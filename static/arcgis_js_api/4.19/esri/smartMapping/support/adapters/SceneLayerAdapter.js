// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.19/esri/copyright.txt for details.
//>>built
define("../../../chunks/_rollupPluginBabelHelpers ../../../chunks/tslib.es6 ../../../core/has ../../../core/maybe ../../../core/Logger ../../../core/accessorSupport/ensureType ../../../core/accessorSupport/decorators/property ../../../core/jsonMap ../../../core/accessorSupport/decorators/subclass ../../../core/Error ../../../core/urlUtils ../../../core/uuid ../../../portal/support/resourceExtension ../../../core/arrayUtils ../../../core/promiseUtils ../../../layers/support/fieldUtils ../../../Graphic ../../../core/watchUtils ../../../tasks/support/FeatureSet ../utils ../../statistics/support/utils ./LayerAdapter ./support/utils ./FeatureLayerAdapter".split(" "),
function(D,y,v,E,N,O,F,P,G,n,Q,R,S,z,u,w,A,H,B,I,J,K,r,L){v=function(C){function x(a){return C.call(this,a)||this}D._inheritsLoose(x,C);var k=x.prototype;k._hasCachedStatistics=function(a){return this.layer.hasCachedStatistics(a)};k._updateQuery=function(a,b=[],c=[]){if(!c.length)return a;const d=this.layer.objectIdField;a=a.clone();b=b.filter(e=>{e=this.layer.getField(e);return-1===c.indexOf(e.name)});const l=b.some(e=>this.layer.getField(e).name===d);a.outFields=l?b:[...b,d];return a};k._fetchFeaturesFromMemory=
async function(a,b,c){if(!a)throw new n("scene-layer-adapter:insufficient-data","view is required to fetch the features from layerView");a=await a.whenLayerView(this.layer);var d=u.createAbortController();const l=H.whenFalseOnce(a,"updating",d.signal);await u.timeout(l,5E3,d);d=await r.getMissingFields(this,c,a);b=this._updateQuery(b,c,d);b=(await a.queryFeatures(b)).features;return d.length?a.whenGraphicAttributes(b,d):b};k._fetchFeaturesForStats=function(a){return I.getFieldsList({field:a.field,
normalizationField:a.normalizationField,valueExpression:a.valueExpression}).then(b=>this.getSampleFeatures({sampleSize:-1,view:a.view,returnGeometry:a.returnGeometry,requiredFields:b,signal:a.signal}))};k._generateFeatureSetForCachedHistogram=function(a,b=a.minimum,c=a.maximum,d){const l=[];for(var e=0;e<d;e++)l[e]=0;e=a.counts.length;const f=a.minimum,m=a.maximum;for(let h=0;h<e;h++){var g=(h+.5)/e;g=((1-g)*f+g*m-b)/(c-b)*d;0<=g&&g<=d&&(l[g===d?d-1:Math.floor(g)]+=a.counts[h])}const q=[];l.forEach((h,
p)=>{const t=new A({attributes:{}});t.attributes.EXPR_1=p+1;t.attributes.countOFExpr=h;q.push(t)});a=new B;a.features=q;return a};k._getCachedStatistics=function(a,b){const c=this.layer;return a.valueExpression||a.sqlExpression||a.sqlWhere||a.minValue||a.maxValue?Promise.reject(new n("scene-layer-adapter:not-supported","This Layer does not support calculating statistics when 'valueExpression', 'sqlExpression', 'sqlWhere', 'minValue' or 'maxValue' is specified")):c.queryCachedStatistics(b&&b.name,
{signal:a.signal}).then(d=>{d=d.stats;const {min:l,max:e}=d;let {avg:f,stddev:m,sum:g,variance:q,count:h}=d;if(0!==l||0!==e)f=0===f?null:f,g=0===g?null:g,m=0===m?null:m,q=0===q?null:q,h=0===h?null:h;null==h&&null!=g&&null!=f&&(h=Math.round(g/f));return{avg:f,count:h,max:e,min:l,stddev:m,sum:g,variance:q}})};k._getSummaryStatisticsFromMemory=async function(a,b){var c={field:a.field,valueExpression:a.valueExpression,normalizationField:a.normalizationField,view:a.view,signal:a.signal};c=a.features?a.features:
await this._fetchFeaturesForStats(c);if(!c||!c.length)throw new n("scene-layer-adapter:insufficient-data","No features are available to calculate statistics");b=w.isDateField(b);a={...a};if("percent-of-total"===a.normalizationType){const d=(await r.calculateStatsFromMemory({field:a.field},c)).sum;if(null==d)throw new n("scene-layer-adapter:invalid","invalid normalizationTotal");a.normalizationTotal=d}c=await r.calculateStatsFromMemory(a,c,b);return r.processSummaryStatisticsResult(c)};k._getCachedStatisticsForUniqueValues=
function(a,b){const c=this.layer,d=b&&b.name,l=b&&this.getFieldDomain(a.field);return a.valueExpression||a.sqlExpression||a.sqlWhere?Promise.reject(new n("scene-layer-adapter:not-supported","This Layer does not support calculating statistics when 'valueExpression', 'sqlExpression' or 'sqlWhere' is specified")):c.queryCachedStatistics(d,{signal:a.signal}).then(e=>{var f=e.stats;if(!f.mostFrequentValues)return Promise.reject();e=e.labels&&e.labels.labels;const m={},g=[],q="countOF"+d;f.mostFrequentValues.forEach(h=>
{const p=new A({attributes:{}});p.attributes[d]=b&&b.name!==c.objectIdField&&(w.isNumericField(b)||w.isDateField(b))?Number(h.value):h.value;p.attributes[q]=h.count;g.push(p)});e&&e.forEach(h=>{m[h.value]=h.label});f=new B;f.features=g;return r.getUniqueValuesFromFeatureSet(f,this,a.field,m,a.signal)}).then(e=>r.createUVResult(e,l,a.returnAllCodedValues))};k._getUniqueValuesFromMemory=function(a,b){const c=b&&this.getFieldDomain(a.field);b={field:a.field,valueExpression:a.valueExpression,view:a.view,
signal:a.signal};return(a.features?Promise.resolve(a.features):this._fetchFeaturesForStats(b)).then(d=>r.calculateUniqueValuesFromMemory(a,d,c))};k._getCachedStatisticsForHistogram=function(a,b){const c=this.layer;return a.valueExpression||a.sqlExpression||a.sqlWhere||a.normalizationType?Promise.reject(new n("scene-layer-adapter:not-supported","This Layer does not support calculating statistics when 'valueExpression' or 'sqlExpression' or 'sqlWhere' or 'normalizationType' is specified")):c.queryCachedStatistics(b&&
b.name,{signal:a.signal}).then(d=>{var l=d.stats;const {minValue:e,maxValue:f}=a;d=null!=e?e:l.min;const m=null!=f?f:l.max,g=a.numBins||10;l=this._generateFeatureSetForCachedHistogram(l.histogram,d,m,g);return r.getHistogramFromFeatureSet(l,d,m,g)})};k._getClassBreaksFromMemory=async function(a){var b={field:a.field,valueExpression:a.valueExpression,normalizationField:a.normalizationField,view:a.view,signal:a.signal};b=a.features?a.features:await this._fetchFeaturesForStats(b);if(!b||!b.length)throw new n("scene-layer-adapter:insufficient-data",
"No features are available to calculate statistics");a={...a};if("percent-of-total"===a.normalizationType){const c=(await r.calculateStatsFromMemory({field:a.field},b)).sum;if(null==c)throw new n("scene-layer-adapter:invalid","invalid normalizationTotal");a.normalizationTotal=c}return r.calculateClassBreaksFromMemory(a,b)};k._getHistogramFromMemory=function(a){const b={field:a.field,valueExpression:a.valueExpression,normalizationField:a.normalizationField,view:a.view,signal:a.signal};return(a.features?
Promise.resolve(a.features):this._fetchFeaturesForStats(b)).then(c=>{if(!c||!c.length)throw new n("scene-layer-adapter:insufficient-data","No features are available to calculate histogram");const {field:d,normalizationType:l,valueExpression:e,classificationMethod:f,minValue:m,maxValue:g,view:q}=a;var h=null!=m&&null!=g;let p=null;f&&"equal-interval"!==f||l?(h={...a},h.features=c,p=this._getBinParamsFromMemory(h)):p=h?Promise.resolve({min:m,max:g}):this.summaryStatistics({field:d,valueExpression:e,
features:c,view:q,signal:a.signal}).then(t=>t.count?{min:t.min,max:t.max}:Promise.reject(new n("feature-layer-adapter:insufficient-data","No features are available to calculate histogram")));return p.then(t=>r.calculateHistogramFromMemory(a,t,c))})};k._getBinParamsFromMemory=async function(a){const {field:b,valueExpression:c,classificationMethod:d,standardDeviationInterval:l,normalizationType:e,normalizationField:f,minValue:m,maxValue:g,features:q,view:h}=a;return this._getClassBreaksFromMemory({field:b,
valueExpression:c,normalizationType:e,normalizationField:f,classificationMethod:d,standardDeviationInterval:l,minValue:m,maxValue:g,numClasses:a.numBins,features:q,view:h}).then(p=>{const t=p.normalizationTotal;p=p.classBreakInfos;const M=J.getSQLFilterForNormalization({field:b,normalizationType:e,normalizationField:f});return r.generateBinParams({field:b,normalizationType:e,normalizationField:f,normalizationTotal:t,classBreaks:p,where:M,layer:this})})};k.getField=function(a=""){return this.layer.getField(a)};
k.getFieldUsageInfo=function(a){a=this.getField(a);if(!a)return null;a=this.layer.getFieldUsageInfo(a.name);return{supportsLabelingInfo:a.supportsLabelingInfo,supportsPopupTemplate:a.supportsPopupTemplate,supportsRenderer:a.supportsRenderer,supportsLayerQuery:a.supportsLayerQuery,supportsStatistics:!0}};k.getFieldDomain=function(a,b){return this._featureLayerAdapter?this._featureLayerAdapter.getFieldDomain(a,b):null};k.summaryStatistics=function(a){const b=this.getField(a.field);return this._featureLayerAdapter?
this._featureLayerAdapter.summaryStatistics(a):this._hasCachedStatistics(b&&b.name)?this._getCachedStatistics(a,b).catch(()=>{u.throwIfAborted(a.signal);return this._getSummaryStatisticsFromMemory(a,b)}):this._getSummaryStatisticsFromMemory(a,b)};k.uniqueValues=function(a){const b=this.getField(a.field);return this._featureLayerAdapter?this._featureLayerAdapter.uniqueValues(a):this._hasCachedStatistics(b&&b.name)?this._getCachedStatisticsForUniqueValues(a,b).catch(()=>{u.throwIfAborted(a.signal);
return this._getUniqueValuesFromMemory(a,b)}):this._getUniqueValuesFromMemory(a,b)};k.histogram=function(a){const b=this.getField(a.field);return this._featureLayerAdapter?this._featureLayerAdapter.histogram(a):this._hasCachedStatistics(b&&b.name)?this._getCachedStatisticsForHistogram(a,b).catch(()=>{u.throwIfAborted(a.signal);return this._getHistogramFromMemory(a)}):this._getHistogramFromMemory(a)};k.classBreaks=function(a){const b=this.getField(a.field);return this._featureLayerAdapter?this._featureLayerAdapter.classBreaks(a):
this._hasCachedStatistics(b&&b.name)?Promise.reject(new n("scene-layer-adapter:not-supported","Cached stats not supported")):this._getClassBreaksFromMemory(a)};k.queryFeatureCount=function(a,b){return this._featureLayerAdapter?this._featureLayerAdapter.queryFeatureCount(a,b):Promise.reject(new n("scene-layer-adapter:not-supported","SceneLayer without associated FeatureLayer does not support count query"))};k.generateRenderer=function(a,b){return this._featureLayerAdapter?this._featureLayerAdapter.generateRenderer(a,
b):Promise.reject(new n("scene-layer-adapter:not-supported","SceneLayer without associated FeatureLayer does not support generateRenderer operation"))};k.heatmapStatistics=function(a){return this._featureLayerAdapter?this._featureLayerAdapter.heatmapStatistics(a):Promise.reject(new n("scene-layer-adapter:not-supported","SceneLayer without associated FeatureLayer does not support heatmapStatistics operation"))};k.predominantCategories=async function(a){if(this._featureLayerAdapter)return this._featureLayerAdapter.predominantCategories(a);
throw new n("scene-layer-adapter:not-supported","SceneLayer without associated FeatureLayer does not support predominantCategories");};k.getSampleFeatures=async function(a){const {view:b,sampleSize:c,requiredFields:d,returnGeometry:l,signal:e}=a;var f=this.layer.createQuery();f.outFields=d;f.returnGeometry=!!l;f.where=null;f.num=c;let m=[];try{if(m=await this._fetchFeaturesFromMemory(b,f,d),m.length&&0<c&&c<=m.length)return z.pickRandom(m,c,1)}catch(g){u.throwIfAborted(e)}f=null;this._featureLayerAdapter&&
(a={...a},delete a.view,f=await this._featureLayerAdapter.getSampleFeatures(a));return f&&f.length?f:z.pickRandom(m,m.length,1)};k.load=function(a){const b=this.layer.load(a).then(c=>{const d=c.associatedLayer;this.geometryType=c.geometryType;if(E.isSome(d))return this._featureLayerAdapter=new L({layer:d}),this._featureLayerAdapter.load(a).then(()=>{this.objectIdField=this._featureLayerAdapter.objectIdField;this.supportsSQLExpression=this._featureLayerAdapter.supportsSQLExpression;this.minScale=this._featureLayerAdapter.minScale;
this.maxScale=this._featureLayerAdapter.maxScale;this.fullExtent=this._featureLayerAdapter.fullExtent});this.objectIdField=c.objectIdField;this.hasQueryEngine=this.supportsSQLExpression=!1;this.fullExtent=c.fullExtent});this.addResolvingPromise(b);return Promise.resolve(this)};return x}(K);y.__decorate([F.property({constructOnly:!0})],v.prototype,"layer",void 0);return v=y.__decorate([G.subclass("esri.smartMapping.support.adapters.SceneLayerAdapter")],v)});