// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.19/esri/copyright.txt for details.
//>>built
define("../../../chunks/_rollupPluginBabelHelpers ../../../chunks/tslib.es6 ../../../core/has ../../../core/maybe ../../../core/Logger ../../../core/accessorSupport/ensureType ../../../core/accessorSupport/decorators/property ../../../core/jsonMap ../../../core/accessorSupport/decorators/subclass ../../../core/Error ../../../core/urlUtils ../../../core/uuid ../../../portal/support/resourceExtension ../../../core/arrayUtils ../../../core/promiseUtils ../../../geometry/support/spatialReferenceUtils ../../../geometry/Point ../../../geometry ../../../layers/support/fieldUtils ../../../core/watchUtils ../../../layers/support/arcgisLayerUrl ../../../tasks/support/QuantizationParameters ../../../tasks/support/StatisticDefinition ../../../tasks/GenerateRendererTask ../../../geometry/support/quantizationUtils ../utils ../../statistics/support/utils ../../statistics/support/predominanceUtils ./LayerAdapter ./support/utils ../../../tasks/support/GenerateRendererParameters ../../../tasks/support/UniqueValueDefinition".split(" "),
function(K,F,z,L,M,Z,N,aa,O,r,ba,ca,da,G,x,H,P,ea,A,Q,R,S,B,T,I,U,q,C,V,n,D,W){const X=M.getLogger("esri.smartMapping.support.adapters.FeatureLayerAdapter");z=function(J){function E(a){return J.call(this,a)||this}K._inheritsLoose(E,J);var m=E.prototype;m.destroy=function(){this._hasLocalSource=null};m._isStatsSupportedOnService=function(){const a=this.layer;return!a.get("capabilities.query.supportsStatistics")||"multipatch"===this.geometryType&&!R.isHostedAgolService(a.url)&&10.5>a.version?Promise.reject(new r("feature-layer-adapter:not-supported",
"Layer does not support statistics query")):Promise.resolve()};m._fetchFeaturesFromMemory=async function(a,b,c){var e=this.layer;if(this._hasLocalSource)return(await e.queryFeatures(b)).features;if(!a)throw new r("feature-layer-adapter:insufficient-data","layerView is required to fetch the features");e=x.createAbortController();const f=Q.whenFalseOnce(a,"updating",e.signal);await x.timeout(f,5E3,e).catch(g=>{X.warn("LayerView is taking too long to update. Aborting fetch from layerView.");throw g;
});return(await a.queryFeatures(b,{signal:c})).features};m._fetchFeaturesFromService=function(a,b){return this.layer.queryFeatures(a,{signal:b}).then(c=>c&&c.features)};m._fetchFeaturesForStats=function(a){return U.getFieldsList({field:a.field,normalizationField:a.normalizationField,valueExpression:a.valueExpression}).then(b=>this.getSampleFeatures({sampleSize:-1,view:a.view,returnGeometry:a.returnGeometry,requiredFields:b,signal:a.signal}))};m._summaryStatsFromGenRend=function(a){const b=a.normalizationType,
c=a.normalizationField;return this.classBreaks({field:a.field,numClasses:5,classificationMethod:"standard-deviation",standardDeviationInterval:.25,normalizationType:b,normalizationField:"field"===b?c:void 0,minValue:a.minValue,maxValue:a.maxValue,signal:a.signal}).then(e=>{let f,g;e.classBreakInfos.some(h=>{h.hasAvg&&(f=h);return!!f});if(f){var d=f.maxValue-f.minValue;g=f.minValue+d/2;d*=4}return n.processSummaryStatisticsResult({min:e.minValue,max:e.maxValue,avg:g,stddev:d})})};m._getSummaryStatsQuery=
function(a,b){const {field:c,normalizationType:e,normalizationField:f,normalizationTotal:g}=a;b=this.supportsSQLExpression&&b?n.msSinceUnixEpochSQL(this,c):a.sqlExpression;var d=n.getFieldExpr({field:c,normalizationType:e,normalizationField:f,normalizationTotal:g,layer:this});const h=b||d;d=h?q.getRangeExpr(h,a.minValue,a.maxValue):null;const k=q.getSQLFilterForNormalization({field:c,normalizationField:f,normalizationType:e});a=q.mergeWhereClauses(a.sqlWhere,k);a=q.mergeWhereClauses(a,d);d=this.layer.createQuery();
d.where=q.mergeWhereClauses(d.where,a);d.sqlFormat=b?"standard":null;d.outStatistics=n.statisticTypes.map(l=>{const p=new B;p.statisticType="variance"===l?"var":l;p.onStatisticField=h;p.outStatisticFieldName=l+"_value";return p});return d};m._summaryStatsFromServiceQuery=async function(a,b){await this._isStatsSupportedOnService();"percent-of-total"===a.normalizationType&&(a.normalizationTotal=await this._getNormalizationTotal(a.field,a.normalizationType));const c=this._getSummaryStatsQuery(a,b);a=
await this.layer.queryFeatures(c,{signal:a.signal});b=n.getSummaryStatisticsFromFeatureSet(a,b);return n.processSummaryStatisticsResult(b)};m._summaryStatsFromClientQuery=async function(a,b){const c=this._getSummaryStatsQuery(a,b);a=await this.layer.queryFeatures(c,{signal:a.signal});b=n.getSummaryStatisticsFromFeatureSet(a,b);return n.processSummaryStatisticsResult(b)};m._summaryStatsFromMemory=async function(a,b){var c=a.field,e={field:c,valueExpression:a.valueExpression,normalizationField:a.normalizationField,
view:a.view,signal:a.signal};e=a.features||await this._fetchFeaturesForStats(e);if(!e||!e.length)throw new r("feature-layer-adapter:insufficient-data","No features are available to calculate statistics");a={...a};if("percent-of-total"===a.normalizationType){c=(await n.calculateStatsFromMemory({field:c},e)).sum;if(null==c)throw new r("feature-layer-adapter:invalid","invalid normalizationTotal");a.normalizationTotal=c}b=await n.calculateStatsFromMemory(a,e,b);return n.processSummaryStatisticsResult(b)};
m._uvFromGenRenderer=function(a,b){const c=a.field,e=new W;e.attributeField=c;const f=new D;f.classificationDefinition=e;return this.generateRenderer(f,a.signal).then(g=>{const d={},h=this.getField(c);g.uniqueValues.forEach(k=>{let l=k.value;if(null==l||""===l||"string"===typeof l&&(""===l.trim()||"\x3cnull\x3e"===l.toLowerCase()))l=null;null==d[l]?d[l]={count:k.count,data:A.isNumericField(h)&&l?Number(l):l}:d[l].count+=k.count});return{count:d}}).then(g=>n.createUVResult(g,b,a.returnAllCodedValues))};
m._getUVQuery=function(a){const b=a.field,c=a.sqlExpression;var e="countOF"+(b||"Expr");const f=new B;f.statisticType="count";f.onStatisticField=c?"1":b;f.outStatisticFieldName=e;e=this.layer.createQuery();e.where=q.mergeWhereClauses(e.where,a.sqlWhere);e.sqlFormat=c?"standard":null;e.outStatistics=[f];e.groupByFieldsForStatistics=[b||c];return e};m._uvFromServiceQuery=function(a,b){return this._isStatsSupportedOnService().then(()=>this.layer.queryFeatures(this._getUVQuery(a),{signal:a.signal})).then(c=>
n.getUniqueValuesFromFeatureSet(c,this,a.field,null,a.signal)).then(c=>n.createUVResult(c,b,a.returnAllCodedValues))};m._uvFromClientQuery=async function(a,b){var {signal:c}=a,e=this._getUVQuery(a);e=await this.layer.queryFeatures(e,{signal:c});c=await n.getUniqueValuesFromFeatureSet(e,this,a.field,null,c);return n.createUVResult(c,b,a.returnAllCodedValues)};m._uvFromMemory=async function(a,b){const {field:c,valueExpression:e,view:f,signal:g}=a;var d={field:c,valueExpression:e,view:f,signal:g};d=
a.features?a.features:await this._fetchFeaturesForStats(d);return n.calculateUniqueValuesFromMemory(a,d,b)};m._calcBinsSQL=function(a,b,c){const e=[],f=b.length;b.forEach((g,d)=>{const [h,k]=g;g=null;g=0!==d||c?d!==f-1||c?q.mergeWhereClauses(`${a} >= ${h}`,`${a} ${d===f-1?" \x3c\x3d ":" \x3c "} ${k}`):`${a} >= ${h}`:`${a} < ${k}`;e.push("WHEN ("+g+") THEN "+(d+1))});return["CASE",e.join(" "),"ELSE 0 END"].join(" ")};m._getNormalizationTotal=function(a,b,c){return a&&"percent-of-total"===b?this.summaryStatistics({field:a,
signal:c}).then(e=>e.sum):Promise.resolve(null)};m._getQueryParamsForExpr=function(a,b){const c=a.signal;if(!a.valueExpression&&!a.sqlExpression){const {field:f,normalizationType:g,normalizationField:d}=a;var e=f?this.getField(f):null;e=A.isDateField(e);b={field:f,normalizationType:g,normalizationField:d,normalizationTotal:b,layer:this};return{sqlExpression:e?n.msSinceUnixEpochSQL(this,f):n.getFieldExpr(b),sqlWhere:e?null:a.sqlWhere||q.getSQLFilterForNormalization({field:f,normalizationType:g,normalizationField:d}),
signal:c}}return{valueExpression:a.valueExpression,sqlExpression:a.sqlExpression,sqlWhere:a.sqlWhere,signal:c}};m._getDataRange=function(a,b,c){return null!=b&&null!=c?Promise.resolve({min:b,max:c}):this.summaryStatistics(a).then(e=>({min:e.min,max:e.max}))};m._histogramForExpr=function(a){return this._getNormalizationTotal(a.field,a.normalizationType,a.signal).then(b=>{const c=this._getQueryParamsForExpr(a,b);return this._getDataRange(c,a.minValue,a.maxValue).then(e=>{const {min:f,max:g}=e,d=a.numBins||
10;e=n.getEqualIntervalBins(f,g,d);e=this._calcBinsSQL(c.sqlExpression,e,null!=a.minValue&&null!=a.maxValue);const h=new B({statisticType:"count",outStatisticFieldName:"countOFExpr",onStatisticField:"1"}),k=this.layer.createQuery();k.where=q.mergeWhereClauses(k.where,c.sqlWhere);k.sqlFormat="standard";k.outStatistics=[h];k.groupByFieldsForStatistics=[e];k.orderByFields=[e];return this._isStatsSupportedOnService().then(()=>this.layer.queryFeatures(k,{signal:c.signal})).then(l=>n.getHistogramFromFeatureSet(l,
f,g,d,b))})})};m._histogramForField=function(a){let b=null;b=null!=a.minValue&&null!=a.maxValue?Promise.resolve({min:a.minValue,max:a.maxValue}):this.summaryStatistics(a).then(c=>{if(!c.count)throw new r("feature-layer-adapter:insufficient-data","Either the layer has no features or none of the features have data for the field");return{min:c.min,max:c.max}});return b.then(c=>this._getBins({min:c.min,max:c.max},a.field,a.numBins,a.signal))};m._getBins=function(a,b,c=10,e){const {min:f,max:g,normTotal:d,
excludeZerosExpr:h}=a,k=a.intervals||n.getEqualIntervalBins(f,g,c);return this._queryBins(k,a.sqlExpr||b,h,e).then(l=>({bins:l.map((p,t)=>({minValue:k[t][0],maxValue:k[t][1],count:p.value})),minValue:f,maxValue:g,normalizationTotal:d}))};m._queryBins=function(a,b,c,e){const f=[],g=a.length;for(let d=0;d<g;d++){const h=q.mergeWhereClauses(c,q.mergeWhereClauses(b+" \x3e\x3d "+a[d][0],null!==a[d][1]?b+(d===g-1?" \x3c\x3d ":" \x3c ")+a[d][1]:""));f.push(h)}return x.eachAlways(f.map(d=>this.queryFeatureCount(d,
e)))};m._binParamsFromGenRend=function(a,b){const {field:c,normalizationType:e,normalizationField:f,signal:g}=a,d=q.getSQLFilterForNormalization({field:c,normalizationType:e,normalizationField:f});a=new D({classificationDefinition:n.createCBDefn({field:c,normalizationType:e,normalizationField:f,classificationMethod:a.classificationMethod,standardDeviationInterval:a.standardDeviationInterval,breakCount:a.numBins||10}),where:q.mergeWhereClauses(d,b)});return this.generateRenderer(a,g).then(h=>{const {normalizationTotal:k,
classBreaks:l}=h;return n.generateBinParams({field:c,normalizationType:e,normalizationField:f,normalizationTotal:k,classBreaks:l,where:d,layer:this})})};m._histogramFromMemory=function(a){const {field:b,normalizationField:c,normalizationType:e,valueExpression:f,classificationMethod:g,minValue:d,maxValue:h,view:k,signal:l}=a,p={field:b,valueExpression:f,normalizationField:c,view:k,signal:l};return(a.features?Promise.resolve(a.features):this._fetchFeaturesForStats(p)).then(t=>{if(!t||!t.length)throw new r("feature-layer-adapter:insufficient-data",
"No features are available to calculate histogram");var u=null!=d&&null!=h;let y=null;g&&"equal-interval"!==g||e?(u={...a},u.features=t,y=this._getBinParamsFromMemory(u)):y=u?Promise.resolve({min:d,max:h,source:"parameters"}):this.summaryStatistics({field:b,valueExpression:f,features:t,view:k,signal:l}).then(v=>v.count?{min:v.min,max:v.max}:Promise.reject(new r("feature-layer-adapter:insufficient-data","No features are available to calculate histogram")));return y.then(v=>n.calculateHistogramFromMemory(a,
v,t))})};m._getBinParamsFromMemory=async function(a){const {field:b,valueExpression:c,classificationMethod:e,standardDeviationInterval:f,normalizationType:g,normalizationField:d,minValue:h,maxValue:k,features:l,view:p,signal:t}=a;return this._classBreaksFromMemory({field:b,valueExpression:c,normalizationType:g,normalizationField:d,classificationMethod:e,standardDeviationInterval:f,minValue:h,maxValue:k,numClasses:a.numBins,features:l,view:p,signal:t}).then(u=>{const y=u.normalizationTotal;u=u.classBreakInfos;
const v=q.getSQLFilterForNormalization({field:b,normalizationType:g,normalizationField:d});return n.generateBinParams({field:b,normalizationType:g,normalizationField:d,normalizationTotal:y,classBreaks:u,where:v,layer:this})})};m._classBreaksFromGenRend=function(a){const {field:b,normalizationType:c,normalizationField:e,normalizationTotal:f,signal:g}=a,d=q.getSQLFilterForNormalization({field:b,normalizationType:c,normalizationField:e});var h=n.getFieldExpr({field:b,normalizationType:c,normalizationField:e,
normalizationTotal:f,layer:this});h=q.getRangeExpr(h,a.minValue,a.maxValue);const k=n.createCBDefn({field:b,normalizationType:c,normalizationField:e,classificationMethod:a.classificationMethod,standardDeviationInterval:a.standardDeviationInterval,breakCount:a.numClasses||5}),l=new D;l.classificationDefinition=k;l.where=q.mergeWhereClauses(d,h);return this.generateRenderer(l,g).then(p=>n.resolveCBResult(a,p))};m._classBreaksFromInterpolation=function(a){const {minValue:b,maxValue:c}=a,e=a.numClasses||
5,f=[],g=(c-b)/e;for(let d=0;d<e;d++){const h=b+d*g;f.push({minValue:h,maxValue:h+g})}f[e-1].maxValue=c;a=n.resolveCBResult(a,{classBreaks:f,normalizationTotal:a.normalizationTotal});return Promise.resolve(a)};m._classBreaksFromMemory=async function(a){const {field:b,normalizationField:c,valueExpression:e,view:f,signal:g}=a;var d={field:b,valueExpression:e,normalizationField:c,view:f,signal:g};d=a.features||await this._fetchFeaturesForStats(d);if(!d||!d.length)throw new r("feature-layer-adapter:insufficient-data",
"No features are available to calculate statistics");a={...a};if("percent-of-total"===a.normalizationType){const h=(await n.calculateStatsFromMemory({field:b},d)).sum;if(null==h)throw new r("feature-layer-adapter:invalid","invalid normalizationTotal");a.normalizationTotal=h}return n.calculateClassBreaksFromMemory(a,d)};m._heatmapStatsFromMemory=async function(a,b){const {blurRadius:c,field:e,view:f,signal:g}=a,{resolution:d,size:h}=f.state,k=new S({extent:f.extent,tolerance:d});a=this._quantizeFeatures(a.features||
await this._fetchFeaturesForStats({field:e,view:f,returnGeometry:!0,signal:g}),k,f);if(!a||!a.length)return{count:0,min:null,max:null,avg:null,stddev:null};if(b=n.calculateHeatmapStats(a,c,b,e,h[0],h[1]))return{count:b.count,min:b.min,max:b.max,avg:b.mean,stddev:b.stdDev};throw new r("feature-layer-adapter:invalid","unable to calculate heatmap statistics");};m._quantizeFeatures=function(a,b,c){const e=I.toQuantizationTransform(b),{spatialReference:f,size:g}=c,d=H.isWrappable(f)?H.getInfo(f):null,
h=d?Math.round((d.valid[1]-d.valid[0])/e.scale[0]):null;return a.map(k=>{const l=new P(L.unwrap(k.geometry));I.quantizePoint(e,l,l,l.hasZ,l.hasM);k.geometry=d?this._wrapPoint(l,h,g[0]):l;return k})};m._wrapPoint=function(a,b,c){0>a.x?a.x+=b:a.x>c&&(a.x-=b);return a};m.getField=function(a=""){return this.layer.getField(a)};m.getFieldUsageInfo=function(a){return this.getField(a)?{supportsLabelingInfo:!0,supportsRenderer:!0,supportsPopupTemplate:!0,supportsLayerQuery:!0,supportsStatistics:!0}:null};
m.getFieldDomain=function(a,b){return this.layer.getFieldDomain(a,b)};m.summaryStatistics=function(a){const {field:b,normalizationType:c,sqlExpression:e,view:f,features:g}=a;var d=b?this.getField(b):null;const h=A.isDateField(d),k=(d=a.valueExpression||e)&&!e,l=f&&"3d"===f.type;return this._hasLocalSource||g||k?k||g||l?this._summaryStatsFromMemory(a,h):this._summaryStatsFromClientQuery(a,h):this.supportsSQLExpression||!h&&!d&&"natural-log"!==c&&"square-root"!==c?(c&&!this.supportsSQLExpression?this._summaryStatsFromGenRend(a):
this._summaryStatsFromServiceQuery(a,h)).catch(()=>{x.throwIfAborted(a.signal);return this._summaryStatsFromMemory(a,h)}):Promise.reject(new r("feature-layer-adapter:not-supported","Layer does not support standardized SQL expression for queries"))};m.uniqueValues=function(a){const {field:b,valueExpression:c,sqlExpression:e,signal:f}=a,g=(b?this.getField(b):null)&&this.getFieldDomain(b),d=c&&(!e||!this.supportsSQLExpression),h=a.view,k=h&&"3d"===h.type;return this._hasLocalSource||a.features||d?d||
a.features||k?this._uvFromMemory(a,g):this._uvFromClientQuery(a,g):this._uvFromServiceQuery(a,g).catch(l=>{x.throwIfAborted(f);return a.field?this._uvFromGenRenderer(a,g):l}).catch(()=>{x.throwIfAborted(f);return d||a.features||k?this._uvFromMemory(a,g):this._uvFromClientQuery(a,g)})};m.histogram=function(a){const {field:b,normalizationType:c,normalizationField:e,classificationMethod:f,signal:g}=a;var d=b?this.getField(b):null;d=A.isDateField(d);const h=a.valueExpression||a.sqlExpression,k=h&&!a.sqlExpression,
l=this.supportsSQLExpression,p=!f||"equal-interval"===f,t=a.minValue,u=a.maxValue,y=null!=t&&null!=u,v=a.numBins||10;return this._hasLocalSource||a.features||k?this._histogramFromMemory(a):(h||l)&&p?l||!h&&"natural-log"!==c&&"square-root"!==c?this._histogramForExpr(a):Promise.reject(new r("feature-layer-adapter:not-supported","Layer does not support standardized SQL expression for queries")):d&&p?Promise.reject(new r("feature-layer-adapter:not-supported","Normalization and date field are not allowed when layer does not support standardized SQL expression for queries")):
c||!p?this._binParamsFromGenRend(a).then(w=>{if(!y)return this._getBins(w,b,v,g);if(t>w.max||u<w.min)throw new r("histogram:insufficient-data","Range defined by 'minValue' and 'maxValue' does not intersect available data range of the field");if(p)return this._getBins({min:t,max:u,sqlExpr:w.sqlExpr,excludeZerosExpr:w.excludeZerosExpr},b,v,g);w=n.getFieldExpr({field:b,normalizationType:c,normalizationField:e,normalizationTotal:w.normTotal,layer:this});w=q.getRangeExpr(w,t,u);return this._binParamsFromGenRend(a,
w).then(Y=>this._getBins(Y,b,v,g))}):this._histogramForField(a)};m.classBreaks=function(a){const b=!1!==a.analyzeData,c=this._hasLocalSource||a.features||a.valueExpression;return b&&c?this._classBreaksFromMemory(a):(b?this._classBreaksFromGenRend(a):this._classBreaksFromInterpolation(a)).catch(()=>{x.throwIfAborted(a.signal);return this._classBreaksFromMemory(a)})};m.queryFeatureCount=function(a,b){if(this._hasLocalSource)return Promise.reject(new r("feature-layer-adapter:not-supported","Layer does not support count query"));
const c=this.layer,e=c.createQuery();e.where=q.mergeWhereClauses(e.where,a);return c.queryFeatureCount(e,{signal:b})};m.generateRenderer=function(a,b){var c=this.layer;if(this._hasLocalSource||10.1>c.version)return Promise.reject(new r("feature-layer-adapter:not-supported","Layer does not support generateRenderer operation (requires ArcGIS Server version 10.1+)"));const e=new T({url:c.parsedUrl.path,source:c.dynamicDataSource,gdbVersion:c.gdbVersion});c=c.createQuery();a.where=q.mergeWhereClauses(a.where,
c.where);return e.execute(a,{signal:b})};m.heatmapStatistics=function(a){const {field:b,fieldOffset:c,signal:e}=a;return(b&&null==c?this.summaryStatistics({field:b,signal:e}):Promise.resolve(null)).then(f=>{let g=c||0;if(f){const {count:d,min:h,max:k}=f;d?h===k&&0===h?g=1:0>=k?g="abs":0>h&&(g=-1.01*h):g=1}return this._heatmapStatsFromMemory(a,g).then(d=>({...d,summaryStatistics:f,fieldOffset:g}))})};m.predominantCategories=async function(a){if(!this._hasLocalSource&&!this.supportsSQLExpression)throw new r("feature-layer-adapter:not-supported",
"Layer does not support advanced SQL expressions and standardized queries");const {fields:b,view:c,signal:e}=a;a=C.getArcadeForPredominantCategory(b);var f=C.getSQLForPredominantCategoryName(b);a=(c&&this._hasLocalSource?await this._uvFromMemory({valueExpression:a,view:c,signal:e}):await this._uvFromServiceQuery({sqlExpression:f.expression,valueExpression:a,signal:e})).uniqueValueInfos;const g=a.map(d=>d.value);f=b.filter(d=>-1===g.indexOf(d));for(const d of f)a.push({value:d,count:0});a.sort((d,
h)=>b.indexOf(d.value)-b.indexOf(h.value));for(const d of a)d.value===C.noDominantCategoryField&&(d.value=null);return{predominantCategoryInfos:a}};m.getSampleFeatures=async function(a){const {view:b,sampleSize:c,requiredFields:e,returnGeometry:f,signal:g}=a,d=this.layer.createQuery();d.outSpatialReference=a.spatialReference||b&&b.spatialReference;d.returnGeometry=!!f;d.outFields=e;let h=[];var k=!1;if(b)try{const l=await b.whenLayerView(this.layer);if(k=!(await n.getMissingFields(this,e,l)).length)if(h=
await this._fetchFeaturesFromMemory(l,d,g),h.length&&0<c&&c<=h.length)return G.pickRandom(h,c,1)}catch(l){x.throwIfAborted(g)}try{if(this._hasLocalSource)return k?h:this._fetchFeaturesFromService(d,g);const l=await this.queryFeatureCount(null,g),p=this.layer.capabilities.query.maxRecordCount;k=-1===c?l:c;k=p&&k>p?p:k;if(l<=h.length||h.length>=p)return h;const t=b.extent.width/b.width/b.scale*4E5;d.maxAllowableOffset=a.resolution||t;if(l<=k)return this._fetchFeaturesFromService(d,g);if(2E4>=l){const u=
await this.layer.queryObjectIds();d.objectIds=G.pickRandom(u,k,1);return this._fetchFeaturesFromService(d,g)}this.layer.get("capabilities.query.supportsPagination")&&(d.num=Math.min(k,2E4));return this._fetchFeaturesFromService(d,g)}catch(l){return x.throwIfAborted(g),h}};m.load=function(a){a=this.layer.load(a).then(b=>{this.geometryType=b.geometryType;this.objectIdField=b.objectIdField;this.supportsSQLExpression=b.get("capabilities.query.supportsSqlExpression");this.hasQueryEngine=this._hasLocalSource=
!b.url&&!!b.source;this.minScale=b.minScale;this.maxScale=b.maxScale;this.fullExtent=b.fullExtent});this.addResolvingPromise(a);return Promise.resolve(this)};return E}(V);F.__decorate([N.property({constructOnly:!0})],z.prototype,"layer",void 0);return z=F.__decorate([O.subclass("esri.smartMapping.support.adapters.FeatureLayerAdapter")],z)});