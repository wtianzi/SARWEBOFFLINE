// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.19/esri/copyright.txt for details.
//>>built
define("exports ../../../../core/compilerUtils ../../../../core/urlUtils ../../../../core/Version ../../../../chunks/mat4 ../../../../chunks/mat4f64 ../../../../chunks/quatf64 ../../support/buffer/BufferView ../../../../chunks/quat ./BinaryStreamReader ./fillDefaults ./pathUtils ../../../../chunks/scalar".split(" "),function(w,D,p,x,m,t,E,k,F,y,u,G,v){function H(e){switch(e.componentType){case 5120:return new k.BufferViewVec2i8(e.raw,e.byteOffset,e.byteStride,e.byteOffset+e.byteStride*e.entryCount);
case 5121:return new k.BufferViewVec2u8(e.raw,e.byteOffset,e.byteStride,e.byteOffset+e.byteStride*e.entryCount);case 5122:return new k.BufferViewVec2i16(e.raw,e.byteOffset,e.byteStride,e.byteOffset+e.byteStride*e.entryCount);case 5123:return new k.BufferViewVec2u16(e.raw,e.byteOffset,e.byteStride,e.byteOffset+e.byteStride*e.entryCount);case 5125:return new k.BufferViewVec2u32(e.raw,e.byteOffset,e.byteStride,e.byteOffset+e.byteStride*e.entryCount);case 5126:return new k.BufferViewVec2f(e.raw,e.byteOffset,
e.byteStride,e.byteOffset+e.byteStride*e.entryCount);default:D.neverReached(e.componentType)}}async function I(e){return new Promise((h,a)=>{const c=new Blob([e]),b=new FileReader;b.onload=()=>{h(JSON.parse(b.result))};b.onerror=f=>{a(f)};b.readAsText(c)})}async function J(e,h){return new Promise((a,c)=>{const b=new Blob([e],{type:h}),f=URL.createObjectURL(b),d=new Image;d.addEventListener("load",()=>{URL.revokeObjectURL(f);"decode"in d?d.decode().then(()=>a(d),()=>a(d)):a(d)});d.addEventListener("error",
g=>{URL.revokeObjectURL(f);c(g)});d.src=f})}let O=function(){function e(a,c,b,f,d){this.context=a;this.errorContext=c;this.uri=b;this.json=f;this.glbBuffer=d;this.bufferCache=new Map;this.textureCache=new Map;this.materialCache=new Map;this.nodeParentMap=new Map;this.nodeTransformCache=new Map;this.baseUri=G.splitURI(this.uri).dirPart;this.checkVersionSupported();this.checkRequiredExtensionsSupported();c.errorUnsupportedIf(null==f.scenes,"Scenes must be defined.");c.errorUnsupportedIf(null==f.meshes,
"Meshes must be defined");c.errorUnsupportedIf(null==f.nodes,"Nodes must be defined.");this.computeNodeParents()}e.load=async function(a,c,b,f){if(p.isDataProtocol(b)){var d=p.dataComponents(b);if("model/gltf-binary"!==d.mediaType)try{const g=JSON.parse(d.isBase64?atob(d.data):d.data);return new e(a,c,b,g)}catch{}d=p.dataToArrayBuffer(b);if(e.isGLBData(d))return this.fromGLBData(a,c,b,d)}if(b.endsWith(".gltf"))return f=await a.loadJSON(b,f),new e(a,c,b,f);d=await a.loadBinary(b,f);if(e.isGLBData(d))return this.fromGLBData(a,
c,b,d);f=await a.loadJSON(b,f);return new e(a,c,b,f)};e.isGLBData=function(a){a=new y.BinaryStreamReader(a);return 4<=a.remainingBytes()&&1179937895===a.readUint32()};e.fromGLBData=async function(a,c,b,f){f=await e.parseGLBData(c,f);return new e(a,c,b,f.json,f.binaryData)};e.parseGLBData=async function(a,c){const b=new y.BinaryStreamReader(c);a.assert(12<=b.remainingBytes(),"GLB binary data is insufficiently large.");var f=b.readUint32(),d=b.readUint32();const g=b.readUint32();a.assert(1179937895===
f,"Magic first 4 bytes do not fit to expected GLB value.");a.assert(c.byteLength>=g,"GLB binary data is smaller than header specifies.");a.errorUnsupportedIf(2!==d,"An unsupported GLB container version was detected. Only version 2 is supported.");c=0;let l,n;for(;8<=b.remainingBytes();)f=b.readUint32(),d=b.readUint32(),0===c?(a.assert(1313821514===d,"First GLB chunk must be JSON."),a.assert(0<=f,"No JSON data found."),l=await I(b.readUint8Array(f))):1===c?(a.errorUnsupportedIf(5130562!==d,"Second GLB chunk expected to be BIN."),
n=b.readUint8Array(f)):a.warnUnsupported("More than 2 GLB chunks detected. Skipping."),c+=1;l||a.error("No GLB JSON chunk detected.");return{json:l,binaryData:n}};var h=e.prototype;h.getBuffer=async function(a,c){const b=this.json.buffers[a],f=this.errorContext;if(null==b.uri)return f.assert(null!=this.glbBuffer,"GLB buffer not present"),this.glbBuffer;let d=this.bufferCache.get(a);d||(c=await this.context.loadBinary(this.resolveUri(b.uri),c),d=new Uint8Array(c),this.bufferCache.set(a,d),f.assert(d.byteLength===
b.byteLength,"Buffer byte lengths should match."));return d};h.getAccessor=async function(a,c){a=this.json.accessors[a];var b=this.errorContext;b.errorUnsupportedIf(null==a.bufferView,"Some accessor does not specify a bufferView.");b.errorUnsupportedIf(a.type in["MAT2","MAT3","MAT4"],`AttributeType ${a.type} is not supported`);b=this.json.bufferViews[a.bufferView];c=await this.getBuffer(b.buffer,c);const f=K[a.type],d=L[a.componentType],g=f*d,l=b.byteStride||g;return{raw:c.buffer,byteStride:l,byteOffset:c.byteOffset+
(b.byteOffset||0)+(a.byteOffset||0),entryCount:a.count,isDenselyPacked:l===g,componentCount:f,componentByteSize:d,componentType:a.componentType,min:a.min,max:a.max,normalized:!!a.normalized}};h.getIndexData=async function(a,c){if(null==a.indices)return null;a=await this.getAccessor(a.indices,c);if(a.isDenselyPacked)switch(a.componentType){case 5121:return new Uint8Array(a.raw,a.byteOffset,a.entryCount);case 5123:return new Uint16Array(a.raw,a.byteOffset,a.entryCount);case 5125:return new Uint32Array(a.raw,
a.byteOffset,a.entryCount)}else switch(a.componentType){case 5121:return v.makeDense(this.wrapAccessor(k.BufferViewUint8,a));case 5123:return v.makeDense(this.wrapAccessor(k.BufferViewUint16,a));case 5125:return v.makeDense(this.wrapAccessor(k.BufferViewUint32,a))}};h.getPositionData=async function(a,c){const b=this.errorContext;b.errorUnsupportedIf(null==a.attributes.POSITION,"No POSITION vertex data found.");a=await this.getAccessor(a.attributes.POSITION,c);b.errorUnsupportedIf(5126!==a.componentType,
"Expected type FLOAT for POSITION vertex attribute, but found "+q[a.componentType]);b.errorUnsupportedIf(3!==a.componentCount,"POSITION vertex attribute must have 3 components, but found "+a.componentCount.toFixed());return this.wrapAccessor(k.BufferViewVec3f,a)};h.getNormalData=async function(a,c){const b=this.errorContext;b.assert(null!=a.attributes.NORMAL,"No NORMAL vertex data found.");a=await this.getAccessor(a.attributes.NORMAL,c);b.errorUnsupportedIf(5126!==a.componentType,"Expected type FLOAT for NORMAL vertex attribute, but found "+
q[a.componentType]);b.errorUnsupportedIf(3!==a.componentCount,"NORMAL vertex attribute must have 3 components, but found "+a.componentCount.toFixed());return this.wrapAccessor(k.BufferViewVec3f,a)};h.getTangentData=async function(a,c){const b=this.errorContext;b.assert(null!=a.attributes.TANGENT,"No TANGENT vertex data found.");a=await this.getAccessor(a.attributes.TANGENT,c);b.errorUnsupportedIf(5126!==a.componentType,"Expected type FLOAT for TANGENT vertex attribute, but found "+q[a.componentType]);
b.errorUnsupportedIf(4!==a.componentCount,"TANGENT vertex attribute must have 4 components, but found "+a.componentCount.toFixed());return new k.BufferViewVec4f(a.raw,a.byteOffset,a.byteStride,a.byteOffset+a.byteStride*a.entryCount)};h.getTextureCoordinates=async function(a,c){const b=this.errorContext;b.assert(null!=a.attributes.TEXCOORD_0,"No TEXCOORD_0 vertex data found.");a=await this.getAccessor(a.attributes.TEXCOORD_0,c);b.errorUnsupportedIf(2!==a.componentCount,"TEXCOORD_0 vertex attribute must have 2 components, but found "+
a.componentCount.toFixed());if(5126===a.componentType)return this.wrapAccessor(k.BufferViewVec2f,a);b.errorUnsupportedIf(!a.normalized,"Integer component types are only supported for a normalized accessor for TEXCOORD_0.");return H(a)};h.getVertexColors=async function(a,c){const b=this.errorContext;b.assert(null!=a.attributes.COLOR_0,"No COLOR_0 vertex data found.");a=await this.getAccessor(a.attributes.COLOR_0,c);b.errorUnsupportedIf(4!==a.componentCount&&3!==a.componentCount,"COLOR_0 attribute must have 3 or 4 components, but found "+
a.componentCount.toFixed());if(4===a.componentCount){if(5126===a.componentType)return this.wrapAccessor(k.BufferViewVec4f,a);if(5121===a.componentType)return this.wrapAccessor(k.BufferViewVec4u8,a);if(5123===a.componentType)return this.wrapAccessor(k.BufferViewVec4u16,a)}else if(3===a.componentCount){if(5126===a.componentType)return this.wrapAccessor(k.BufferViewVec3f,a);if(5121===a.componentType)return this.wrapAccessor(k.BufferViewVec3u8,a);if(5123===a.componentType)return this.wrapAccessor(k.BufferViewVec3u16,
a)}b.errorUnsupported("Unsupported component type for COLOR_0 attribute: "+q[a.componentType])};h.hasPositions=function(a){return void 0!==a.attributes.POSITION};h.hasNormals=function(a){return void 0!==a.attributes.NORMAL};h.hasVertexColors=function(a){return void 0!==a.attributes.COLOR_0};h.hasTextureCoordinates=function(a){return void 0!==a.attributes.TEXCOORD_0};h.hasTangents=function(a){return void 0!==a.attributes.TANGENT};h.getMaterial=async function(a,c,b){const f=this.errorContext;var d=
this.materialCache.get(a.material);if(!d){d=null!=a.material?u.material(this.json.materials[a.material]):u.material();const g=d.pbrMetallicRoughness,l=this.hasVertexColors(a);let n;g.baseColorTexture&&(f.errorUnsupportedIf(0!==(g.baseColorTexture.texCoord||0),"Only TEXCOORD with index 0 is supported."),n=await this.getTexture(g.baseColorTexture.index,c));let z;d.normalTexture&&(0!==(d.normalTexture.texCoord||0)?f.warnUnsupported("Only TEXCOORD with index 0 is supported for the normal map texture."):
z=await this.getTexture(d.normalTexture.index,c));let A;d.occlusionTexture&&b&&(0!==(d.occlusionTexture.texCoord||0)?f.warnUnsupported("Only TEXCOORD with index 0 is supported for the occlusion texture."):A=await this.getTexture(d.occlusionTexture.index,c));let B;d.emissiveTexture&&b&&(0!==(d.emissiveTexture.texCoord||0)?f.warnUnsupported("Only TEXCOORD with index 0 is supported for the emissive texture."):B=await this.getTexture(d.emissiveTexture.index,c));let C;g.metallicRoughnessTexture&&b&&(0!==
(g.metallicRoughnessTexture.texCoord||0)?f.warnUnsupported("Only TEXCOORD with index 0 is supported for the metallicRoughness texture."):C=await this.getTexture(g.metallicRoughnessTexture.index,c));d={alphaMode:d.alphaMode,alphaCutoff:d.alphaCutoff,color:g.baseColorFactor,doubleSided:!!d.doubleSided,colorTexture:n,normalTexture:z,name:d.name,id:null!=a.material?a.material:-1,occlusionTexture:A,emissiveTexture:B,emissiveFactor:d.emissiveFactor,metallicFactor:g.metallicFactor,roughnessFactor:g.roughnessFactor,
metallicRoughnessTexture:C,vertexColors:l,ESRI_externalColorMixMode:d.extras.ESRI_externalColorMixMode}}return d};h.getTexture=async function(a,c){var b=this.errorContext,f=this.json.textures[a];const d=u.textureSampler(null!=f.sampler?this.json.samplers[f.sampler]:{});b.errorUnsupportedIf(null==f.source,"Source is expected to be defined for a texture.");f=this.json.images[f.source];var g=this.textureCache.get(a);g||(f.uri?b=await this.context.loadImage(this.resolveUri(f.uri),c):(b.errorUnsupportedIf(null==
f.bufferView,"Image bufferView must be defined."),b.errorUnsupportedIf(null==f.mimeType,"Image mimeType must be defined."),g=this.json.bufferViews[f.bufferView],c=await this.getBuffer(g.buffer,c),b.errorUnsupportedIf(null!=g.byteStride,"byteStride not supported for image buffer"),b=await J(new Uint8Array(c.buffer,c.byteOffset+(g.byteOffset||0),g.byteLength),f.mimeType)),g={data:b,wrapS:d.wrapS,wrapT:d.wrapT,minFilter:d.minFilter,name:f.name,id:a},this.textureCache.set(a,g));return g};h.getNodeTransform=
function(a){if(void 0===a)return M;var c=this.nodeTransformCache.get(a);if(!c){c=this.getNodeTransform(this.getNodeParent(a));const b=this.json.nodes[a];if(b.matrix)c=m.multiply(t.create(),c,b.matrix);else if(b.translation||b.rotation||b.scale)c=t.clone(c),b.translation&&m.translate(c,c,b.translation),b.rotation&&(r[3]=F.getAxisAngle(r,b.rotation),m.rotate(c,c,r[3],r)),b.scale&&m.scale(c,c,b.scale);this.nodeTransformCache.set(a,c)}return c};h.wrapAccessor=function(a,c){return new a(c.raw,c.byteOffset,
c.byteStride,c.byteOffset+c.byteStride*(c.entryCount-1)+c.componentByteSize*c.componentCount)};h.resolveUri=function(a){return p.makeAbsolute(a,this.baseUri)};h.getNodeParent=function(a){return this.nodeParentMap.get(a)};h.checkVersionSupported=function(){const a=x.Version.parse(this.json.asset.version,"glTF");N.validate(a)};h.checkRequiredExtensionsSupported=function(){const a=this.json,c=this.errorContext;a.extensionsRequired&&0!==a.extensionsRequired.length&&c.errorUnsupported("gltf loader was not able to load unsupported feature. Required extensions: "+
a.extensionsRequired.join(", "))};h.computeNodeParents=function(){this.json.nodes.forEach((a,c)=>{a.children&&a.children.forEach(b=>{this.nodeParentMap.set(b,c)})})};return e}();const N=new x.Version(2,0,"glTF"),M=m.fromXRotation(t.create(),Math.PI/2),r=E.create(),K={SCALAR:1,VEC2:2,VEC3:3,VEC4:4},L={[5120]:1,[5121]:1,[5122]:2,[5123]:2,[5126]:4,[5125]:4},q={5120:"BYTE",5121:"UNSIGNED_BYTE",5122:"SHORT",5123:"UNSIGNED_SHORT",5125:"UNSIGNED_INT",5126:"FLOAT"};w.Resource=O;Object.defineProperty(w,"__esModule",
{value:!0})});