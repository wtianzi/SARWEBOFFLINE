// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.19/esri/copyright.txt for details.
//>>built
define("exports ../../../../core/compilerUtils ../../../../core/mathUtils ../../../../chunks/vec3f64 ../../../../chunks/vec3 ../../../../geometry/projectionEllipsoid ../../../../chunks/mat4 ../../../../chunks/mat4f64 ../../support/geometryUtils ./common ../../state/utils/viewUtils".split(" "),function(u,z,k,A,g,B,C,J,D,l,r){function E(c,a,b=l.defaultApplyOptions,d=!0){t.eyeCenterDistance=0;t.requiresTwoSteps=!1;const f=v(c,a,b,void 0,t);if(0===f)return!1;C.identity(q);C.rotate(q,q,-f,a.viewRight);
switch(b.tiltMode){case 1:g.transformMat4(m,a.viewForward,q);g.scale(m,m,t.eyeCenterDistance);g.add(a.center,a.eye,m);break;case 0:g.subtract(m,a.center,a.eye);g.transformMat4(m,m,q);g.subtract(a.eye,a.center,m);break;default:z.neverReached(b.tiltMode)}g.transformMat4(a.up,a.up,q);a.markViewDirty();return t.requiresTwoSteps&&d?E(c,a,b,!1):!0}function v(c,a,b=l.defaultApplyOptions,d=l.defaultApplyOptions,f){if(!c.state.constraints.tilt)return 0;var e=c.state.constraints.tilt(a.distance,K);if(0!==b.interactionType){var {interactionStartCamera:n,
interactionFactor:F}=b,{min:L,max:M}=e,h=v(c,n,l.defaultApplyOptions,b),G=0===h?0:r.viewAngle(c.renderCoordsHelper,n.center,n.eye);e.min=L;e.max=M;2===b.interactionType?(l.hasConstraintType(b.selection,2)&&H(c,n,e),l.adjustRangeForInteraction(h,G,!0,F,I,e)):l.adjustRangeForInteraction(h,G,!1,F,I,e)}2===d.interactionType&&l.hasConstraintType(d.selection,2)&&H(c,d.interactionStartCamera,e);if(1===b.tiltMode||1===d.tiltMode){a:switch(f&&(f.requiresTwoSteps=!1),c.viewingMode){case "global":b=N;h=c.pointsOfInterest.centerOnSurfaceFrequent.estimatedSurfaceAltitude;
d=h+B.getReferenceEllipsoid(c.spatialReference).radius;h=c.renderCoordsHelper.intersectManifold(a.ray,h,p);b.eyeCenterDistance=a.distance;h?(b.eyeCenterDistance=g.distance(a.eye,p),b.tiltAtCenter=r.viewAngle(c.renderCoordsHelper,p,a.eye)):c.state.isLocal?b.tiltAtCenter=r.viewAngle(c.renderCoordsHelper,a.center,a.eye):(D.sphere.closestPointOnSilhouette(D.sphere.fromRadius(d),a.ray,p),b.eyeCenterDistance=g.distance(a.eye,p),b.tiltAtCenter=k.acosClamped(-g.dot(a.viewForward,g.normalize(p,p))));b.radius=
d;b.eyeRadius=g.length(a.eye);b.constraints=c.state.constraints;b.centerIsOnSurface=h;a=k.clamp(b.tiltAtCenter,e.min,e.max);if(1E-9<Math.abs(b.tiltAtCenter-a)){if(b.centerIsOnSurface){{const {constraints:w,eyeCenterDistance:O,tiltAtCenter:x}=b;a=x;c=w.clampTilt(O,x);e=y(b,c);if(w.clampTilt(e,x)!==c)for(e=0;10>e&&1E-9<Math.abs(c-a);)d=(a+c)/2,h=y(b,d),h=w.clampTilt(h,d),1E-9<Math.abs(h-d)?a=d:c=d,e++;a=c}e=a;c=k.asinClamped(b.radius/b.eyeRadius*Math.sin(b.tiltAtCenter));e=k.asinClamped(b.radius/b.eyeRadius*
Math.sin(e));c=b.eyeRadius>b.radius?c-e:e-c}else a=b.constraints.clampTilt(b.eyeCenterDistance,b.tiltAtCenter),f&&a<Math.PI/2&&(f.requiresTwoSteps=!0,a=Math.PI/2-1E-5),c=b.tiltAtCenter-Math.PI/2-(a-Math.PI/2);f&&(f.eyeCenterDistance=y(b,a));f=c}else f=0;break a;case "local":d=r.viewAngle(c.renderCoordsHelper,a.center,a.eye);b=k.clamp(d,e.min,e.max);e=d-b;1E-9<Math.abs(e)?(f&&(d=c.pointsOfInterest.centerOnSurfaceFrequent.estimatedSurfaceAltitude,c=c.renderCoordsHelper.getAltitude(a.eye)-d,b=Math.cos(b),
f.eyeCenterDistance=1E-4<Math.abs(b)?c/b:a.distance),f=e):f=0;break a;default:z.neverReached(c.viewingMode),f=void 0}return f}f=r.viewAngle(c.renderCoordsHelper,a.center,a.eye);b=k.clamp(f,e.min,e.max);f-=b;f=1E-9<Math.abs(f)?f:0;return f}function y(c,a){if(!c.centerIsOnSurface)return c.eyeCenterDistance;a=Math.PI-k.clamp(a,0,Math.PI);const b=k.asinClamped(c.radius/c.eyeRadius*Math.sin(a)),d=Math.sin(Math.PI-a-b)/Math.sin(a);return c.eyeRadius<c.radius&&1<d?Math.sin(Math.PI-a-(Math.PI-b))/Math.sin(a)*
c.eyeRadius:d*c.eyeRadius}function H(c,a,b){if(!c.state.isLocal){var d=c.state.constraints;if(d.altitude){var f=g.squaredLength(a.center),e=Math.sqrt(f);a=a.distance;var n=B.getReferenceEllipsoid(c.spatialReference).radius;c=d.altitude.min+n;d=d.altitude.max+n;c=(c*c-a*a-f)/(-2*e*a);b.min=Math.max(b.min,Math.min(Math.PI-k.acosClamped((d*d-a*a-f)/(-2*e*a)),b.max));b.max=Math.min(b.max,Math.PI-k.acosClamped(c))}}}const m=A.create(),q=J.create(),p=A.create(),I=k.deg2rad(5),K={min:0,max:0},N={constraints:null,
radius:0,eyeRadius:0,centerIsOnSurface:!0,eyeCenterDistance:0,tiltAtCenter:0},t={eyeCenterDistance:0,requiresTwoSteps:!1};u.applyTiltConstraint=E;u.getTiltConstraintError=v;Object.defineProperty(u,"__esModule",{value:!0})});