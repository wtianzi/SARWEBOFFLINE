// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.19/esri/copyright.txt for details.
//>>built
define("exports ../../../../chunks/_rollupPluginBabelHelpers ../../../../core/has ../../../../core/maybe ../../../../Color ../../../../chunks/vec3f64 ../../../../chunks/vec3 ../../../../chunks/mat4 ../../../../geometry/projection ../../../../chunks/mat3f64 ../../../../chunks/mat4f64 ../../../../chunks/vec4f64 ../../../../geometry/support/MeshMaterialMetallicRoughness ../../../../geometry/support/MeshComponent ../../../../chunks/mat3 ../../../../geometry/support/meshUtils/projection ../../../../geometry/support/aaBoundingBox ../../webgl-engine/lib/geometryDataUtils ../../webgl-engine/lib/Geometry ../../webgl-engine/lib/Object3D ../../support/debugFlags ./elevationAlignmentUtils ./ElevationAligners ./ElevationContext ./Graphics3DObject3DGraphicLayer ../support/edgeUtils ./Graphics3DSymbolLayer ../../webgl-engine/materials/DefaultMaterial ../../webgl-engine/lib/Texture ../support/symbolColorUtils ../../webgl-engine/materials/NativeLineMaterial".split(" "),
function(J,X,K,z,E,y,u,Y,F,Z,D,P,aa,ba,Q,R,G,ca,L,da,S,T,ea,fa,ha,ia,ja,ka,la,U,V){const ma=["mesh"];K=function(M){function N(a,b,c,d){a=M.call(this,a,b,c,d)||this;a._materials=new Map;a._textures=new Map;a.ensureDrapedStatus(!1);return a}X._inheritsLoose(N,M);var f=N.prototype;f.doLoad=async function(){S.DRAW_MESH_GEOMETRY_NORMALS&&(this._debugVertexNormalMaterial=new V.NativeLineMaterial({color:[1,0,1,1]}),this._debugFaceNormalMaterial=new V.NativeLineMaterial({color:[0,1,1,1]}))};f.destroy=function(){M.prototype.destroy.call(this);
this._context.stage.removeMany(Array.from(this._materials.values(),a=>a.material));this._context.stage.removeMany(Array.from(this._textures.values()));this._materials.clear();this._textures.clear()};f.createGraphics3DGraphic=function(a){const b=a.graphic;if(!this._validateGeometry(b.geometry,ma,"fill on mesh-3d"))return null;const c=this.setGraphicElevationContext(b,new fa.ElevationContext);return this._createAs3DShape(b,a.renderingInfo,c,b.uid)};f.layerOpacityChanged=function(a,b){const c=this._getLayerOpacity();
this._materials.forEach(d=>{d.material.setParameterValues({layerOpacity:c});const e=d.material.params;this._setMaterialTransparentParameter(e,d);d.material.setParameterValues({transparent:e.transparent})});a.forEach(d=>{d=b(d);z.isSome(d)&&d.layerOpacityChanged(c,this._context.isAsync)});return!0};f.layerElevationInfoChanged=function(a,b){return this.updateGraphics3DGraphicElevationInfo(a,b,T.needsElevationUpdates3D)};f.slicePlaneEnabledChanged=function(a,b){this._materials.forEach(c=>{c.material.setParameterValues({slicePlaneEnabled:this._context.slicePlaneEnabled})});
a.forEach(c=>{c=b(c);z.isSome(c)&&c.slicePlaneEnabledChanged(this._context.slicePlaneEnabled,this._context.isAsync)});return!0};f.physicalBasedRenderingChanged=function(){const a=this._usePBR();this._materials.forEach(b=>b.material.setParameterValues({usePBR:a}));return!0};f.pixelRatioChanged=function(){return!0};f._requiresSymbolVertexColors=function(){return this._drivenProperties.color||this._drivenProperties.opacity};f._colorOrTextureUid=function(a){return a?a instanceof E?a.toHex():a.contentHash:
"-"};f._materialPropertiesDefault=function(a,b){const c=this._requiresSymbolVertexColors(),d=!!a.vertexAttributes.color;a=!!a.vertexAttributes.tangent;return{hasSymbolVertexColors:c,hasVertexColors:d,hasVertexTangents:a,uid:`vc:${d},vt:${a},vct${b},svc:${c}`}};f._materialProperties=function(a,b,c){a=this._materialPropertiesDefault(a,c);if(!b.material)return a;const {color:d,colorTexture:e,normalTexture:g,doubleSided:h,alphaCutoff:n,alphaMode:q}=b.material;c=this._colorOrTextureUid(d);var l=this._colorOrTextureUid(e),
r=this._colorOrTextureUid(g);a.color=d;a.colorTexture=e;a.normalTexture=g;a.uid=`${a.uid},cmuid:${c},ctmuid:${l},ntmuid:${r},ds:${h},ac:${n},am:${q}`;if(b.material instanceof aa){const {metallic:x,roughness:p,metallicRoughnessTexture:m,emissiveColor:v,emissiveTexture:t,occlusionTexture:w}=b.material;b=this._colorOrTextureUid(m);c=this._colorOrTextureUid(v);l=this._colorOrTextureUid(t);r=this._colorOrTextureUid(w);a.metallic=x;a.roughness=p;a.metallicRoughnessTexture=m;a.emissiveColor=v;a.emissiveTexture=
t;a.occlusionTexture=w;a.uid=`${a.uid},mrm:${x},mrr:${p},mrt:${b},emuid:${c},etmuid:${l},otmuid:${r}`}return a};f._setInternalColorValueParameters=function(a,b){b.diffuse=E.toUnitRGB(a);b.opacity=a.a};f._getLoadableTextureResource=function(a){return a.data?a.data:a.url};f._getInternalTextureId=function(a){const b=this._getLoadableTextureResource(a);if(b){var c=a.contentHash,d=this._textures.get(c);d||(d=new la.Texture(b,{mipmap:!0,wrap:this._castTextureWrap(a.wrap),noUnpackFlip:!0,preMultiplyAlpha:!0}),
this._textures.set(c,d),this._context.stage.add(d));return d.id}};f._castTextureWrap=function(a="repeat"){return"string"===typeof a?(a=this._castTextureWrapIndividual(a),{s:a,t:a}):{s:this._castTextureWrapIndividual(a.horizontal),t:this._castTextureWrapIndividual(a.vertical)}};f._castTextureWrapIndividual=function(a){switch(a){case "clamp":return 33071;case "mirror":return 33648;default:return 10497}};f._setInternalMaterialParameters=function(a,b){a.color&&this._setInternalColorValueParameters(a.color,
b);a.colorTexture&&(b.textureId=this._getInternalTextureId(a.colorTexture));a.normalTexture&&(b.normalTextureId=this._getInternalTextureId(a.normalTexture));a.emissiveColor&&(b.emissiveFactor=E.toUnitRGB(a.emissiveColor));a.emissiveTexture&&(b.emissiveTextureId=this._getInternalTextureId(a.emissiveTexture));a.occlusionTexture&&(b.occlusionTextureId=this._getInternalTextureId(a.occlusionTexture));a.metallicRoughnessTexture&&(b.metallicRoughnessTextureId=this._getInternalTextureId(a.metallicRoughnessTexture))};
f._setExternalMaterialParameters=function(a){var b=this._drivenProperties.color;let c=z.isSome(this.symbolLayer.material)?this.symbolLayer.material.colorMixMode:null;b?a.externalColor=P.ONES:(b=z.isSome(this.symbolLayer.material)?this.symbolLayer.material.color:null,z.isSome(b)?a.externalColor=E.toUnitRGBA(b):(c=null,a.externalColor=P.ONES));c&&(a.colorMixMode=c);a.castShadows=!!this.symbolLayer.castShadows};f._hasTransparentVertexColors=function(a){a=a.vertexAttributes.color;if(!a)return!1;for(let b=
3;b<a.length;b+=4)if(255!==a[b])return!0;return!1};f._getOrCreateMaterial=function(a,b){var c=b.material&&b.material.color,d=b.material&&b.material.colorTexture,e=b.material&&"blend"===b.material.alphaMode;c=!(b.material&&"opaque"===b.material.alphaMode)&&(this._hasTransparentVertexColors(a)||c&&1>c.a||d&&d.transparent||e);a=this._materialProperties(a,b,c);if(d=this._materials.get(a.uid))return d.material;c={material:null,isComponentTransparent:c,alphaMode:b.material?b.material.alphaMode:"opaque"};
d=null==a.metallicRoughnessTexture&&null==a.metallic&&null==a.roughness;e={usePBR:this._usePBR(),isSchematic:d,vertexColors:a.hasVertexColors,symbolColors:a.hasSymbolVertexColors,vertexTangents:a.hasVertexTangents,ambient:y.ZEROS,diffuse:y.ONES,opacity:1,doubleSided:!0,doubleSidedType:"winding-order",cullFace:0,textureAlphaPremultiplied:!0,layerOpacity:this._getLayerOpacity(),slicePlaneEnabled:this._context.slicePlaneEnabled,initTextureTransparent:!0};d||(e.mrrFactors=[null!=a.metallic?a.metallic:
1,null!=a.roughness?a.roughness:1,.5]);b.material&&(e.doubleSided=b.material.doubleSided,e.cullFace=b.material.doubleSided?0:2,e.textureAlphaCutoff=b.material.alphaCutoff);this._setInternalMaterialParameters(a,e);this._setExternalMaterialParameters(e);this._setMaterialTransparentParameter(e,c);b=new ka.DefaultMaterial(e);c.material=b;this._materials.set(a.uid,c);this._context.stage.add(b);return b};f._usePBR=function(){return this._context.physicalBasedRenderingEnabled};f._setMaterialTransparentParameter=
function(a,b){a.transparent=this.needsDrivenTransparentPass||b.isComponentTransparent||1>a.layerOpacity||1>a.opacity||a.externalColor&&1>a.externalColor[3];a.textureAlphaMode="auto"===b.alphaMode?a.transparent?3:1:"opaque"===b.alphaMode?1:"mask"===b.alphaMode?2:0};f._addDebugNormals=function(a,b,c,d){var e=b.length,g=a.spatialReference.isGeographic?20015077/180:1;const h=.1*Math.max(a.extent.width*g,a.extent.height*g,a.extent.zmax-a.extent.zmin),n=[],q=[];a=[];g=[];for(let v=0;v<e;v++){var l=b[v],
r=l.vertexAttributes.get("position"),x=l.vertexAttributes.get("normal");const t=l.indices.get("position");l=l.indices.get("normal");r=r.data;x=x.data;for(let w=0;w<t.length;w++){var p=3*t[w];const na=3*l[w];for(var m=0;3>m;m++)n.push(r[p+m]);for(m=0;3>m;m++)n.push(r[p+m]+x[na+m]*h);q.push(q.length);q.push(q.length);if(0===w%3){this._calculateFaceNormal(r,t,w,A);this._getFaceVertices(r,t,w,k,B,C);u.add(k,k,B);u.add(k,k,C);u.scale(k,k,1/3);for(p=0;3>p;p++)a.push(k[p]);for(p=0;3>p;p++)a.push(k[p]+A[p]*
h);g.push(g.length);g.push(g.length)}}}e=new L.Geometry([["position",{data:n,size:3,exclusive:!0}]],[["position",new Uint32Array(q)]],2);b.push(e);c.push(this._debugVertexNormalMaterial);d.push(D.clone(d[0]));e=new L.Geometry([["position",{data:a,size:3,exclusive:!0}]],[["position",new Uint32Array(g)]],2);b.push(e);c.push(this._debugFaceNormalMaterial);d.push(D.clone(d[0]))};f._createAs3DShape=function(a,b,c,d){a=a.geometry;if("mesh"!==a.type)return null;b=this._createGeometryInfo(a,b);if(!b)return null;
const {geometries:e,materials:g,transformations:h,objectTransformation:n}=b;S.DRAW_MESH_GEOMETRY_NORMALS&&this._addDebugNormals(a,e,g,h);b=new da.Object3D({geometries:e,materials:g,transformations:h,metadata:{layerUid:this._context.layer.uid,graphicUid:d}});b.transformation=n;d=ea.perObjectElevationAligner;var q=this._createEdgeMaterial();q=z.isSome(q)?{baseMaterial:g[0],edgeMaterials:[q],properties:{mergeGeometries:!0,slicePlaneEnabled:this._context.slicePlaneEnabled}}:null;b=new ha(this,b,e,null,
null,d,c,q);b.needsElevationUpdates=T.needsElevationUpdates3D(c.mode);c=a.extent.center.clone();c.z=0;b.elevationContext.centerPointInElevationSR=c;b.alignedSampledElevation=d(b,b.elevationContext,this._context.elevationProvider,this._context.renderCoordsHelper);return b};f._createComponentNormals=function(a,b,c,d){switch(c.shading||"flat"){case "source":return this._createComponentNormalsSource(a,b,c,d);case "flat":return this._createComponentNormalsFlat(a,d);case "smooth":return this._createComponentNormalsSmooth(a,
d)}};f._createComponentNormalsSource=function(a,b,c,d){if(!b)return this._createComponentNormalsFlat(a,d);let e=!1;if(!c.trustSourceNormals)for(c=0;c<d.length;c+=3){this._calculateFaceNormal(a,d,c,A);for(let g=0;3>g;g++){const h=3*d[c+g];k[0]=b[h+0];k[1]=b[h+1];k[2]=b[h+2];0>u.dot(A,k)&&(b[h+0]=-b[h+0],b[h+1]=-b[h+1],b[h+2]=-b[h+2],e=!0)}}return{normals:b,indices:d,didFlipNormals:e}};f._createComponentNormalsFlat=function(a,b){const c=new Float32Array(b.length),d=new Uint32Array(3*b.length);for(let e=
0;e<b.length;e+=3){const g=this._calculateFaceNormal(a,b,e,A);for(let h=0;3>h;h++)c[e+h]=g[h],d[e+h]=e/3}return{normals:c,indices:d,didFlipNormals:!1}};f._createComponentNormalsSmooth=function(a,b){const c={};for(var d=0;d<b.length;d+=3){var e=this._calculateFaceNormal(a,b,d,A);for(var g=0;3>g;g++){var h=b[d+g];let n=c[h];n||(n={normal:y.create(),count:0},c[h]=n);u.add(n.normal,n.normal,e);n.count++}}a=new Float32Array(3*b.length);d=new Uint32Array(3*b.length);for(e=0;e<b.length;e++){g=c[b[e]];1!==
g.count&&(u.normalize(g.normal,g.normal),g.count=1);for(h=0;3>h;h++)a[3*e+h]=g.normal[h];d[e]=e}return{normals:a,indices:d,didFlipNormals:!1}};f._getFaceVertices=function(a,b,c,d,e,g){const h=3*b[c+0],n=3*b[c+1];b=3*b[c+2];d[0]=a[h+0];d[1]=a[h+1];d[2]=a[h+2];e[0]=a[n+0];e[1]=a[n+1];e[2]=a[n+2];g[0]=a[b+0];g[1]=a[b+1];g[2]=a[b+2]};f._calculateFaceNormal=function(a,b,c,d){this._getFaceVertices(a,b,c,k,B,C);u.subtract(B,B,k);u.subtract(C,C,k);u.cross(k,B,C);u.normalize(d,k);return d};f._getOrCreateComponents=
function(a){return a.components?a.components:oa};f._createPositionBuffer=function(a){const b=a.vertexAttributes.position,c=new Float64Array(b.length);F.projectBuffer(a.vertexAttributes.position,a.spatialReference,0,c,this._context.renderCoordsHelper.spatialReference,0,b.length/3);return c};f._createNormalBuffer=function(a,b){const c=a.vertexAttributes.normal;if(!c)return null;if("local"===this._context.layerView.view.viewingMode)return c;const d=a.vertexAttributes.position,e=new Float32Array(c.length);
return R.projectNormalToECEF(c,d,b,a.spatialReference,e)};f._createTangentBuffer=function(a,b){const c=a.vertexAttributes.tangent;if(!c)return null;if("local"===this._context.layerView.view.viewingMode)return c;const d=a.vertexAttributes.position,e=new Float32Array(c.length);return R.projectTangentToECEF(c,d,b,a.spatialReference,e)};f._createColorBuffer=function(a){return a.vertexAttributes.color};f._createSymbolColorBuffer=function(a){if(this._requiresSymbolVertexColors()){a=this._getVertexOpacityAndColor(a);
const b=U.parseColorMixMode(z.get(this.symbolLayer,"material","colorMixMode")),c=new Uint8Array(4);U.encodeSymbolColor(a,b,c);return c}return null};f._createBuffers=function(a,b){var c=a.vertexAttributes&&a.vertexAttributes.position;if(!c)return this.logger.warn("Mesh geometry must contain position vertex attributes"),null;var d=a.vertexAttributes.normal;const e=a.vertexAttributes.uv;var g=a.vertexAttributes.tangent;if(d&&d.length!==c.length)return this.logger.warn("Mesh normal vertex buffer must contain the same number of elements as the position buffer"),
null;if(g&&g.length/4!==c.length/3)return this.logger.warn("Mesh tangent vertex buffer must contain the same number of elements as the position buffer"),null;if(e&&e.length/2!==c.length/3)return this.logger.warn("Mesh uv vertex buffer must contain the same number of elements as the position buffer"),null;c=this._createPositionBuffer(a);d=this._createColorBuffer(a);b=this._createSymbolColorBuffer(b);g=this._createNormalBuffer(a,c);const h=this._createTangentBuffer(a,c);a=this._transformCenterLocal(a,
c,g);return{positionBuffer:c,normalBuffer:g,tangentBuffer:h,uvBuffer:e,colorBuffer:d,symbolColorBuffer:b,objectTransformation:a}};f._transformCenterLocal=function(a,b,c){var d=a.extent.center;const e=this._context.renderCoordsHelper.spatialReference;H[0]=d.x;H[1]=d.y;H[2]=0;d=D.create();F.computeLinearTransformation(a.spatialReference,H,d,e);Y.invert(W,d);for(a=0;a<b.length;a+=3)k[0]=b[a+0],k[1]=b[a+1],k[2]=b[a+2],u.transformMat4(k,k,W),b[a+0]=k[0],b[a+1]=k[1],b[a+2]=k[2];if(c)for(Q.fromMat4(I,d),
Q.transpose(I,I),b=0;b<c.length;b+=3)k[0]=c[b+0],k[1]=c[b+1],k[2]=c[b+2],u.transformMat3(k,k,I),c[b+0]=k[0],c[b+1]=k[1],c[b+2]=k[2];return d};f._validateFaces=function(a,b){a=a.vertexAttributes.position.length/3;if(b=b.faces){let c=-1;for(let d=0;d<b.length;d++){const e=b[d];e>c&&(c=e)}if(a<=c)return this.logger.warn(`Vertex index ${c} is out of bounds of the mesh position buffer`),!1}else if(0!==a%3)return this.logger.warn("Mesh position buffer length must be a multiple of 9 if no component faces are defined (3 values per vertex * 3 vertices per triangle)"),
!1;return!0};f._getOrCreateFaces=function(a,b){return b.faces?b.faces:ca.generateDefaultIndexArray(a.vertexAttributes.position.length/3)};f._isOutsideClippingArea=function(a){if(!this._context.clippingExtent)return!1;var b=a.vertexAttributes&&a.vertexAttributes.position;if(!b)return!1;const c=this._context.elevationProvider.spatialReference,d=b.length/3;a.spatialReference.equals(c)||(b=new Float64Array(b.length),F.projectBuffer(a.vertexAttributes.position,a.spatialReference,0,b,c,0,d));G.empty(O);
G.expandWithBuffer(O,b,0,d);return!G.intersectsClippingArea(O,this._context.clippingExtent)};f._createGeometryInfo=function(a,b){if(!F.canProjectWithoutEngine(a.spatialReference,this._context.layerView.view.spatialReference))return this.logger.warn("Geometry spatial reference is not compatible with the view"),null;if(this._isOutsideClippingArea(a))return null;b=this._createBuffers(a,b);if(!b)return null;const {positionBuffer:c,uvBuffer:d,colorBuffer:e,symbolColorBuffer:g,normalBuffer:h,tangentBuffer:n,
objectTransformation:q}=b;var l=this._getOrCreateComponents(a);b=[];const r=[],x=[];let p=!1;for(const v of l){if(!this._validateFaces(a,v))return null;l=this._getOrCreateFaces(a,v);if(0===l.length)continue;var m=this._createComponentNormals(c,h,v,l);m.didFlipNormals&&(p=!0);const t=[["position",{size:3,data:c,exclusive:!0}],["normal",{size:3,data:m.normals,exclusive:!0}]];m=[["position",l],["normal",m.indices]];e&&(t.push(["color",{size:4,data:e,exclusive:!0}]),m.push(["color",l]));g&&(t.push(["symbolColor",
{size:4,data:g,exclusive:!0}]),m.push(["symbolColor",new Uint16Array(l.length)]));a.vertexAttributes.uv&&(t.push(["uv0",{size:2,data:d,exclusive:!0}]),m.push(["uv0",l]));a.vertexAttributes.tangent&&(t.push(["tangent",{size:4,data:n,exclusive:!0}]),m.push(["tangent",l]));l=new L.Geometry(t,m);b.push(l);r.push(D.create());x.push(this._getOrCreateMaterial(a,v))}p&&this.logger.warn("Normals have been automatically flipped to be consistent with the counter clock wise face winding order. It is better to generate mesh geometries that have consistent normals.");
return{geometries:b,transformations:r,materials:x,objectTransformation:q}};f._createEdgeMaterial=function(){const a={opacity:this._getLayerOpacity()};return ia.createMaterial(this.symbolLayer,a)};return N}(ja.Graphics3DSymbolLayer);const H=y.create(),k=y.create(),B=y.create(),C=y.create(),A=y.create(),W=D.create(),I=Z.create(),O=G.create(),oa=[new ba];J.Graphics3DMeshFillSymbolLayer=K;J.default=K;Object.defineProperty(J,"__esModule",{value:!0})});