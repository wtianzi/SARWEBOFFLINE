// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.19/esri/copyright.txt for details.
//>>built
define("../../../../core/has ../../../../core/lang ../../../../core/maybe ../../../../core/urlUtils ../../../../core/promiseUtils ../../../../core/asyncUtils ./I3SBinaryReader ./I3SUtil ./I3SMaterialUtil".split(" "),function(A,B,u,v,w,p,x,C,y){return function(){function q(a,c,f,b,d,e){this.streamDataController=c;this.logger=f;this.defaultGeometrySchema=b;this.requiredAttributes=d;this.options=e;this.logLayer=a;this.layerUrl=a.parsedUrl.path;this.geometryDefinitions=a.geometryDefinitions;if(a.materialDefinitions){const g=
a.textureSetDefinitions;this.materialAndTextures=a.materialDefinitions.map(h=>y.getMaterialAndTextures(g,h))}}var k=q.prototype;k.load=function(a,c,f){return this.streamDataController.request(a,c,{signal:f})};k.loadAttribute=function(a,c,f){return this.load(`${this.layerUrl}/nodes/${a.resources.attributes}/attributes/${c.key}/0`,"binary",f).then(b=>x.readBinaryAttribute(c,b))};k.loadAttributes=function(a,c,f){return w.eachAlways(c.map(b=>this.loadAttribute(a,b.attributeStorageInfo,f))).then(b=>{const d=
{};for(let e=0;e<c.length;++e)if(b[e].value)d[c[e].name]=b[e].value;else{if(w.isAbortError(b[e].error))throw b[e].error;this.logger.error("#loadAttributes",this.logLayer,`Failed to load attributeData for '${c[e].name}' on node '${a.id}'`,b[e].error)}return d})};k.loadNodeData=async function(a,c){var f=null!=this.requiredAttributes&&a.resources.attributes?p.result(this.loadAttributes(a,this.requiredAttributes,c)):null;var b=this.geometryDefinitions;var d={bufferDefinition:null,bufferIndex:0};if(!(null==
b||0>a.resources.geometryDefinition)&&(b=0<=a.resources.geometryDefinition?b[a.resources.geometryDefinition].geometryBuffers:null,null!=b))for(var e=0;e<b.length;e++){var g=b[e];if(null!=g.compressedAttributes){if("draco"===g.compressedAttributes.encoding&&!A("disable-feature:i3s-draco")){d.bufferIndex=e;d.bufferDefinition=g;break}}else d.bufferIndex=e,d.bufferDefinition=b[e]}const {bufferDefinition:h,bufferIndex:t}=d;e=(g=!!a.resources.geometry)?p.result(this.loadGeometry(a.resources.geometry,t,
c)):null;b=a.resources.hasSharedResource?await this.loadShared(a,c):null;var l=(d=this.materialAndTextures&&0<=a.resources.materialDefinition?this.materialAndTextures[a.resources.materialDefinition]:null!=b?y.getMaterialAndTexturesFromShared(b):null)&&d.material;d=d&&d.textures;const D=`${a.id}`,z=!g&&this.options.loadFeatureData;g=z?await this.loadFeatureData(D,c):null;if(z)a:{for(m of g.featureData)if(l=m.geometries,null!=l)for(var n of l){var m={featureIds:[m.id],featureDataPosition:m.position,
geometries:[n]};break a}m=null}else m={featureIds:[],geometries:[{type:"ArrayBufferView",params:{material:l}}],featureDataPosition:[0,0,0]};if(n=u.isNone(m)){n=[];for(var r of g.featureData)null!=r.position&&n.push({featureIds:[r.id],featureDataPosition:r.position,geometries:null})}r=n;n=null!=d&&0<d.length?p.result(this.loadTextures(a,d,c)):null;c=a=null;e&&(a=p.assertResult(await e),(c=this.defaultGeometrySchema)&&b&&b.materialDefinitions&&(e=Object.keys(b.materialDefinitions)[0],!b.materialDefinitions[e].params.vertexRegions&&
c.vertexAttributes.region&&(c=B.clone(c),delete c.vertexAttributes.region)),c=x.createGeometryDescriptor(h,c));b=n?p.assertResult(await n):null;f=(f=f?p.assertResult(await f):{})?{attributeData:f,loadedAttributes:this.requiredAttributes}:null;return u.isSome(m)?{geometryData:m,attributeDataInfo:f,geometryBuffer:a,geometryDescriptor:c,requiredTextures:d,textureData:b}:u.isSome(r)?{pointData:r,attributeDataInfo:f,geometryBuffer:a,geometryDescriptor:c,requiredTextures:d,textureData:b}:Promise.reject()};
q.addAbsoluteHrefTexture=function(a,c){a=a.textureDefinitions;if(null!=a)for(const f of Object.keys(a))for(const b of a[f].images)Array.isArray(b.href)?b.hrefConcat=b.href.map(d=>v.makeAbsolute(d,c)):b.hrefConcat=v.makeAbsolute(b.href,c)};q.fixTextureEncodings=function(a){a=a.textureDefinitions;if(null!=a)for(const f in a){const b=a[f];if(Array.isArray(b.encoding))for(var c=0;c<b.encoding.length;c++){const d=b.encoding[c];"data:"===d.substring(0,5)&&(b.encoding[c]=d.substring(5))}else c=b.encoding,
"data:"===c.substring(0,5)&&(b.encoding=c.substring(5))}};k.loadShared=function(a,c){const f=`${this.layerUrl}/nodes/${a.resources.geometry}/shared`;return this.load(f,"json",c).then(b=>{q.fixTextureEncodings(b);q.addAbsoluteHrefTexture(b,f);return b})};k.loadTexture=function(a,c,f,b,d,e){return 2===d||1===d?this.load(a,"binary",e).then(g=>({id:c,usage:f,data:g,encoding:d})):this.load(a,"image",e).then(g=>{var h=g;if(b&&4096<=g.width*g.height){h=Math.ceil(g.width/2);const t=Math.ceil(g.height/2),
l=document.createElement("canvas");l.width=h;l.height=t;l.getContext("2d").drawImage(g,0,0,h,t);h=l}return{id:c,usage:f,data:h,encoding:d}})};k.loadTextures=function(a,c,f){const b=this.options.uncompressedTextureDownsamplingEnabled,d=this.options.textureUsageMask;return Promise.all(c.map(e=>{if(0===(e.usage&d))return null;const g=C.selectEncoding(e.encodings,this.options.textureEncodings);return null==g?(this.logger.error("#loadTextures",this.logLayer,`No known encoding for texture found on node ${a.id}`),
Promise.reject()):this.loadTexture(`${this.layerUrl}/nodes/${a.resources.texture||a.id}/textures/${g.name}`,e.id,e.usage,b,g.encoding,f)}))};k.loadFeatureData=function(a,c){return this.load(`${this.layerUrl}/nodes/${a}/features/0`,"json",c)};k.loadGeometry=function(a,c,f){return this.load(`${this.layerUrl}/nodes/${a}/geometries/${c}`,"binary",f)};return q}()});