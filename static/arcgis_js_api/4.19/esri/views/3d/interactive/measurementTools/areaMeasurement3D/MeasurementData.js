// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.19/esri/copyright.txt for details.
//>>built
define("../../../../../geometry/SpatialReference ../../../../../geometry/support/intersects ../../../../../core/mathUtils ../../../../../chunks/vec3f64 ../../../../../chunks/vec3 ../../../support/mathUtils ../../../../../geometry/projectionEllipsoid ../../../../../geometry/projection ../../../../../core/Quantity ../../../../../chunks/vec2f64 ../../../../../chunks/vec4f64 ../../../../../core/libs/earcut/earcut ../../../../../chunks/vec2 ../support/viewUtils ../support/measurementUtils".split(" "),
function(J,E,K,g,k,B,C,t,z,F,L,G,D,H,w){function I(y,l){const a=new Float64Array(y.length*l);for(let c=0;c<y.length;++c){const d=y[c];for(let b=0;b<l;++b)a[c*l+b]=d[b]}return a}return function(){function y(){this.positionsWorldCoords=[];this.positionsRenderCoords=[];this.positionsProjectedWorldCoords=[];this.positionsFittedRenderCoords=[];this.positionsGeographic=[];this.positionsSpherical=[];this.positionsStereographic=[];this.pathSegmentLengths=[];this.geodesicPathSegmentLengths=[];this.perimeterSegmentLengths=
[];this.intersectingSegments=new Set;this.geodesicIntersectingSegments=new Set;this.areaCentroidWorldCoords=g.create();this.areaCentroidRenderCoords=g.create();this.geodesicAreaCentroidRenderCoords=g.create();this._length=0;this._centroidRenderCoords=g.create();this._planeWorldCoords=L.create();this._worldUp=g.create();this._worldTangent=g.create();this._frame=[g.create(),g.create(),g.create()];this._pathVersion=-1;this._validMeasurement=!1;this._tempU=g.create();this._tempV=g.create();this._tempVec3=
g.create();this._tempSphere={center:g.create(),radius:0}}var l=y.prototype;l.update=function(a,c,d,b,e,f,n){if(this._pathVersion!==a.version||this._validMeasurement!==b){this._pathVersion=a.version;this._validMeasurement=b;this._resize(a.numVertices);var u=C.getSphericalPCPF(c.spatialReference),q=t.canProjectWithoutEngine(c.spatialReference,u)&&t.canProjectToWGS84ComparableLonLat(c.spatialReference),m=this.positionsGeographic,h=this.positionsWorldCoords,x=this.positionsRenderCoords,v=this.positionsSpherical;
a.forEachVertexPosition((r,p)=>{t.projectPointToVector(r,h[p],f);t.projectPointToVector(r,x[p],e);q&&(t.projectPointToWGS84ComparableLonLat(r,m[p]),t.projectPointToVector(r,v[p],u),k.normalize(v[p],v[p]))});a=this._updatePathLengths(b);this.pathLength=0<this._length?new z(d.normalizeDistance(a),"meters"):null;q?(a=this._updateGeodesicPathLengths(b,f),this.geodesicPathLength=0<this._length?new z(a,"meters"):null):this.geodesicPathLength=null;b?(this._updateArea(c,d,e,f,n),q&&this._updateGeodesicArea(c)):
(this.geodesicTriangleIndices=this.triangleIndices=this.perimeterLength=this.geodesicArea=this.area=null,this.intersectingSegments.clear(),this.geodesicIntersectingSegments.clear())}};l._resize=function(a){a<this._length&&(this.positionsWorldCoords.length=a,this.positionsRenderCoords.length=a,this.positionsProjectedWorldCoords.length=a,this.positionsFittedRenderCoords.length=a,this.positionsGeographic.length=a,this.positionsSpherical.length=a,this.positionsStereographic.length=a,this.pathSegmentLengths.length=
a,this.geodesicPathSegmentLengths.length=a,this._length=this.perimeterSegmentLengths.length=a);for(;this._length<a;)this.positionsWorldCoords.push(g.create()),this.positionsRenderCoords.push(g.create()),this.positionsProjectedWorldCoords.push(F.create()),this.positionsFittedRenderCoords.push(g.create()),this.positionsGeographic.push(g.create()),this.positionsSpherical.push(g.create()),this.positionsStereographic.push(F.create()),this.pathSegmentLengths.push(0),this.geodesicPathSegmentLengths.push(0),
this.perimeterSegmentLengths.push(0),++this._length};l._updatePathLengths=function(a){const c=this.positionsWorldCoords,d=this.pathSegmentLengths;let b=0;for(let e=0;e<this._length;++e){const f=d[e]=k.distance(c[e],c[(e+1)%this._length]);if(e<this._length-1||a)b+=f}return b};l._updateGeodesicPathLengths=function(a,c){const d=this.positionsGeographic,b=this.geodesicPathSegmentLengths;let e=0;for(let f=0;f<this._length;++f){const n=b[f]=w.segmentLengthGeodesicVector(d[f],d[(f+1)%this._length],c);if(f<
this._length-1||a)e+=n}return e};l._updateArea=function(a,c,d,b,e){const f=a.renderCoordsHelper;a=this.positionsWorldCoords;const n=this.positionsRenderCoords,u=this.positionsProjectedWorldCoords,q=this.positionsFittedRenderCoords;var m=this._planeWorldCoords,h=this._centroidRenderCoords;H.midpoint(n,h);f.worldUpAtPosition(h,this._worldUp);f.worldBasisAtPosition(h,0,this._worldTangent);t.projectDirection(h,this._worldUp,d,this._worldUp,b);t.projectDirection(h,this._worldTangent,d,this._worldTangent,
b);2<a.length&&w.bestFitPlane(a,m);this.fittingMode=this._selectFittingMode(m,a,this._worldUp,e);let x=0;if("horizontal"===this.fittingMode){let r=-Infinity;n.forEach((p,A)=>{p=f.getAltitude(n[A]);p>r&&(r=p,x=A)})}e=a[x];h=m;var v=this._worldTangent;"horizontal"===this.fittingMode?h=this._worldUp:"vertical"===this.fittingMode&&(h=this._tempVec3,v=this._worldUp,B.makeOrthonormal(m,this._worldUp,h));k.copy(this._frame[2],h);B.makeOrthonormal(v,h,this._frame[0]);k.cross(this._frame[1],this._frame[0],
this._frame[2]);k.negate(this._frame[1],this._frame[1]);m=this._tempVec3;h=this._tempU;v=this._tempV;for(let r=0;r<this._length;++r){const p=u[r],A=q[r];k.subtract(m,a[r],e);D.set(p,k.dot(this._frame[0],m),k.dot(this._frame[1],m));k.scale(h,this._frame[0],p[0]);k.scale(v,this._frame[1],p[1]);k.add(m,h,v);k.add(m,m,e);t.projectVectorToVector(m,b,A,d)}this.perimeterLength=0<this._length?new z(c.normalizeDistance(this._updatePerimeterLengths()),"meters"):null;H.midpoint(q,this.areaCentroidRenderCoords);
t.projectVectorToVector(this.areaCentroidRenderCoords,d,this.areaCentroidWorldCoords,b);this._updateIntersectingSegments();this.area=0===this.intersectingSegments.size?new z(c.normalizeArea(this._computeArea()),"square-meters"):null};l._updateGeodesicArea=function(a){const c=a.renderCoordsHelper,d=this.positionsSpherical,b=this.positionsStereographic,e=this._tempVec3,f=w.fitHemisphere(d,e);if(f){var n=this._tempU,u=this._tempV;B.tangentFrame(e,n,u);for(let q=0;q<this._length;++q){const m=k.dot(d[q],
n),h=k.dot(d[q],u),x=k.dot(d[q],e);D.set(b[q],m/x,h/x)}k.scale(e,e,C.getReferenceEllipsoid(a.spatialReference).radius);c.toRenderCoords(e,C.getSphericalPCPF(a.spatialReference),this.geodesicAreaCentroidRenderCoords);this._updateGeodesicIntersectingSegments();this.geodesicArea=f&&0===this.geodesicIntersectingSegments.size?new z(this._computeGeodesicArea(),"square-meters"):null}else this.geodesicArea=null};l._updatePerimeterLengths=function(){const a=this.positionsProjectedWorldCoords,c=this.perimeterSegmentLengths;
let d=0;for(let b=0;b<this._length;++b){const e=c[b]=D.distance(a[b],a[(b+1)%this._length]);d+=e}return d};l._updateIntersectingSegments=function(){const a=this.positionsProjectedWorldCoords,c=this.intersectingSegments;c.clear();for(let d=0;d<this._length;++d)for(let b=d+2;b<this._length;++b)(b+1)%this._length!==d&&E.segmentIntersects(a[d],a[(d+1)%this._length],a[b],a[(b+1)%this._length])&&(c.add(d),c.add(b))};l._computeArea=function(){const a=this.positionsProjectedWorldCoords;var c=I(a,2);c=this.triangleIndices=
new Uint32Array(G.earcut(c,[],2));let d=0;for(let b=0;b<c.length;b+=3)d+=w.triangleAreaEuclidean(a[c[b]],a[c[b+1]],a[c[b+2]]);return d};l._updateGeodesicIntersectingSegments=function(){const a=this.positionsStereographic,c=this.geodesicIntersectingSegments;c.clear();for(let d=0;d<this._length;++d)for(let b=d+2;b<this._length;++b)(b+1)%this._length!==d&&E.segmentIntersects(a[d],a[(d+1)%this._length],a[b],a[(b+1)%this._length])&&(c.add(d),c.add(b))};l._computeGeodesicArea=function(){const a=this.positionsGeographic;
var c=I(this.positionsStereographic,2);c=this.geodesicTriangleIndices=new Uint32Array(G.earcut(c,[],2));let d=0;for(let b=0;b<c.length;b+=3)d+=w.triangleAreaGeodesic(a[c[b]],a[c[b+1]],a[c[b+2]],J.WGS84);return d};l._selectFittingMode=function(a,c,d,b){var e=c.map(n=>Math.abs(w.planePointDistance(a,n))).reduce((n,u)=>Math.max(n,u),0);w.boundingSphere(c,this._tempSphere);c=e/(2*this._tempSphere.radius);e=c<b.maxRelativeErrorAlmostCoplanar;let f="horizontal";c<b.maxRelativeErrorCoplanar?f="oblique":
e&&(f=Math.abs(k.dot(d,a))>Math.cos(K.deg2rad(b.verticalAngleThreshold))?"horizontal":"vertical");return f};return y}()});