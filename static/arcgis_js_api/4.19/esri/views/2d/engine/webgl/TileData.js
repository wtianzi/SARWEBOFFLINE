// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.19/esri/copyright.txt for details.
//>>built
define("exports ../../../../core/maybe ./Utils ./cpuMapped/DisplayRecordReader ./MemoryRequirements ./TileBufferData ./WGLDisplayRecord ./WGLDisplayObject ./TileDisplayData ./mesh/VertexBuffer ./util/Writer ./mesh/VertexVector".split(" "),function(A,C,t,D,u,w,B,E,x,F,G,H){const v=new u,n=new u;u=function(){function l(){this.tileBufferData=this.tileDisplayData=null}var q=l.prototype;q.reshuffle=function(){v.reset();const c=x.groupRecordsByGeometryType(this.tileDisplayData.displayObjects);for(var b of c)for(var a of b)a&&
v.needMore(a.geometryType,a.meshData?a.meshData.vertexCount:a.vertexCount,a.meshData?a.meshData.indexData.length:a.indexCount);b=c.length;a=new w;for(var d=0;d<b;++d){a.geometries[d].indexBuffer=new Uint32Array(Math.round(1.5*v.indicesFor(d)));var h=[];for(var e in this.tileBufferData.geometries[d].vertexBuffer)h.push(this.tileBufferData.geometries[d].vertexBuffer[e].stride);h=l._computeVertexAlignment(h);var f=Math.round(1.5*v.verticesFor(d));h=l._align(f,h);for(var k in this.tileBufferData.geometries[d].vertexBuffer)f=
this.tileBufferData.geometries[d].vertexBuffer[k].stride,a.geometries[d].vertexBuffer[k]={stride:f,data:t.allocateTypedArrayBuffer(h,f)}}n.reset();this.tileDisplayData.displayList.clear();for(e=0;e<b;++e){k=c[e];for(const g of k){if(g.meshData)g.writeMeshDataToBuffers(n.verticesFor(e),a.geometries[e].vertexBuffer,n.indicesFor(e),a.geometries[e].indexBuffer),g.meshData=null;else{k=this.tileBufferData.geometries[e].vertexBuffer;d=this.tileBufferData.geometries[e].indexBuffer;h=a.geometries[e].vertexBuffer;
f=a.geometries[e].indexBuffer;const p=n.verticesFor(e),m=n.indicesFor(e);t.copyMeshData(p,m,h,f,g,k,d);g.vertexFrom=p;g.indexFrom=m}n.needMore(e,g.vertexCount,g.indexCount)}}for(const g of this.tileDisplayData.displayObjects)this.tileDisplayData.displayList.addToList(g.displayRecords);this.tileBufferData=a};q.getStrides=function(){const c=[];for(let b=0;b<this.tileBufferData.geometries.length;++b){const a=this.tileBufferData.geometries[b];c[b]={};for(const d in a.vertexBuffer)c[b][d]=a.vertexBuffer[d].stride}return c};
q.clone=function(){const c=new l;c.tileBufferData=this.tileBufferData.clone();c.tileDisplayData=this.tileDisplayData.clone();return c};q._guessSize=function(){const {displayObjects:c}=this.tileDisplayData,b=Math.min(c.length,4);let a=0;for(let d=0;d<b;d++)a=Math.max(a,c[d].displayRecords.length);return 2*(12*c.length+c.length*a*40)};q.serialize=function(){const c=this.tileBufferData.serialize(),b=this.tileBufferData.getBuffers(),a=this.tileDisplayData.serialize(new G(Int32Array,this._guessSize())).buffer();
b.push(a);return{result:{displayData:a,bufferData:c},transferList:b}};l.fromVertexData=function(c){const b=[],a={},d=new Map;t.forEachGeometryType(h=>{const e=c.data[h];if(C.isSome(e)){const g=D.DisplayRecordReader.from(e.records).getCursor();for(;g.next();){var f=g.id;const p=g.materialKey;var k=g.insertAfter;const m=g.indexFrom,r=g.indexCount,y=g.vertexFrom,I=g.vertexCount;if(!d.has(f)){const z=new E(f);z.insertAfter=k;d.set(f,z);b.push(z)}k=d.get(f);f=new B(f,h,p);f.indexFrom=m;f.indexCount=r;
f.vertexFrom=y;f.vertexCount=I;k.displayRecords.push(f)}a[h]=F.VertexBuffers.fromVertexData(e,h)}else a[h]=(new H.VertexVectors(h,0)).intoBuffers()});b.sort((h,e)=>h.id-e.id);return l.fromMeshData({displayObjects:b,vertexBuffersMap:a})};l.fromMeshData=function(c){const b=new l,a=new x["default"],d=new w;a.displayObjects=c.displayObjects;for(const h in c.vertexBuffersMap){const e=c.vertexBuffersMap[h];d.geometries[h].indexBuffer=e.indexBuffer;d.geometries[h].vertexBuffer=e.namedBuffers}b.tileDisplayData=
a;b.tileBufferData=d;return b};l.bind=function(c,b){const a=new l;a.tileDisplayData=c;a.tileBufferData=b;return a};l.create=function(c,b){const a=new l;a.tileDisplayData=new x["default"];a.tileDisplayData.displayObjects=c;const d=[0,0,0,0,0],h=[0,0,0,0,0],e=[[],[],[],[],[]];for(var f of c)for(var k of f.displayRecords)e[k.geometryType].push(k),d[k.geometryType]+=k.meshData.vertexCount,h[k.geometryType]+=k.meshData.indexData.length;c=new w;b=[b.fill||{},b.line||{},b.icon||{},b.text||{},b.label||{}];
for(f=0;5>f;f++){k=new Uint32Array(h[f]);{var g=b[f];var p=d[f];const m={};for(const r in g){const y={data:t.allocateTypedArrayBuffer(p,g[r]),stride:g[r]};m[r]=y}g=m}B.writeAllMeshDataToBuffers(e[f],g,k);c.geometries[f]={indexBuffer:k,vertexBuffer:g}}a.tileBufferData=c;return a};l._align=function(c,b){const a=c%b;return 0===a?c:c+(b-a)};l._computeVertexAlignment=function(c){let b=!1,a=!1;for(const d of c)2===d%4?b=!0:0!==d%4&&(a=!0);return a?4:b?2:1};return l}();A.TileData=u;Object.defineProperty(A,
"__esModule",{value:!0})});