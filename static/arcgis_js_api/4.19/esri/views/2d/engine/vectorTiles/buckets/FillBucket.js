// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.19/esri/copyright.txt for details.
//>>built
define("../../../../../chunks/_rollupPluginBabelHelpers ../../../../../core/ArrayPool ../../../../../core/libs/earcut/earcut ../../webgl/Geometry ../../webgl/mesh/Tesselator ./BaseBucket".split(" "),function(C,D,E,A,G,H){const z=new G;return function(F){function w(a,b,c,d,g,e){a=F.call(this,a,b)||this;a.type=1;a._fillVertexBuffer=c;a._fillIndexBuffer=d;a._outlineVertexBuffer=g;a._outlineIndexBuffer=e;return a}C._inheritsLoose(w,F);var x=w.prototype;x.processFeatures=function(a){this._fillIndexStart=
3*this._fillIndexBuffer.index;this._fillIndexCount=0;this._outlineIndexStart=3*this._outlineIndexBuffer.index;this._outlineIndexCount=0;const b=this.layer,c=this.zoom;a&&a.setExtent(this.layerExtent);let d=void 0===b.getPaintValue("fill-pattern",c)&&b.getPaintValue("fill-antialias",c);if(b.outlineUsesFillColor){if(d&&!b.hasDataDrivenOpacity){var g=b.getPaintValue("fill-opacity",c),e=b.getPaintValue("fill-opacity",c+1);1>g&&1>e&&(d=!1)}d&&!b.hasDataDrivenColor&&(g=b.getPaintValue("fill-color",c),e=
b.getPaintValue("fill-color",c+1),1>g[3]&&1>e[3]&&(d=!1))}const {fillMaterial:f,outlineMaterial:p,hasDataDrivenFill:h,hasDataDrivenOutline:n}=b;for(const q of this._features){g=h?f.encodeAttributes(q,c,b):null;e=d&&n?p.encodeAttributes(q,c,b):null;const k=q.getGeometry(a);this._processFeature(k,d,b.outlineUsesFillColor,g,e,null==a?void 0:a.validateTessellation)}};x.serialize=function(){var a=10+this.layerUIDs.length;a+=this._fillVertexBuffer.array.length;a+=this._fillIndexBuffer.array.length;a+=this._outlineVertexBuffer.array.length;
a+=this._outlineIndexBuffer.array.length;a=new Uint32Array(a);var b=new Int32Array(a.buffer);let c=0;a[c++]=this.type;a[c++]=this.layerUIDs.length;for(var d=0;d<this.layerUIDs.length;d++)a[c++]=this.layerUIDs[d];a[c++]=this._fillIndexStart;a[c++]=this._fillIndexCount;a[c++]=this._outlineIndexStart;a[c++]=this._outlineIndexCount;a[c++]=this._fillVertexBuffer.array.length;for(d=0;d<this._fillVertexBuffer.array.length;d++)b[c++]=this._fillVertexBuffer.array[d];a[c++]=this._fillIndexBuffer.array.length;
for(d=0;d<this._fillIndexBuffer.array.length;d++)a[c++]=this._fillIndexBuffer.array[d];a[c++]=this._outlineVertexBuffer.array.length;for(d=0;d<this._outlineVertexBuffer.array.length;d++)b[c++]=this._outlineVertexBuffer.array[d];a[c++]=this._outlineIndexBuffer.array.length;for(b=0;b<this._outlineIndexBuffer.array.length;b++)a[c++]=this._outlineIndexBuffer.array[b];return a.buffer};x._processFeature=function(a,b,c,d,g,e){if(a){var f=a.length,p=!g||0===g.length;if(b&&(!c||p))for(b=0;b<f;b++)this._processOutline(a[b],
g);for(g=0;g<f;g++)if(b=w._area(a[g]),128<b){void 0!==h&&this._processFill(a,h,d,e);var h=[g]}else-128>b&&void 0!==h&&h.push(g);void 0!==h&&this._processFill(a,h,d,e)}};x._processOutline=function(a,b){const c=this._outlineVertexBuffer,d=this._outlineIndexBuffer,g=d.index;var e;let f,p;const h=new A.Point(0,0),n=new A.Point(0,0),q=new A.Point(0,0);let k=-1,l=-1;var m=-1;let r=-1,y=-1,B=!1,t=a.length;if(!(2>t)){var v=a[0];for(e=a[t-1];t&&e.isEqual(v);)--t,e=a[t-1];if(!(2>t-0)){for(v=0;v<t;++v){0===
v?(e=a[t-1],f=a[0],p=a[1],h.assignSub(f,e),h.normalize(),h.rightPerpendicular()):(e=f,f=p,p=v!==t-1?a[v+1]:a[0],h.assign(n));e=this._isClipEdge(e,f);-1===r&&(B=e);n.assignSub(p,f);n.normalize();n.rightPerpendicular();m=h.x*n.y-h.y*n.x;q.assignAdd(h,n);q.normalize();var u=-q.x*-h.x+-q.y*-h.y;u=Math.abs(0!==u?1/u:1);8<u&&(u=8);0<=m?(m=c.add(f.x,f.y,h.x,h.y,0,1,b),-1===r&&(r=m),0<=k&&0<=l&&0<=m&&!e&&d.add(k,l,m),l=c.add(f.x,f.y,u*-q.x,u*-q.y,0,-1,b),-1===y&&(y=l),0<=k&&0<=l&&0<=m&&!e&&d.add(k,l,m),k=
l,l=m,m=c.add(f.x,f.y,q.x,q.y,0,1,b),0<=k&&0<=l&&0<=m&&!e&&d.add(k,l,m),l=c.add(f.x,f.y,n.x,n.y,0,1,b)):(m=c.add(f.x,f.y,u*q.x,u*q.y,0,1,b),-1===r&&(r=m),0<=k&&0<=l&&0<=m&&!e&&d.add(k,l,m),l=c.add(f.x,f.y,-h.x,-h.y,0,-1,b),-1===y&&(y=l),0<=k&&0<=l&&0<=m&&!e&&d.add(k,l,m),k=l,l=m,m=c.add(f.x,f.y,-q.x,-q.y,0,-1,b),0<=k&&0<=l&&0<=m&&!e&&d.add(k,l,m),k=c.add(f.x,f.y,-n.x,-n.y,0,-1,b));0<=k&&0<=l&&0<=m&&!e&&d.add(k,l,m)}0<=k&&0<=l&&0<=r&&!B&&d.add(k,l,r);0<=k&&0<=r&&0<=y&&!B&&d.add(k,y,r);this._outlineIndexCount+=
3*(d.index-g)}}};x._processFill=function(a,b,c,d){var g;1<b.length&&(g=[]);var e=0;for(var f of b)0!==e&&g.push(e),e+=a[f].length;f=2*e;e=D.acquire();for(var p of b){var h=a[p];const q=h.length;for(let k=0;k<q;++k)e.push(h[k].x,h[k].y)}p=E.earcut(e,g,2);if(d&&0<E.deviation(e,g,2,p)){d=[];f=[];z.beginPolygon(d,f);for(var n of b)if(b=a[n],!(3>b.length)){z.beginContour();for(g=0;g<b.length;++g)p=b[g].x,h=b[g].y,p=[p,h,0],z.addVertex(p,p);z.endContour()}z.endPolygon();if(0<f.length){a=this._fillVertexBuffer.index;
for(n=0;n<d.length;)this._fillVertexBuffer.add(d[n++],d[n++],c);for(c=0;c<f.length;)this._fillIndexBuffer.add(a+f[c+0],a+f[c+1],a+f[c+2]),c+=3;this._fillIndexCount+=f.length}}else if(a=p.length,0<a){n=this._fillVertexBuffer.index;for(b=0;b<f;)this._fillVertexBuffer.add(e[b++],e[b++],c);for(c=0;c<a;)this._fillIndexBuffer.add(n+p[c++],n+p[c++],n+p[c++]);this._fillIndexCount+=a}D.release(e)};x._isClipEdge=function(a,b){return a.x===b.x?-64>=a.x||4160<=a.x:a.y===b.y?-64>=a.y||4160<=a.y:!1};w._area=function(a){let b=
0;const c=a.length-1;for(let d=0;d<c;d++)b+=(a[d].x-a[d+1].x)*(a[d].y+a[d+1].y);b+=(a[c].x-a[0].x)*(a[c].y+a[0].y);return.5*b};C._createClass(w,[{key:"fillIndexStart",get:function(){return this._fillIndexStart}},{key:"fillIndexCount",get:function(){return this._fillIndexCount}},{key:"outlineIndexStart",get:function(){return this._outlineIndexStart}},{key:"outlineIndexCount",get:function(){return this._outlineIndexCount}}]);return w}(H)});