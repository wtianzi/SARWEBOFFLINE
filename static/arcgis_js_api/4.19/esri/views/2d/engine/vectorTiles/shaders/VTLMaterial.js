// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.19/esri/copyright.txt for details.
//>>built
define(["exports","../../../../../chunks/_rollupPluginBabelHelpers","../../../../../chunks/vec4f32","../MemoryBuffer"],function(y,A,B,C){let z=function(){function v(a){this._color=B.create();this._key=a}var k=v.prototype;k.defines=function(){return[]};k.getStride=function(){this._layoutInfo||this._buildAttributesInfo();return this._stride};k.getAttributeLocations=function(){this._locations||this._buildAttributesInfo();return this._locations};k.getLayoutInfo=function(){this._layoutInfo||this._buildAttributesInfo();
return this._layoutInfo};k.getEncodingInfos=function(){this._propertyEncodingInfo||this._buildAttributesInfo();return this._propertyEncodingInfo};k.getUniforms=function(){this._uniforms||this._buildAttributesInfo();return this._uniforms};k.getShaderHeader=function(){this._shaderHeader||this._buildAttributesInfo();return this._shaderHeader};k.getShaderMain=function(){this._shaderMain||this._buildAttributesInfo();return this._shaderMain};k.setDataUniforms=function(a,c,d,f){const l=this.getUniforms();
for(const e in l){const b=l[e];switch(b.type){case "float":a.setUniform1f(b.name,b.getValue(d,c,f));break;case "vec2":a.setUniform2fv(b.name,b.getValue(d,c,f));break;case "vec4":{const h=b.getValue(d,c,f),g=h[3];this._color[0]=g*h[0];this._color[1]=g*h[1];this._color[2]=g*h[2];this._color[3]=g;a.setUniform4fv(b.name,this._color)}}}};k.encodeAttributes=function(a,c,d){const f=this.attributesInfo(),l=this.getEncodingInfos(),e=[];for(const g of Object.keys(l)){var b,h=l[g];const {type:m,precisionFactor:q,
isLayout:w}=f[g],t=w?d.getLayoutProperty(g):d.getPaintProperty(g),u=null==(b=t.interpolator)?void 0:b.getInterpolationRange(c);let x=0;for(const n of h){n.dataIndex>=e.length&&e.push(0);h=t.getValue(u?u[x]:c,a);switch(m){case 0:e[n.dataIndex]|=this._encodeByte(h*(q||1),8*n.offset);break;case 1:e[n.dataIndex]|=this._encodeByte(h*(q||1)+128,8*n.offset);break;case 2:e[n.dataIndex]=this._encodeColor(h);break;default:throw Error("Unsupported encoding type");}++x}}return e};k.getAtributeState=function(a){const c=
3+2*a;a=0|this._bit(c);return a|=this._bit(c+1)<<1};k._buildAttributesInfo=function(){const a=[],c={};var d={},f=-1,l=this.attributesInfo(),e=this.attributes();let b=-1;for(const m of e){++b;e=this.getAtributeState(b);if(0===e)continue;var h=l[m];const q=[];c[m]=q;h=h.type;for(let w=0;w<e;++w){const {dataType:t,bytesPerElement:u,count:x,normalized:n}=v._encodingInfo[h],r=t<<2|x;let p=d[r];p&&4!==p.offset||(++f,d[r]=p={dataIndex:f,offset:0},a.push({location:-1,name:"a_data_"+f,count:4/u,type:t,normalized:n}));
q.push({dataIndex:p.dataIndex,offset:p.offset});p.offset+=u*x}}this._buildVertexBufferLayout(a);d={};f=0;l=this._layoutInfo.geometry;for(var g of l)d[g.name]=f++;if(g=this._layoutInfo.opacity)for(const m of g)d[m.name]=f++;this._buildShaderInfo(a,c);this._propertyEncodingInfo=c;this._locations=d};k._buildVertexBufferLayout=function(a){const c={};var d=this.geometryInfo();let f=d[0].stride;if(0===a.length)c.geometry=d;else{const l=[];let e=f;f+=4*a.length;for(const b of d)d={...b},d.stride=f,l.push(d);
for(const b of a)l.push({name:b.name,count:b.count,type:b.type,offset:e,stride:f,normalized:b.normalized||!1,divisor:0}),e+=D(b.type)*b.count;c.geometry=l}this.opacityInfo()&&(c.opacity=this.opacityInfo());this._layoutInfo=c;this._stride=f};k._buildShaderInfo=function(a,c){let d="\n",f="\n";const l=[];for(var e of a)d+=`attribute ${this._getType(e.count)} ${e.name};\n`;var b=this.attributes();a=this.attributesInfo();e=-1;for(const m of b){++e;const {name:q,type:w,precisionFactor:t,isLayout:u}=a[m];
b=t&&1!==t?` * ${1/t}`:"";const {bytesPerElement:x,count:n}=v._encodingInfo[w];var h=r=>`a_data_${r.dataIndex}${2===w?"":`[${r.offset/x}]`}`;switch(this.getAtributeState(e)){case 0:b=this._getType(n);var g=`u_${q}`;l.push({name:g,type:b,getValue:(r,p)=>u?r.getLayoutValue(m,p):r.getPaintValue(m,p)});d+=`uniform ${b} ${g};\n`;f+=`${b} ${q} = ${g};\n`;break;case 1:g=h(c[m][0]);f+=`${this._getType(n)} ${q} = ${g}${b};\n`;break;case 2:{g=`u_t_${q}`;l.push({name:g,type:"float",getValue:(p,E,F)=>(u?p.getLayoutProperty(m):
p.getPaintProperty(m)).interpolator.interpolationUniformValue(F,E)});d+=`uniform float ${g};\n`;const r=h(c[m][0]);h=h(c[m][1]);f+=`${this._getType(n)} ${q} = mix(${r}${b}, ${h}${b}, ${g});\n`}}}this._shaderHeader=d;this._shaderMain=f;this._uniforms=l};k._bit=function(a){return(this._key&1<<a)>>a};k._getType=function(a){switch(a){case 1:return"float";case 2:return"vec2";case 4:return"vec4"}throw Error("Invalid count");};k._encodeColor=function(a){const c=255*a[3];return C.i8888to32(a[0]*c,a[1]*c,
a[2]*c,c)};k._encodeByte=function(a,c){return(a&255)<<c};A._createClass(v,[{key:"key",get:function(){return this._key}},{key:"type",get:function(){return this._key&7}}]);return v}();z._encodingInfo=[{dataType:5121,bytesPerElement:1,count:1,normalized:!1},{dataType:5121,bytesPerElement:1,count:1,normalized:!1},{dataType:5121,bytesPerElement:1,count:4,normalized:!0}];const D=v=>{switch(v){case 5126:return 4;case 5124:return 4;case 5125:return 4;case 5122:return 2;case 5123:return 2;case 5120:return 1;
case 5121:return 1}};y.VTLMaterial=z;Object.defineProperty(y,"__esModule",{value:!0})});