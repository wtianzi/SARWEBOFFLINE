// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.19/esri/copyright.txt for details.
//>>built
define("exports ../../../../chunks/_rollupPluginBabelHelpers ../../../../core/has ../../../../core/promiseUtils ../../../../request ../../../../core/ItemCache ../../../../core/workers/workers ../../tiling/TileKey ./TileIndex ./GlyphMosaic ./GlyphSource ./SpriteMosaic ./decluttering/debugging".split(" "),function(q,A,r,k,t,n,B,u,v,w,x,y,C){const z=new n(10),l=new Map;n=function(){function p(a,c,d){this._vectorTileLayer=a;this._styleRepository=c;this.devicePixelRatio=d;this._connection=this._glyphMosaic=
this._spriteMosaic=null}var f=p.prototype;f.destroy=function(){this._connection&&(this._connection.close(),this._connection=null);this._vectorTileLayer=this._styleRepository=null;this._spriteMosaic&&(this._spriteMosaic=null);this._glyphMosaic&&(this._glyphMosaic=null)};f.start=async function(a){const c=this._vectorTileLayer;var d=c.sourceNameToSource;const e=[];for(const b in d)e.push(this._fetchTileMap(d[b],a));this._spriteSourcePromise=this._vectorTileLayer.loadSpriteSource(this.devicePixelRatio,
a);this._spriteSourcePromise.then(b=>{this._spriteMosaic=new y(1024,1024,250);this._spriteMosaic.setSpriteSource(b)});d=new x(this._styleRepository.glyphs);this._glyphMosaic=new w(1024,1024,d);this._broadcastPromise=B.open("WorkerTileHandler",{client:this,scheduler:a.scheduler,signal:a.signal}).then(b=>{this._connection=b;return Promise.all(this._connection.broadcast("setStyle",{style:c.currentStyleInfo.style,vectorTileLayerMaxBuffers:r("vectortilelayer-max-buffers")},a))});return Promise.all(e)};
f.updateStyle=async function(a){await this._broadcastPromise;return this._broadcastPromise=new Promise((c,d)=>{Promise.all(this._connection.broadcast("updateStyle",a)).then(c,d)})};f.setStyle=async function(a,c){await this._broadcastPromise;this._styleRepository=a;const d=this._vectorTileLayer.sourceNameToSource,e=[];for(const b in d)e.push(this._fetchTileMap(d[b],null));this._spriteSourcePromise=this._vectorTileLayer.loadSpriteSource(this.devicePixelRatio,null);this._spriteSourcePromise.then(b=>
{this._spriteMosaic=new y(1024,1024,250);this._spriteMosaic.setSpriteSource(b)});a=new x(a.glyphs);this._glyphMosaic=new w(1024,1024,a);this._broadcastPromise=new Promise((b,g)=>{Promise.all(this._connection.broadcast("setStyle",{style:c,vectorTileLayerMaxBuffers:r("vectortilelayer-max-buffers")})).then(b,g)});e.push(this._broadcastPromise);return Promise.all(e)};f.fetchTileData=function(a,c){return this._getRefKeys(a,c).then(d=>{const e=this._vectorTileLayer.sourceNameToSource,b=[];for(const g in e)b.push(g);
return this._getSourcesData(b,d,c)})};f.parseTileData=function(a,c){const d=a&&a.data;if(!d)return Promise.resolve(null);const {sourceName2DataAndRefKey:e,transferList:b}=d;return 0===Object.keys(e).length?Promise.resolve(null):this._broadcastPromise.then(()=>this._connection.getAvailableClient().then(g=>g.invoke("createTileAndParse",{key:a.key.id,sourceName2DataAndRefKey:e,styleLayerUIDs:a.styleLayerUIDs},{...c,transferList:b}).then(m=>({tileData:m}))))};f.getSprites=async function(a){await this._spriteSourcePromise;
return this._spriteMosaic.getSpriteItems(a)};f.getGlyphs=function(a){return this._glyphMosaic.getGlyphItems(a.font,a.codePoints)};f.perfReport=function({key:a,milliseconds:c}){C.perfAdd(a,c,"ms")};f._getTilePayload=async function(a,c,d){a=u.pool.acquire(a.id);const e=this._vectorTileLayer.sourceNameToSource[c].getSourceTileUrl(a.level,a.row,a.col);u.pool.release(a);try{return{protobuff:await this.request(e,d),sourceName:c}}catch(b){if(k.isAbortError(b))throw b;return{protobuff:null,sourceName:c}}};
f.request=function(a,c){return t(a,{responseType:"array-buffer",...c}).then(({data:d})=>d)};f._fetchTileMap=async function(a,c){if(a.capabilities.operations.supportsTileMap&&a.tileIndex)return Promise.resolve();if(a.tileMapURL){var d=z.get(a.tileMapURL);if(d)a.tileIndex=d;else if(l.has(a.tileMapURL))try{var e=await l.get(a.tileMapURL);a.tileIndex=new v(e.data)}catch(b){if(k.isAbortError(b))throw b;}else{c=t(a.tileMapURL,c);l.set(a.tileMapURL,c);try{e=await c,l.delete(a.tileMapURL),z.put(a.tileMapURL,
a.tileIndex),a.tileIndex=new v(e.data)}catch(b){if(l.delete(a.tileMapURL),k.isAbortError(b))throw b;}}}};f._getRefKeys=function(a,c){const d=this._vectorTileLayer.sourceNameToSource,e=[];for(const b in d){const g=d[b].getRefKey(a,c);e.push(g)}return k.eachAlways(e)};f._getSourcesData=function(a,c,d){const e=[];for(let b=0;b<c.length;b++)if(null==c[b].value||null==a[b])e.push(null);else{const g=this._getTilePayload(c[b].value,a[b],d);e.push(g)}return k.eachAlways(e).then(b=>{const g={},m=[];for(let h=
0;h<b.length;h++)b[h].value&&b[h].value&&b[h].value.protobuff&&0<b[h].value.protobuff.byteLength&&(g[b[h].value.sourceName]={refKey:c[h].value.id,protobuff:b[h].value.protobuff},m.push(b[h].value.protobuff));return{sourceName2DataAndRefKey:g,transferList:m}})};A._createClass(p,[{key:"spriteMosaic",get:function(){return this._spriteSourcePromise.then(()=>this._spriteMosaic)}},{key:"glyphMosaic",get:function(){return this._glyphMosaic}}]);return p}();q.TileHandler=n;Object.defineProperty(q,"__esModule",
{value:!0})});