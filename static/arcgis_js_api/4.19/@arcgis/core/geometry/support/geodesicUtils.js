/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.19/esri/copyright.txt for details.
*/
import"../../chunks/tslib.es6.js";import"../../chunks/ArrayPool.js";import"../../core/lang.js";import"../../chunks/deprecate.js";import"../../chunks/object.js";import"../../config.js";import"../../chunks/Logger.js";import"../../chunks/string.js";import"../../chunks/metadata.js";import"../../core/accessorSupport/decorators/property.js";import"../../core/Accessor.js";import"../../chunks/PropertyOrigin.js";import"../../core/scheduling.js";import"../../core/promiseUtils.js";import"../../chunks/Message.js";import e from"../../core/Error.js";import"../../chunks/ensureType.js";import"../../core/accessorSupport/decorators/subclass.js";import"../../chunks/JSONSupport.js";import"../../core/urlUtils.js";import"../../core/accessorSupport/decorators/cast.js";import"../../chunks/jsonMap.js";import"../../chunks/reader.js";import"../../chunks/writer.js";import"../../chunks/resourceExtension.js";import t from"../SpatialReference.js";import"../Geometry.js";import s from"../Point.js";import"../../chunks/Ellipsoid.js";import"./webMercatorUtils.js";import"../Extent.js";import"../../chunks/zmUtils.js";import"../Multipoint.js";import n from"../Polygon.js";import"../../chunks/extentUtils.js";import i from"../Polyline.js";import"../../chunks/typeUtils.js";import"./jsonUtils.js";import"../../geometry.js";import{c as r}from"../../chunks/unitUtils.js";import{t as o,s as a,W as c}from"../../chunks/geodesicConstants.js";function p(e){if(!e)return null;if(e.isGeographic&&e.wkid){const t=a[e.wkid];if(t)return t}if(e.wkt){const t=c.exec(e.wkt);if(!t||2!==t.length)return null;const s=t[1].split(",");if(!s||s.length<3)return null;const n=parseFloat(s[1]),i=parseFloat(s[2]);if(isNaN(n)||isNaN(i))return null;return{a:n,f:0===i?0:1/i}}return null}function l(e){const s=p(e||t.WGS84);if(function(e){return"b"in e&&"eSq"in e&&"radius"in e}(s))return s;const n=s.a*(1-s.f);return Object.assign(s,{b:n,eSq:1-(n/s.a)**2,radius:(2*s.a+n)/3,densificationRatio:1e4/((2*s.a+n)/3)})}function h(e,t,s){const{a:n,eSq:i}=l(s),r=Math.sqrt(i),a=Math.sin(t[1]*o),c=n*t[0]*o;let p;if(i>0){p=n*((1-i)*(a/(1-i*(a*a))-1/(2*r)*Math.log((1-r*a)/(1+r*a))))*.5}else p=n*a;return e[0]=c,e[1]=p,e}function u(e){return null!==p(e)}function f(t,s="square-meters"){if(t.some((e=>!u(e.spatialReference))))throw new e("geodesic-areas:invalid-spatial-reference","the input geometries spatial reference is not supported");const n=[];for(let e=0;e<t.length;e++){const s=t[e],i=s.spatialReference,{radius:r,densificationRatio:o}=l(i),a=r*o;n.push(d(s,a))}const i=[],o=[0,0],a=[0,0];for(let e=0;e<n.length;e++){const{rings:t,spatialReference:c}=n[e];let p=0;for(let e=0;e<t.length;e++){const s=t[e];h(o,s[0],c),h(a,s[s.length-1],c);let n=a[0]*o[1]-o[0]*a[1];for(let e=0;e<s.length-1;e++)h(o,s[e+1],c),h(a,s[e],c),n+=a[0]*o[1]-o[0]*a[1];p+=n}p=r(p,"square-meters",s),i.push(p/-2)}return i}function m(t,s="meters"){const n=t,i=t;if(!n&&!i)throw new e("geodesic-lengths:invalid-geometries","the input geometries type is not supported");if(n?n.some((e=>!u(e.spatialReference))):i.some((e=>!u(e.spatialReference))))throw new e("geodesic-lengths:invalid-spatial-reference","the input geometries spatial reference is not supported");const o=[];for(let e=0;e<t.length;e++){const n=t[e],{spatialReference:i}=n,a="polyline"===n.type?n.paths:n.rings;let c=0;for(let e=0;e<a.length;e++){const t=a[e];let s=0;for(let e=1;e<t.length;e++){const n=t[e-1][0],r=t[e][0],o=t[e-1][1],a=t[e][1];if(o!==a||n!==r){const e={distance:null};M(e,[n,o],[r,a],i),s+=e.distance}}c+=s}c=r(c,"meters",s),o.push(c)}return o}function d(t,s){if("polyline"!==t.type&&"polygon"!==t.type)throw new e("geodesic-densify:invalid-geometry","the input geometry is neither polyline nor polygon");const{spatialReference:r}=t;if(!u(r))throw new e("geodesic-densify:invalid-spatial-reference","the input geometry spatial reference is not supported");const o="polyline"===t.type?t.paths:t.rings,a=[],c=[0,0],p={distance:null};for(const e of o){const t=[];a.push(t),t.push([e[0][0],e[0][1]]);let n,i,o=e[0][0],l=e[0][1];for(let a=0;a<e.length-1;a++){if(n=e[a+1][0],i=e[a+1][1],o===n&&l===i)continue;const h=[o,l];M(p,[o,l],[n,i],r);const{azimuth:u,distance:f}=p,m=f/s;if(m>1){for(let e=1;e<=m-1;e++){g(c,h,u,e*s,r),t.push(c.slice(0))}g(c,h,u,(f+Math.floor(m-1)*s)/2,r),t.push(c.slice(0))}g(c,h,u,f,r),t.push(c.slice(0)),o=c[0],l=c[1]}}return"polyline"===t.type?new i({paths:a,spatialReference:r}):new n({rings:a,spatialReference:r})}function g(e,t,s,n,i){const r=t[0],a=t[1],c=r*o,p=a*o,h=s*o,{a:u,b:f,f:m}=l(i),d=Math.sin(h),g=Math.cos(h),M=(1-m)*Math.tan(p),j=1/Math.sqrt(1+M*M),w=M*j,y=Math.atan2(M,g),k=j*d,R=k*k,v=1-R,b=v*(u*u-f*f)/(f*f),q=1+b/16384*(4096+b*(b*(320-175*b)-768)),z=b/1024*(256+b*(b*(74-47*b)-128));let S,x,U,N,A=n/(f*q),P=2*Math.PI;for(;Math.abs(A-P)>1e-12;)U=Math.cos(2*y+A),S=Math.sin(A),x=Math.cos(A),N=z*S*(U+z/4*(x*(2*U*U-1)-z/6*U*(4*S*S-3)*(4*U*U-3))),P=A,A=n/(f*q)+N;const E=w*S-j*x*g,G=Math.atan2(w*x+j*S*g,(1-m)*Math.sqrt(R+E*E)),O=Math.atan2(S*d,j*x-w*S*g),F=m/16*v*(4+m*(4-3*v)),W=G/o,C=(c+(O-(1-F)*m*k*(A+F*S*(U+F*x*(2*U*U-1)))))/o;return e[0]=C,e[1]=W,e}function M(e,t,s,n){const i=t[0]*o,r=t[1]*o,a=s[0]*o,c=s[1]*o,{a:p,b:h,f:u,radius:f}=l(n),m=a-i,d=Math.atan((1-u)*Math.tan(r)),g=Math.atan((1-u)*Math.tan(c)),M=Math.sin(d),j=Math.cos(d),w=Math.sin(g),y=Math.cos(g);let k,R,v,b,q,z,S,x,U,N,A=1e3,P=m;do{if(S=Math.sin(P),x=Math.cos(P),v=Math.sqrt(y*S*(y*S)+(j*w-M*y*x)*(j*w-M*y*x)),0===v)return e.distance=0,e.azimuth=void 0,e.reverseAzimuth=void 0,e;q=M*w+j*y*x,z=Math.atan2(v,q),U=j*y*S/v,R=1-U*U,b=q-2*M*w/R,isNaN(b)&&(b=0),N=u/16*R*(4+u*(4-3*R)),k=P,P=m+(1-N)*u*U*(z+N*v*(b+N*q*(2*b*b-1)))}while(Math.abs(P-k)>1e-12&&--A>0);if(0===A){const t=f,s=Math.acos(Math.sin(r)*Math.sin(c)+Math.cos(r)*Math.cos(c)*Math.cos(a-i))*t,n=a-i,p=Math.sin(n)*Math.cos(c),l=Math.cos(r)*Math.sin(c)-Math.sin(r)*Math.cos(c)*Math.cos(n),h=Math.atan2(p,l);return e.azimuth=h/o,e.distance=s,e.reverseAzimuth=void 0,e}const E=R*(p*p-h*h)/(h*h),G=E/1024*(256+E*(E*(74-47*E)-128)),O=h*(1+E/16384*(4096+E*(E*(320-175*E)-768)))*(z-G*v*(b+G/4*(q*(2*b*b-1)-G/6*b*(4*v*v-3)*(4*b*b-3)))),F=Math.atan2(y*Math.sin(P),j*w-M*y*Math.cos(P)),W=Math.atan2(j*Math.sin(P),j*w*Math.cos(P)-M*y);return e.azimuth=F/o,e.distance=O,e.reverseAzimuth=W/o,e}function j(t,s,n="meters"){if(!t||!s)throw new e("geodesic-distance:missing-parameters","one or both input parameters are missing");if(!t.spatialReference||!s.spatialReference)throw new e("geodesic-distance:invalid-parameters","one or both input points do not have a spatial reference");if(!t.spatialReference.equals(s.spatialReference))throw new e("geodesic-distance:invalid-parameters","spatial references of input parameters do not match");const{spatialReference:i}=t;if(!u(i))throw new e("geodesic-distance:not-supported","input geometry spatial reference is not supported");if(t.equals(s))return{distance:0,azimuth:0,reverseAzimuth:0};const o={distance:null};return M(o,[t.x,t.y],[s.x,s.y],i),o.distance=r(o.distance,"meters",n),o}function w(t,n,i){if(!t||null==n||null==i)throw new e("point-from-distance:missing-parameters","one or more input parameters are missing or undefined");if(i<0||i>360)throw new e("point-from-distance:-of-bounds","azimuth is restricted to angles between, and including, 0° to 360° degrees");if(!t.spatialReference)throw new e("point-from-distance:missing-spatial-reference","the input point must have a spatial reference");const{spatialReference:r}=t;if(!u(r))throw new e("geodesic-distance:not-supported","input geometry spatial reference is not supported");const o=[0,0];return g(o,[t.x,t.y],i,n,r),new s({x:o[0],y:o[1],spatialReference:r})}export{g as directGeodeticSolver,f as geodesicAreas,d as geodesicDensify,j as geodesicDistance,m as geodesicLengths,M as inverseGeodeticSolver,u as isSupported,w as pointFromDistance};
