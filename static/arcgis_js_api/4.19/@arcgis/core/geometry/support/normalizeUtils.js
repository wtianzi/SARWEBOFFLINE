/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.19/esri/copyright.txt for details.
*/
import"../../chunks/tslib.es6.js";import"../../chunks/ArrayPool.js";import"../../core/lang.js";import"../../chunks/deprecate.js";import"../../chunks/object.js";import"../../kernel.js";import t from"../../config.js";import{L as e,b as s,i as n}from"../../chunks/Logger.js";import"../../chunks/string.js";import"../../chunks/metadata.js";import"../../core/accessorSupport/decorators/property.js";import"../../core/Accessor.js";import"../../chunks/PropertyOrigin.js";import"../../core/scheduling.js";import"../../core/promiseUtils.js";import"../../chunks/Message.js";import r from"../../core/Error.js";import"../../chunks/ensureType.js";import"../../core/accessorSupport/decorators/subclass.js";import"../../chunks/JSONSupport.js";import{urlToObject as o}from"../../core/urlUtils.js";import"../../core/accessorSupport/decorators/cast.js";import"../../chunks/jsonMap.js";import"../../chunks/reader.js";import"../../chunks/writer.js";import"../../chunks/resourceExtension.js";import{g as i}from"../SpatialReference.js";import c from"../../request.js";import"../Geometry.js";import"../Point.js";import"../../chunks/Ellipsoid.js";import{geographicToWebMercator as p,webMercatorToGeographic as l}from"./webMercatorUtils.js";import"../Extent.js";import"../../chunks/zmUtils.js";import"../Multipoint.js";import u from"../Polygon.js";import"../../chunks/extentUtils.js";import f from"../Polyline.js";import"../../chunks/typeUtils.js";import{fromJSON as a,getJsonType as m,getGeometryType as h}from"./jsonUtils.js";import"../../geometry.js";import{g,c as y,o as j,u as x}from"../../chunks/normalizeUtilsCommon.js";async function d(t,e,s){const n="string"==typeof t?o(t):t,r=e[0].spatialReference,i=m(e[0]),p={...s,query:{...n.query,f:"json",sr:r.wkid?r.wkid:JSON.stringify(r),geometries:JSON.stringify(k(e))}};return function(t,e,s){const n=h(e);return t.map((t=>{const e=n.fromJSON(t);return e.spatialReference=s,e}))}((await c(n.path+"/simplify",p)).data,i,r)}function k(t){return{geometryType:m(t[0]),geometries:t.map((t=>t.toJSON()))}}const w=e.getLogger("esri.geometry.support.normalizeUtils");function S(t){return"polyline"===t[0].type}function R(t){const e=[];let s=0,n=0;for(let r=0;r<t.length;r++){const o=t[r];let i=null;for(let t=0;t<o.length;t++)i=o[t],e.push(i),0===t?(s=i[0],n=s):(s=Math.min(s,i[0]),n=Math.max(n,i[0]));i&&e.push([(s+n)/2,0])}return e}function M(t,e){if(!(t instanceof f||t instanceof u)){const t="straightLineDensify: the input geometry is neither polyline nor polygon";throw w.error(t),new r(t)}const s=g(t),n=[];for(const t of s){const s=[];n.push(s),s.push([t[0][0],t[0][1]]);for(let n=0;n<t.length-1;n++){const r=t[n][0],o=t[n][1],i=t[n+1][0],c=t[n+1][1],p=Math.sqrt((i-r)*(i-r)+(c-o)*(c-o)),l=(c-o)/p,u=(i-r)/p,f=p/e;if(f>1){for(let t=1;t<=f-1;t++){const n=t*e,i=u*n+r,c=l*n+o;s.push([i,c])}const t=(p+Math.floor(f-1)*e)/2,n=u*t+r,i=l*t+o;s.push([n,i])}s.push([i,c])}}return function(t){return"polygon"===t.type}(t)?new u({rings:n,spatialReference:t.spatialReference}):new f({paths:n,spatialReference:t.spatialReference})}function P(t,e,s){if(e){const e=M(t,1e6);t=l(e,!0)}return s&&(t=x(t,s)),t}function U(t,e,s){if(Array.isArray(t)){const n=t[0];if(n>e){const s=j(n,e);t[0]=n+s*(-2*e)}else if(n<s){const e=j(n,s);t[0]=n+e*(-2*s)}}else{const n=t.x;if(n>e){const s=j(n,e);t=t.clone().offset(s*(-2*e),0)}else if(n<s){const e=j(n,s);t=t.clone().offset(e*(-2*s),0)}}return t}async function b(e,r,l){if(!Array.isArray(e))return b([e],r);const h=r?r.url:t.geometryServiceUrl;let k,w,R,M,N,O,J,q,A=0;const L=[],v=[];for(const t of e)if(s(t))v.push(t);else if(k||(k=t.spatialReference,w=i(k),R=k.isWebMercator,O=R?102100:4326,M=y[O].maxX,N=y[O].minX,J=y[O].plus180Line,q=y[O].minus180Line),w)if("mesh"===t.type)v.push(t);else if("point"===t.type)v.push(U(t.clone(),M,N));else if("multipoint"===t.type){const e=t.clone();e.points=e.points.map((t=>U(t,M,N))),v.push(e)}else if("extent"===t.type){const e=t.clone()._normalize(!1,!1,w);v.push(e.rings?new u(e):e)}else if(t.extent){const e=t.extent,s=j(e.xmin,N)*(2*M);let n=0===s?t.clone():x(t.clone(),s);e.offset(s,0),e.intersects(J)&&e.xmax!==M?(A=e.xmax>A?e.xmax:A,n=P(n,R),L.push(n),v.push("cut")):e.intersects(q)&&e.xmin!==N?(A=e.xmax*(2*M)>A?e.xmax*(2*M):A,n=P(n,R,360),L.push(n),v.push("cut")):v.push(n)}else v.push(t.clone());else v.push(t);let z=j(A,M),E=-90;const I=z,T=new f;for(;z>0;){const t=360*z-180;T.addPath([[t,E],[t,-1*E]]),E*=-1,z--}if(L.length>0&&I>0){const t=function(t,e){let s=-1;for(let n=0;n<e.cutIndexes.length;n++){const r=e.cutIndexes[n],o=e.geometries[n],i=g(o);for(let t=0;t<i.length;t++){const e=i[t];e.some((s=>{if(s[0]<180)return!0;{let s=0;for(let t=0;t<e.length;t++){const n=e[t][0];s=n>s?n:s}s=Number(s.toFixed(9));const n=-360*j(s,180);for(let s=0;s<e.length;s++){const e=o.getPoint(t,s);o.setPoint(t,s,e.clone().offset(n,0))}return!0}}))}if(r===s){if("polygon"===t[0].type)for(const e of g(o))t[r]=t[r].addRing(e);else if(S(t))for(const e of g(o))t[r]=t[r].addPath(e)}else s=r,t[r]=o}return t}(L,await async function(t,e,s,n){const r="string"==typeof t?o(t):t,i=e[0].spatialReference,p={...n,query:{...r.query,f:"json",sr:JSON.stringify(i),target:JSON.stringify({geometryType:m(e[0]),geometries:e}),cutter:JSON.stringify(s)}},l=await c(r.path+"/cut",p),{cutIndexes:u,geometries:f=[]}=l.data;return{cutIndexes:u,geometries:f.map((t=>{const e=a(t);return e.spatialReference=i,e}))}}(h,L,T,l)),s=[],r=[];for(let o=0;o<v.length;o++){const i=v[o];if("cut"!==i)r.push(i);else{const i=t.shift(),c=e[o];n(c)&&"polygon"===c.type&&c.rings&&c.rings.length>1&&i.rings.length>=c.rings.length?(s.push(i),r.push("simplify")):r.push(R?p(i):i)}}if(!s.length)return r;const i=await d(h,s,l),u=[];for(let t=0;t<r.length;t++){const e=r[t];"simplify"!==e?u.push(e):u.push(R?p(i.shift()):i.shift())}return u}const X=[];for(let t=0;t<v.length;t++){const e=v[t];if("cut"!==e)X.push(e);else{const t=L.shift();X.push(!0===R?p(t):t)}}return Promise.resolve(X)}function N(t){if(!t)return null;const e=t.extent;if(!e)return null;const s=t.spatialReference&&i(t.spatialReference);if(!s)return e;const[n,r]=s.valid,o=2*r,{width:c}=e;let p,{xmin:l,xmax:u}=e;if([l,u]=[u,l],"extent"===t.type||0===c||c<=r||c>o||l<n||u>r)return e;switch(t.type){case"polygon":if(!(t.rings.length>1))return e;p=R(t.rings);break;case"polyline":if(!(t.paths.length>1))return e;p=R(t.paths);break;case"multipoint":p=t.points}const f=e.clone();for(let t=0;t<p.length;t++){let e=p[t][0];e<0?(e+=r,u=Math.max(e,u)):(e-=r,l=Math.min(e,l))}return f.xmin=l,f.xmax=u,f.width<c?(f.xmin-=r,f.xmax-=r,f):e}function O(t,e){const s=i(e);if(s){const[e,n]=s.valid,r=n-e;if(t<e)for(;t<e;)t+=r;if(t>n)for(;t>n;)t-=r}return t}export{N as getDenormalizedExtent,b as normalizeCentralMeridian,O as normalizeMapX,M as straightLineDensify};
