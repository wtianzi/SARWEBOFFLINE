/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.19/esri/copyright.txt for details.
*/
import{_ as e}from"./tslib.es6.js";import{clone as i,h as s}from"../core/lang.js";import{L as t,b as r}from"./Logger.js";import{property as a}from"../core/accessorSupport/decorators/property.js";import l from"../core/Error.js";import"./ensureType.js";import{subclass as o}from"../core/accessorSupport/decorators/subclass.js";import"../core/urlUtils.js";import{w as n}from"./writer.js";import"./resourceExtension.js";import u from"../renderers/visualVariables/support/SizeStop.js";import p from"../renderers/visualVariables/SizeVariable.js";import{i as c}from"./sizeVariableUtils.js";import{c as d}from"./MD5.js";var m;let f=m=class extends p{writeLevels(e,i,s){for(const s in e){const e=this.levels[s];return void(i.stops=e)}}clone(){return new m({axis:this.axis,field:this.field,valueExpression:this.valueExpression,valueExpressionTitle:this.valueExpressionTitle,maxDataValue:this.maxDataValue,maxSize:c(this.maxSize)?this.maxSize.clone():this.maxSize,minDataValue:this.minDataValue,minSize:c(this.minSize)?this.minSize.clone():this.minSize,normalizationField:this.normalizationField,stops:this.stops&&this.stops.map((e=>e.clone())),target:this.target,useSymbolValue:this.useSymbolValue,valueRepresentation:this.valueRepresentation,valueUnit:this.valueUnit,legendOptions:this.legendOptions&&this.legendOptions.clone(),levels:i(this.levels)})}};e([a()],f.prototype,"levels",void 0),e([n("levels")],f.prototype,"writeLevels",null),f=m=e([o("esri.views.2d.engine.LevelDependentSizeVariable")],f);const v=t.getLogger("esri.views.2d.layers.support.clusterUtils");s.add("esri-cluster-arcade-enabled",1);const x=s("esri-cluster-arcade-enabled"),h=(e,i,s,t)=>{const a=i.clone();if(!E(a))return a;if(s.fields)for(const i of s.fields)b(e,i);if("visualVariables"in a){const i=(a.visualVariables||[]).filter((e=>"$view.scale"!==e.valueExpression)),l=S(i);i.forEach((i=>{"rotation"===i.type?i.field?i.field=w(e,i.field,"avg_angle"):i.valueExpression&&(i.field=g(e,i.valueExpression,"avg_angle"),i.valueExpression=null):i.normalizationField?(i.field=w(e,i.field,"norm",i.normalizationField),i.normalizationField=null):i.field?i.field=w(e,i.field,"avg"):(i.field=g(e,i.valueExpression,"avg"),i.valueExpression=null)})),r(l)&&!z(i)&&(i.push(y(s,t)),a.dynamicClusterSize=!0),a.visualVariables=i}switch(a.type){case"simple":break;case"unique-value":a.field?a.field=w(e,a.field,"mode"):a.valueExpression&&(a.field=g(e,a.valueExpression,"mode"),a.valueExpression=null);break;case"class-breaks":a.normalizationField?(a.field=w(e,a.field,"norm",a.normalizationField),a.normalizationField=null):a.field?a.field=w(e,a.field,"avg"):(a.field=g(e,a.valueExpression,"avg"),a.valueExpression=null)}return a},S=e=>{for(const i of e)if("size"===i.type)return i;return null},z=e=>{for(const i of e)if("cluster_count"===i.field)return!0;return!1},y=(e,i)=>{const s=[new u({value:0,size:0}),new u({value:1})];if(r(i))return new p({field:"cluster_count",stops:[...s,new u({value:2,size:0})]});const t=Object.keys(i).reduce(((t,r)=>({...t,[r]:[...s,new u({value:Math.max(2,i[r].minValue),size:e.clusterMinSize}),new u({value:Math.max(3,i[r].maxValue),size:e.clusterMaxSize})]})),{});return new f({field:"cluster_count",levels:t})},E=e=>{const i=i=>v.error(new l("Unsupported-renderer",i,{renderer:e}));if("unique-value"===e.type){if(e.field2||e.field3)return i("FeatureReductionCluster does not support multi-field UniqueValueRenderers"),!1}else if("class-breaks"===e.type){if(e.normalizationField){const s=e.normalizationType;if("field"!==s)return i(`FeatureReductionCluster does not support a normalizationType of ${s}`),!1}}else if("simple"!==e.type)return i(`FeatureReductionCluster does not support renderers of type ${e.type}`),!1;if(!x){if("valueExpression"in e&&e.valueExpression)return i("FeatureReductionCluster does not currently support renderer.valueExpression. Support will be added in a future release"),!1;if(("visualVariables"in e&&e.visualVariables||[]).some((e=>!(!("valueExpression"in e)||!e.valueExpression))))return i("FeatureReductionCluster does not currently support visualVariables with a valueExpression. Support will be added in a future release"),!1}return!0};function b(e,i){const{name:s,outStatistic:t}=i,{onStatisticField:r,onStatisticValueExpression:a,statisticType:o}=t;if(a){const i=d(a.toLowerCase());e.push({name:s,outStatistic:{onStatisticField:i,onStatisticValueExpression:a,statisticType:o}})}else r?e.push({name:s,outStatistic:{onStatisticField:r,statisticType:o}}):v.error(new l("mapview-unsupported-field","Unable to handle field",{field:i}))}function g(e,i,s){const t=d(i),r="mode"===s?`cluster_type_${t}`:`cluster_avg_${t}`;return e.some((e=>e.name===r))||e.push({name:r,outStatistic:{onStatisticField:t,onStatisticValueExpression:i,statisticType:s}}),r}function w(e,i,s,t){if("cluster_count"===i||e.some((e=>e.name===i)))return i;const r=function(e,i,s){switch(e){case"avg":case"avg_angle":return`cluster_avg_${i}`;case"mode":return`cluster_type_${i}`;case"norm":{const e=s,t="field",r=i.toLowerCase()+",norm:"+t+","+e.toLowerCase();return"cluster_avg_"+d(r)}}}(s,i,t);return e.some((e=>e.name===r))||("norm"===s?e.push({name:r,outStatistic:{onStatisticField:i,onStatisticNormalizationField:t,statisticType:s}}):e.push({name:r,outStatistic:{onStatisticField:i,statisticType:s}})),r}export{y as a,h as c,S as f,E as i};
