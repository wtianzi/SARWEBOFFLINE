/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.19/esri/copyright.txt for details.
*/
import{_ as e}from"./tslib.es6.js";import{i as t,u as i,L as s,b as r}from"./Logger.js";import{c as o}from"./vec3f64.js";import{a,s as n,d as l,b as p,e as c,g as u,l as d,k as h}from"./vec3.js";import{d as f}from"./screenUtils.js";import{a as m}from"./BufferView.js";import{c as g}from"./vec2.js";import{S as v,T as P,B as b,g as x,O as C,d as E,E as y,p as w,a as S,b as O,D as j,V as T,ae as R,u as q,H as A,v as B,R as D,M as U,af as _,z as L,G as H,A as M,m as V}from"./VertexColor.glsl.js";import{P as I}from"./Program.js";import{s as z,m as N,d as W,a as $}from"./renderState.js";import{u as F,p as G}from"./geometryUtils.js";import{g as X,j as k,D as J}from"./ColorMaterial.js";import{h as K}from"./Util.js";import{i as Q}from"./Object3D.js";import{L as Y}from"./RibbonLineMaterial.js";var Z=Object.freeze({__proto__:null,build:function(e){const t=new v;return t.include(P,{linearDepth:!1}),t.include(b,e),t.include(Y,e),t.vertex.uniforms.add("proj","mat4").add("view","mat4"),t.attributes.add("position","vec3"),t.varyings.add("vpos","vec3"),t.vertex.code.add(x`
    void main(void) {
      vpos = position;
      forwardNormalizedVertexColor();
      gl_Position = transformPosition(proj, view, vpos);
  `),e.stippleEnabled&&(t.attributes.add("auxpos1","vec3"),t.vertex.uniforms.add("ndcToPixel","vec2"),t.vertex.code.add(x`
    vec4 vpos2 = transformPosition(proj, view, auxpos1);
    float lineSegmentPixelSize = length((vpos2.xy / vpos2.w - gl_Position.xy / gl_Position.w) * ndcToPixel);

    stipplePatternUv = lineSegmentPixelSize * stipplePatternPixelSizeInv;
    ${e.stippleIntegerRepeatsEnabled?"stipplePatternUv = floor(stipplePatternUv + 0.5);":""}

    // Cancel out perspective correct interpolation because we want this length the really represent
    // the screen distance
    stipplePatternUv *= gl_Position.w;
    `)),t.vertex.code.add(x`
  }
  `),4===e.output&&t.include(C),t.include(E,e),t.fragment.uniforms.add("constantColor","vec4").add("alphaCoverage","float"),t.fragment.code.add(x`
  void main() {
    discardBySlice(vpos);

    vec4 color = ${e.attributeColor?"vColor":"constantColor"};

    float stippleAlpha = getStippleAlpha();
    discardByStippleAlpha(stippleAlpha, stippleAlphaColorDiscard);

    vec4 finalColor = blendStipple(vec4(color.rgb, color.a * alphaCoverage), stippleAlpha);

    if (finalColor.a < ${x.float(y)}) {
      discard;
    }

    ${0===e.output?x`gl_FragColor = highlightSlice(finalColor, vpos);`:""}
    ${4===e.output?x`outputHighlight();`:""}
  }
  `),t}});class ee extends O{constructor(e,t){super(e,t),this.stipplePattern=null,this.stippleTextureBind=null,this.stippleTextureRepository=e.stippleTextureRepository}initializeProgram(e){const t=ee.shader.get(),i=this.configuration,s=t.build({output:i.output,attributeColor:i.vertexColors,slicePlaneEnabled:i.slicePlaneEnabled,sliceHighlightDisabled:!1,sliceEnabledForVertexPrograms:!1,stippleEnabled:i.stippleEnabled,stippleOffColorEnabled:i.stippleOffColorEnabled,stippleUVMaxEnabled:!1,stippleIntegerRepeatsEnabled:i.stippleIntegerRepeatsEnabled});return new I(e.rctx,s.generateSource("vertex"),s.generateSource("fragment"),j)}dispose(){super.dispose(),this.stippleTextureRepository.release(this.stipplePattern),this.stipplePattern=null,this.stippleTextureBind=null}bindPass(e,s,r){if(T.bindProjectionMatrix(this.program,r.camera.projectionMatrix),this.stipplePattern!==s.stipplePattern){const e=s.stipplePattern;this.stippleTextureBind=this.stippleTextureRepository.swap(this.stipplePattern,e),this.stipplePattern=e}if(this.configuration.stippleEnabled){const i=t(this.stippleTextureBind)?this.stippleTextureBind(e,0)*r.camera.pixelRatio:1;this.program.setUniform1i("stipplePatternTexture",0),this.program.setUniform1f("stipplePatternPixelSizeInv",1/i),this.program.setUniform2f("ndcToPixel",r.camera.fullViewport[2]/2,r.camera.fullViewport[3]/2)}if(this.program.setUniform4fv("constantColor",s.color),this.program.setUniform1f("alphaCoverage",Math.min(1,s.width*r.camera.pixelRatio)),this.configuration.stippleOffColorEnabled){const e=i(s.stippleOffColor);this.program.setUniform4f("stippleOffColor",e[0],e[1],e[2],e.length>3?e[3]:1)}4===this.configuration.output&&C.bindOutputHighlight(e,this.program,r)}bindDraw(e){T.bindView(this.program,e),E.bindUniformsWithOrigin(this.program,this.configuration,e)}initializePipeline(){const e=this.configuration,t=z(770,1,771,771),i=(t,i=null,s=null)=>N({blending:i,depthTest:R,depthWrite:s,colorWrite:W,stencilWrite:e.sceneHasOcludees?q:null,stencilTest:e.sceneHasOcludees?t?A:B:null});return 0===e.output?(this._occludeePipelineState=i(!0,e.transparent||e.stippleEnabled?t:null,$),i(!1,e.transparent||e.stippleEnabled?t:null,$)):i(!1)}get primitiveType(){return 1}getPipelineState(e){return e?this._occludeePipelineState:this.pipeline}}ee.shader=new D(Z,(()=>Promise.resolve().then((function(){return Z}))));class te extends S{constructor(){super(...arguments),this.output=0,this.slicePlaneEnabled=!1,this.vertexColors=!1,this.transparent=!1,this.stippleEnabled=!1,this.stippleOffColorEnabled=!1,this.stippleIntegerRepeatsEnabled=!1,this.sceneHasOcludees=!1}}e([w({count:8})],te.prototype,"output",void 0),e([w()],te.prototype,"slicePlaneEnabled",void 0),e([w()],te.prototype,"vertexColors",void 0),e([w()],te.prototype,"transparent",void 0),e([w()],te.prototype,"stippleEnabled",void 0),e([w()],te.prototype,"stippleOffColorEnabled",void 0),e([w()],te.prototype,"stippleIntegerRepeatsEnabled",void 0),e([w()],te.prototype,"sceneHasOcludees",void 0);const ie=s.getLogger("esri.views.3d.webgl-engine.materials.NativeLineMaterial");class se extends U{constructor(e){super(e,ae),this.techniqueConfig=new te}getTechniqueConfig(e){this.techniqueConfig.output=e,this.techniqueConfig.slicePlaneEnabled=this.params.slicePlaneEnabled,this.techniqueConfig.vertexColors=this.params.vertexColors,this.techniqueConfig.transparent=this.params.color[3]<1||this.params.width<1;const i=t(this.params.stipplePattern);return this.techniqueConfig.stippleEnabled=i,this.techniqueConfig.stippleOffColorEnabled=i&&t(this.params.stippleOffColor),this.techniqueConfig.stippleIntegerRepeatsEnabled=i&&this.params.stippleIntegerRepeats,this.techniqueConfig.sceneHasOcludees=this.params.sceneHasOcludees,this.techniqueConfig}getPassParameters(){return this.params}intersect(e,t,i,s,r,o,a,n,l){l?_(e,s,o,1,a):this.intersectLineGeometry(e,t,i,s,a)}intersectLineGeometry(e,t,i,s,r){if(!s.options.selectionMode||Q(t))return;if(!K(i))return void ie.error("intersection assumes a translation-only matrix");const o=e.vertexAttributes.get("position").data,f=s.camera,m=ve;g(m,s.point);a(Pe[0],m[0]-2,m[1]+2,0),a(Pe[1],m[0]+2,m[1]+2,0),a(Pe[2],m[0]+2,m[1]-2,0),a(Pe[3],m[0]-2,m[1]-2,0);for(let e=0;e<4;e++)if(!f.unprojectFromRenderScreen(Pe[e],be[e]))return;G.fromPoints(f.eye,be[0],be[1],xe),G.fromPoints(f.eye,be[1],be[2],Ce),G.fromPoints(f.eye,be[2],be[3],Ee),G.fromPoints(f.eye,be[3],be[0],ye);let v=Number.MAX_VALUE;for(let e=0;e<o.length-5;e+=3){if(ne[0]=o[e]+i[12],ne[1]=o[e+1]+i[13],ne[2]=o[e+2]+i[14],le[0]=o[e+3]+i[12],le[1]=o[e+4]+i[13],le[2]=o[e+5]+i[14],G.signedDistance(xe,ne)<0&&G.signedDistance(xe,le)<0||G.signedDistance(Ce,ne)<0&&G.signedDistance(Ce,le)<0||G.signedDistance(Ee,ne)<0&&G.signedDistance(Ee,le)<0||G.signedDistance(ye,ne)<0&&G.signedDistance(ye,le)<0)continue;if(f.projectToRenderScreen(ne,ue),f.projectToRenderScreen(le,de),ue[2]<0&&de[2]>0){n(pe,ne,le);const e=f.frustum,t=-G.signedDistance(e[4],ne)/l(pe,G.normal(e[4]));p(pe,pe,t),c(ne,ne,pe),f.projectToRenderScreen(ne,ue)}else if(ue[2]>0&&de[2]<0){n(pe,le,ne);const e=f.frustum,t=-G.signedDistance(e[4],le)/l(pe,G.normal(e[4]));p(pe,pe,t),c(le,le,pe),f.projectToRenderScreen(le,de)}else if(ue[2]<0&&de[2]<0)continue;ue[2]=0,de[2]=0;const t=F.distance2(F.fromPoints(ue,de,me),m);t<v&&(v=t,u(he,ne),u(fe,le))}const P=s.rayBeginPoint,b=s.rayEndPoint;if(v<4){let e=Number.MAX_VALUE;if(F.closestLineSegmentPoint(F.fromPoints(he,fe,me),F.fromPoints(P,b,ge),ce)){n(ce,ce,P);const t=d(ce);p(ce,ce,1/t),e=t/h(P,b)}r(e,ce)}}computeAttachmentOrigin(e,t){const i=e.vertexAttributes;if(!i)return!1;const s=i.get("position");return L(s,null,!1,t)}createBufferWriter(){const e=this.params.vertexColors?X:k;return r(this.params.stipplePattern)?new J(e):new oe(e.clone().vec3f("auxpos1"))}getGLMaterial(e){return 0===e.output||4===e.output?new re(e):void 0}}class re extends H{constructor(e){super(e),this.updateParameters()}updateParameters(){this.technique=this.techniqueRep.acquireAndReleaseExisting(ee,this.material.getTechniqueConfig(this.output),this.technique)}beginSlot(e){return 3===e}_updateOccludeeState(e){e.hasOccludees!==this.material.params.sceneHasOcludees&&(this.material.setParameterValues({sceneHasOcludees:e.hasOccludees}),this.updateParameters())}ensureParameters(e){0===this.output&&this._updateOccludeeState(e)}bind(e,t){e.bindProgram(this.technique.program),this.technique.bindPass(e,this.material.getPassParameters(),t)}getPipelineState(e,t){return this.technique.getPipelineState(t)}}class oe{constructor(e){this.vertexBufferLayout=e}allocate(e){return this.vertexBufferLayout.createBuffer(e)}elementCount(e){return e.indices.get("position").length}write(e,t,i,s){M(t,this.vertexBufferLayout,e.transformation,e.invTranspTransformation,i,s),this.writeAuxpos1(e,t,i,s)}writeAuxpos1(e,t,i,s){const r=i.getField("auxpos1",m),o=t.indices.get("position"),a=t.vertexAttributes.get("position").data,n=e.transformation,l=r.typedBufferStride,p=r.typedBuffer;s*=l;for(let e=0;e<o.length;e+=2){const t=3*o[e],i=a[t],r=a[t+1],c=a[t+2],u=n[0]*i+n[4]*r+n[8]*c+n[12],d=n[1]*i+n[5]*r+n[9]*c+n[13],h=n[2]*i+n[6]*r+n[10]*c+n[14];for(let e=0;e<2;++e)p[s]=u,p[s+1]=d,p[s+2]=h,s+=l}}}const ae={color:[1,1,1,1],vertexColors:!1,slicePlaneEnabled:!1,width:1,stipplePattern:null,stippleIntegerRepeats:!1,stippleOffColor:null,sceneHasOcludees:!1,...V},ne=o(),le=o(),pe=o(),ce=o(),ue=f(),de=f(),he=o(),fe=o(),me=F.create(),ge=F.create(),ve=o(),Pe=[f(),f(),f(),f()],be=[o(),o(),o(),o()],xe=G.create(),Ce=G.create(),Ee=G.create(),ye=G.create();export{se as N};
