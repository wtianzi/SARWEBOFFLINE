/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.19/esri/copyright.txt for details.
*/
import{O as t}from"./ArrayPool.js";import{i as e,b as s,c as i}from"./Logger.js";import{a as r,f as a,c as o}from"./vec3f64.js";import{i as n,f as h,k as m,g as c,a as l}from"./vec3.js";import{h as d}from"./mathUtils.js";import{g as b}from"./uid.js";import{m as u,c as g,a as _,b as f}from"./mat4.js";import{c as p,d as y,I as v}from"./quatf64.js";import{B as M,J as A}from"./geometryUtils.js";import{s as S,a as j}from"./Util.js";class V{constructor(){this.id=b()}unload(){}}class T{constructor(){this._disposed=!1}get disposed(){return this._disposed}get shaderTransformation(){return this._shaderTransformation}acquire(t,e,s,i,r,a){this.id=b(),this.geometry=t,this.material=e,this.transformation=s,this.instanceParameters=i,this.origin=r,this._shaderTransformation=a,this._disposed=!1}release(){this._disposed=!1}dispose(){this._disposed=!0}getStaticTransformation(){return this.transformation}getShaderTransformation(){return e(this._shaderTransformation)?this._shaderTransformation(this.transformation):this.transformation}computeAttachmentOrigin(t){return!!(this.material.computeAttachmentOrigin?this.material.computeAttachmentOrigin(this.geometry,t):this.geometry.computeAttachmentOrigin(t))&&(n(t,t,this.getStaticTransformation()),!0)}}T.pool=new t(T);class x{constructor(t){this.channel=t,this.id=b()}}function B(t,e,s){for(let i=0;i<s;++i)e[2*i]=t[i],e[2*i+1]=t[i]-e[2*i]}function O(t,e,s,i){for(let r=0;r<i;++r)R[0]=t[r],B(R,L,1),e[r]=L[0],s[r]=L[1]}const R=new Float64Array(1),L=new Float32Array(2);function U(t,e){return s(t)&&(t=[]),t.push(e),t}function w(t,e){if(s(t))return t;const i=t.filter((t=>t!==e));return 0===i.length?null:i}function E(t){return!!e(t)&&!t.visible}function N(t,e){const s=new Map;return s.set(0,e.acquire(t,0)),s.set(1,e.acquire(t,7)),s.set(4,e.acquire(t,3)),s.set(3,e.acquire(t,2)),s.set(2,e.acquire(t,1)),s.set(5,e.acquire(t,4)),s.set(7,e.acquire(t,3)),s.set(6,e.acquire(t,3)),s}function G(t,e){e.release(t,0),e.release(t,7),e.release(t,3),e.release(t,2),e.release(t,1),e.release(t,4)}function W(t,s,i){const r=t.origin.vec3;S(P,-r[0],-r[1],-r[2]),e(t.transformation)?u(s,P,t.transformation):g(s,P),i&&(_(i,s),f(i,i))}function q(t,e,s,i,r){X[0]=t.get(e,0),X[1]=t.get(e,1),X[2]=t.get(e,2),B(X,C,3),s.set(r,0,C[0]),i.set(r,0,C[1]),s.set(r,1,C[2]),i.set(r,1,C[3]),s.set(r,2,C[4]),i.set(r,2,C[5])}const X=new Float64Array(3),C=new Float32Array(6),P=p();class D extends V{constructor(t={}){super(),this.type=1,this._geometryRecords=new Array,this._geometries=new Array,this._objectTransformation=p(),this._bvObjectSpace=new F,this._bvWorldSpace=new F,this._bvDirty=!0,this._hasVolatileTransformation=!1,this._visible=!0,this.castShadow=null==t.castShadow||t.castShadow,this.metadata=t.metadata,this.metadata&&this.metadata.isElevationSource&&(this.metadata.lastValidElevationBB=new I),this.transformation=p();const{geometries:e,materials:s,transformations:i,origins:r}=t;if(Array.isArray(e)){j(s.length===e.length,"Object3D: materials don't match geometries"),j(i.length===e.length,"Object3D: transformations don't match geometries"),this._geometryRecords.length=e.length,this._geometries.length=e.length;for(let t=0;t<e.length;t++)this._geometries[t]=e[t],this._geometryRecords[t]=T.pool.acquire(e[t],s[t],y(i[t]),{highlights:null,occludees:null,visible:!0},r&&r[t])}}get geometryRecords(){return this._geometryRecords}get geometries(){return this._geometries}get transformation(){return this._objectTransformation}set transformation(t){g(this._objectTransformation,t),this._invalidateBoundingVolume(),this._emit("objectTransformation",this)}dispose(){this._geometryRecords.length=0,this._geometries.length=0}get parentLayer(){return this._parentLayer}set parentLayer(t){j(null==this._parentLayer||null==t,"Object3D can only be added to a single Layer"),this._parentLayer=t}getNumGeometryRecords(){return this._geometryRecords.length}getGeometryRecord(t){return j(t>=0&&t<this._geometryRecords.length,"Object3d.getGeometryDataByIndex: index out of range"),this._geometryRecords[t]}addGeometry(t,s,i,r,a,o){i=i||v,this._geometries.push(t);const n=T.pool.acquire(t,s,i,r||{highlights:null,occludees:null,visible:!0},a,o);return this._geometryRecords.push(n),this._hasVolatileTransformation=this._hasVolatileTransformation||e(n.shaderTransformation),this._emit("objectGeometryAdded",{object:this,record:n}),this._invalidateBoundingVolume(),n}removeGeometry(t){const s=this._geometryRecords.splice(t,1)[0];return this._hasVolatileTransformation=e(s.shaderTransformation)?this._geometryRecords.some((t=>e(t.shaderTransformation))):this._hasVolatileTransformation,s.dispose(),this._geometries.splice(t,1),this._emit("objectGeometryRemoved",{object:this,record:s}),this._invalidateBoundingVolume(),s}removeAllGeometries(){for(;this.getNumGeometryRecords()>0;)this.removeGeometry(0)}geometryVertexAttrsUpdated(t){this._emit("vertexAttrsUpdated",{object:this,record:this._geometryRecords[t]}),this._invalidateBoundingVolume()}get isVisible(){return this._visible}setVisible(t){this._visible=t;for(const t of this._geometryRecords)t.instanceParameters.visible=this._visible;this._emit("visibilityChanged",this)}maskOccludee(){const t=new x(1);for(const e of this._geometryRecords)e.instanceParameters.occludees=U(e.instanceParameters.occludees,t);return this._emit("occlusionChanged",this),t}removeOcclude(t){for(const e of this._geometryRecords)e.instanceParameters.occludees=w(e.instanceParameters.occludees,t);this._emit("occlusionChanged",this)}highlight(){const t=new x(0);for(const e of this._geometryRecords)e.instanceParameters.highlights=U(e.instanceParameters.highlights,t);return this._emit("highlightChanged",this),t}removeHighlight(t){for(const e of this._geometryRecords)e.instanceParameters.highlights=w(e.instanceParameters.highlights,t);this._emit("highlightChanged",this)}getCombinedStaticTransformation(t,e){return u(i(e,p()),this.transformation,t.getStaticTransformation())}getCombinedShaderTransformation(t,e){return e=e||p(),u(e,this.transformation,t.getShaderTransformation()),e}hasVolativeTransformation(){return this._hasVolatileTransformation}getBBMin(t){return this._validateBoundingVolume(),t?this._bvObjectSpace.bbMin:this._bvWorldSpace.bbMin}getBBMax(t){return this._validateBoundingVolume(),t?this._bvObjectSpace.bbMax:this._bvWorldSpace.bbMax}getBounds(t){return this._validateBoundingVolume(),t?this._bvObjectSpace.bounds:this._bvWorldSpace.bounds}_validateBoundingVolume(){if(!this._bvDirty&&!this._hasVolatileTransformation)return;this._bvObjectSpace.init(),this._bvWorldSpace.init();for(let t=0;t<this._geometryRecords.length;++t){const s=this._geometries[t],i=this._geometryRecords[t],r=s.boundingInfo;e(r)&&(this._calculateTransformedBoundingVolume(r,this._bvObjectSpace,i.getShaderTransformation()),this._calculateTransformedBoundingVolume(r,this._bvWorldSpace,this.getCombinedShaderTransformation(i)))}h(this._bvObjectSpace.bounds,this._bvObjectSpace.bbMin,this._bvObjectSpace.bbMax,.5),h(this._bvWorldSpace.bounds,this._bvWorldSpace.bbMin,this._bvWorldSpace.bbMax,.5);const t=o(),i=o(),r=d(this.transformation);for(let e=0;e<this._geometryRecords.length;++e){const a=this._geometries[e].boundingInfo;if(s(a))continue;const o=this._geometryRecords[e].getShaderTransformation(),h=d(o);n(t,a.getCenter(),o);const c=m(t,this._bvObjectSpace.bounds),l=a.getBSRadius()*h;this._bvObjectSpace.bounds[3]=Math.max(this._bvObjectSpace.bounds[3],c+l),n(i,t,this.transformation);const b=m(i,this._bvWorldSpace.bounds),u=l*r;this._bvWorldSpace.bounds[3]=Math.max(this._bvWorldSpace.bounds[3],b+u)}this._bvDirty=!1}_calculateTransformedBoundingVolume(t,e,s){const i=t.getBBMin(),a=t.getBBMax(),o=r(i),h=r(a);n(o,o,s),n(h,h,s);for(let t=0;t<3;++t)e.bbMin[t]=Math.min(e.bbMin[t],o[t],h[t]),e.bbMax[t]=Math.max(e.bbMax[t],o[t],h[t]);for(let t=0;t<3;++t){c(o,i),c(h,a),o[t]=a[t],h[t]=i[t],n(o,o,s),n(h,h,s);for(let t=0;t<3;++t)e.bbMin[t]=Math.min(e.bbMin[t],o[t],h[t]),e.bbMax[t]=Math.max(e.bbMax[t],o[t],h[t])}}_invalidateBoundingVolume(){this._bvDirty=!0,e(this._parentLayer)&&this._parentLayer.notifyObjectBBChanged(this,this._bvWorldSpace.bounds)}_emit(t,s){e(this._parentLayer)&&this._parentLayer.events.emit(t,s)}get test(){const t=this;return{hasGeometry:e=>t._geometries.indexOf(e)>-1,getGeometryIndex:e=>t._geometries.indexOf(e)}}}class I{constructor(){this.bbMin=a(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),this.bbMax=a(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE)}isEmpty(){return this.bbMax[0]<this.bbMin[0]&&this.bbMax[1]<this.bbMin[1]&&this.bbMax[2]<this.bbMin[2]}}class F extends I{constructor(){super(...arguments),this.bounds=M()}init(){l(this.bbMin,Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),l(this.bbMax,-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE),A(this.bounds)}}export{V as C,T as G,D as O,x as a,N as b,W as c,B as d,q as e,O as f,U as g,w as h,E as i,G as r};
