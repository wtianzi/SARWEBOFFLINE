/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.19/esri/copyright.txt for details.
*/
import{id as t}from"../kernel.js";import{b as r,i as e}from"./Logger.js";import{throwIfAbortError as a}from"../core/promiseUtils.js";import s from"../request.js";import i from"../portal/Portal.js";import n from"../portal/PortalItem.js";import o from"../layers/FeatureLayer.js";class l{constructor(t,r,e){this.parsedUrl=t,this.portalItem=r,this.signal=e,this.rootDocument=null;const a=this.parsedUrl.path.match(/^(.*)\/SceneServer\/layers\/([\d]*)\/?$/i);a&&(this.urlParts={root:a[1],layerId:parseInt(a[2],10)})}async fetch(){var t;if(!this.urlParts)return null;const e=null!=(t=this.portalItem)?t:await this.portalItemFromServiceItemId();if(r(e))return this.loadFromUrl();const a=await this.findAndLoadRelatedPortalItem(e);return r(a)?null:this.loadFeatureLayerFromPortalItem(a)}async fetchPortalItem(){var t;if(!this.urlParts)return null;const e=null!=(t=this.portalItem)?t:await this.portalItemFromServiceItemId();return r(e)?null:this.findAndLoadRelatedPortalItem(e)}async fetchRootDocument(){if(e(this.rootDocument))return this.rootDocument;if(r(this.urlParts))return this.rootDocument={},{};const t={query:{f:"json"},responseType:"json",signal:this.signal},a=`${this.urlParts.root}/SceneServer`;try{const r=await s(a,t);this.rootDocument=r.data}catch{this.rootDocument={}}return this.rootDocument}async fetchServiceOwningPortalUrl(){var r;const e=null==(r=t)?void 0:r.findServerInfo(this.parsedUrl.path);if(null!=e&&e.owningSystemUrl)return e.owningSystemUrl;const i=this.parsedUrl.path.replace(/(.*\/rest)\/.*/i,"$1")+"/info";try{const t=(await s(i,{query:{f:"json"},responseType:"json",signal:this.signal})).data.owningSystemUrl;if(t)return t}catch(t){a(t)}return null}async findAndLoadRelatedPortalItem(t){try{return(await t.fetchRelatedItems({relationshipType:"Service2Service",direction:"reverse"},{signal:this.signal})).find((t=>"Feature Service"===t.type))||null}catch(t){return a(t),null}}async loadFeatureLayerFromPortalItem(t){await t.load({signal:this.signal});const r=await this.findMatchingAssociatedSublayerUrl(t.url);return new o({url:r,portalItem:t}).load({signal:this.signal})}async loadFromUrl(){const t=await this.findMatchingAssociatedSublayerUrl(`${this.urlParts.root}/FeatureServer`);return new o({url:t}).load({signal:this.signal})}async findMatchingAssociatedSublayerUrl(t){const r=t.replace(/^(.*FeatureServer)(\/[\d]*\/?)?$/i,"$1"),e={query:{f:"json"},responseType:"json",authMode:"no-prompt",signal:this.signal},a=this.urlParts.layerId,i=this.fetchRootDocument(),n=s(r,e),[o,l]=await Promise.all([n,i]),c=l&&l.layers,u=o.data&&o.data.layers;if(!Array.isArray(u))throw new Error("expected layers array");if(Array.isArray(c))for(let t=0;t<Math.min(c.length,u.length);t++){if(c[t].id===a)return`${r}/${u[t].id}`}else if(a<u.length)return`${r}/${u[a].id}`;throw new Error("could not find matching associated sublayer")}async portalItemFromServiceItemId(){const t=(await this.fetchRootDocument()).serviceItemId;if(!t)return null;const r=new n({id:t}),s=await this.fetchServiceOwningPortalUrl();e(s)&&(r.portal=new i({url:s}));try{return r.load({signal:this.signal})}catch(t){return a(t),null}}}export{l as F};
