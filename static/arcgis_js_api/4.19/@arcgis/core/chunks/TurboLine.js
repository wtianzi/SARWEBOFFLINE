/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.19/esri/copyright.txt for details.
*/
function t(t,e,r){return t[0]=e[0]-r[0],t[1]=e[1]-r[1],t}function e(t,e){return Math.sqrt(t*t+e*e)}function r(t){const r=e(t[0],t[1]);t[0]/=r,t[1]/=r}function i(t,r){return e(t[0]-r[0],t[1]-r[1])}function n(t){return"function"==typeof t}function o(t){return 1/Math.max(t,1)}function x(t,e,r){l.trackDistance=null!=e.trackDistance&&e.trackDistance,l.wrapDistance=null!=e.wrapDistance?e.wrapDistance:65535,l.thin=null!=e.thin&&e.thin,l.initialDistance=null!=e.initialDistance?e.initialDistance:0,l.enableOuterBisectorSplit=null!=e.enableOuterBisectorSplit&&e.enableOuterBisectorSplit,l.outerBisectorAutoSplitThreshold=null!=e.outerBisectorAutoSplitThreshold?e.outerBisectorAutoSplitThreshold:0,l.enableInnerBisectorSplit=null!=e.enableOuterBisectorSplit&&e.enableOuterBisectorSplit,l.innerBisectorAutoSplitThreshold=null!=e.innerBisectorAutoSplitThreshold?e.innerBisectorAutoSplitThreshold:0,c=t,y=r,a=0,d=0,h=0,b=!1,g=null,V=null,p.currentVertex.x=null,p.currentVertex.y=null,p.distance=l.initialDistance;const i=c[0],n=c[c.length-1];p.canSplit=!1,p.closed=i.x===n.x&&i.y===n.y,c.length<2||2===c.length&&p.closed||(l.thin?l.trackDistance?function(){f(),E(),N(1);for(;d-h>l.wrapDistance||a<c.length;)f(),E(),N(2),y.bridge(p),p.leftExit0=p.rightExit0,p.leftExit2=p.rightExit2}():function(){for(;a<c.length;){if(a>0&&(p.inbound.x=p.outbound.x,p.inbound.y=p.outbound.y),a<c.length-1){p.outbound.x=c[a+1].x-c[a].x,p.outbound.y=c[a+1].y-c[a].y;const t=Math.sqrt(p.outbound.x*p.outbound.x+p.outbound.y*p.outbound.y);p.distance+=t,p.outbound.x/=t,p.outbound.y/=t}else p.outbound.x=p.inbound.x,p.outbound.y=p.inbound.y;0===a&&(p.inbound.x=p.outbound.x,p.inbound.y=p.outbound.y),p.currentVertex.x=c[a].x,p.currentVertex.y=c[a].y,p.prevNormal.x=-p.inbound.y,p.prevNormal.y=p.inbound.x,p.nextNormal.x=-p.outbound.y,p.nextNormal.y=p.outbound.x,0===a?(y.vertex(p),p.leftEntry0=p.entry0,p.leftEntry2=p.entry2,p.leftExit0=p.exit0,p.leftExit2=p.exit2):(y.vertex(p),p.rightEntry0=p.entry0,p.rightEntry2=p.entry2,p.rightExit0=p.exit0,p.rightExit2=p.exit2,y.bridge(p),p.leftExit0=p.rightExit0,p.leftExit2=p.rightExit2),++a}}():l.enableOuterBisectorSplit||l.outerBisectorAutoSplitThreshold>0||l.enableInnerBisectorSplit||l.innerBisectorAutoSplitThreshold>0?(p.canSplit=!0,function(){f(),m(),p.splitInner=p.gapInner=p.splitOuter=p.gapOuter=!1,v(1),p.closure0=p.leftEntry0,p.closure1=p.leftEntry1,p.closure2=p.leftEntry2;for(;d-h>l.wrapDistance||a<c.length-1||a<c.length&&(!p.closed||l.trackDistance);)f(),m(),p.splitInner=p.gapInner=p.splitOuter=p.gapOuter=!1,v(2),y.bridge(p),p.leftExit0=p.rightExit0,p.leftExit1=p.rightExit1,p.leftExit2=p.rightExit2;p.closed&&!l.trackDistance&&(p.rightEntry0=p.closure0,p.rightEntry1=p.closure1,p.rightEntry2=p.closure2,y.bridge(p),p.leftExit0=p.rightExit0,p.leftExit1=p.rightExit1,p.leftExit2=p.rightExit2)}()):function(){f(),m(),v(1),p.closure0=p.leftEntry0,p.closure1=p.leftEntry1,p.closure2=p.leftEntry2;for(;d-h>l.wrapDistance||a<c.length-1||a<c.length&&(!p.closed||l.trackDistance);)f(),m(),v(2),y.bridge(p),p.leftExit0=p.rightExit0,p.leftExit1=p.rightExit1,p.leftExit2=p.rightExit2;p.closed&&!l.trackDistance&&(p.rightEntry0=p.closure0,p.rightEntry1=p.closure1,p.rightEntry2=p.closure2,y.bridge(p),p.leftExit0=p.rightExit0,p.leftExit1=p.rightExit1,p.leftExit2=p.rightExit2)}())}function s(){c=null,y=null}function u(){if(p.cosine<l.innerBisectorAutoSplitThreshold){p.splitInner=!0,p.gapInner=!0;const t=Math.max(l.innerBisectorAutoSplitThreshold,p.cosine),e=Math.sqrt(1-t*t)/t;p.leftInner.x=p.nextNormal.x+p.sign*e*p.outbound.x,p.leftInner.y=p.nextNormal.y+p.sign*e*p.outbound.y,p.rightInner.x=p.prevNormal.x-p.sign*e*p.inbound.x,p.rightInner.y=p.prevNormal.y-p.sign*e*p.inbound.y}else l.enableInnerBisectorSplit&&(p.splitInner=!0,p.gapInner=!1,p.leftInner.x=p.rightInner.x=p.bisector.x/p.cosine,p.leftInner.y=p.rightInner.y=p.bisector.y/p.cosine);if(p.cosine<l.outerBisectorAutoSplitThreshold){p.splitOuter=!0,p.gapOuter=!0;const t=Math.max(l.outerBisectorAutoSplitThreshold,p.cosine),e=Math.sqrt(1-t*t)/t;p.leftOuter.x=p.prevNormal.x-p.sign*e*p.inbound.x,p.leftOuter.y=p.prevNormal.y-p.sign*e*p.inbound.y,p.rightOuter.x=p.nextNormal.x+p.sign*e*p.outbound.x,p.rightOuter.y=p.nextNormal.y+p.sign*e*p.outbound.y}else l.enableOuterBisectorSplit&&(p.splitOuter=!0,p.gapOuter=!1,p.leftOuter.x=p.rightOuter.x=p.bisector.x/p.cosine,p.leftOuter.y=p.rightOuter.y=p.bisector.y/p.cosine)}let c;const l={};let y,a,d,h,b,g,V;const p=new class{constructor(){this.closed=void 0,this.isFirstVertex=void 0,this.isLastVertex=void 0,this.isCap=void 0,this.currentVertex={x:void 0,y:void 0},this.inbound={x:void 0,y:void 0},this.outbound={x:void 0,y:void 0},this.prevNormal={x:void 0,y:void 0},this.nextNormal={x:void 0,y:void 0},this.bisector={x:void 0,y:void 0},this.leftInner={x:void 0,y:void 0},this.rightInner={x:void 0,y:void 0},this.leftOuter={x:void 0,y:void 0},this.rightOuter={x:void 0,y:void 0}}};function f(){if(b)return p.distance=0,p.isCap=p.isFirstVertex=p.isLastVertex=!1,void(b=!1);if(0===d)if(p.isFirstVertex=0===a,V=c[a],0===a){if(d=0,p.closed){p.inbound.x=V.x-c[c.length-2].x,p.inbound.y=V.y-c[c.length-2].y;const t=Math.sqrt(p.inbound.x*p.inbound.x+p.inbound.y*p.inbound.y);p.inbound.x/=t,p.inbound.y/=t}}else p.inbound.x=V.x-g.x,p.inbound.y=V.y-g.y,d=Math.sqrt(p.inbound.x*p.inbound.x+p.inbound.y*p.inbound.y),p.inbound.x/=d,p.inbound.y/=d;if(p.distance+d-h<=l.wrapDistance){if(a<c.length-1){p.outbound.x=c[a+1].x-V.x,p.outbound.y=c[a+1].y-V.y;const t=Math.sqrt(p.outbound.x*p.outbound.x+p.outbound.y*p.outbound.y);p.outbound.x/=t,p.outbound.y/=t}else if(p.closed){p.outbound.x=c[1].x-V.x,p.outbound.y=c[1].y-V.y;const t=Math.sqrt(p.outbound.x*p.outbound.x+p.outbound.y*p.outbound.y);p.outbound.x/=t,p.outbound.y/=t}else p.outbound.x=p.inbound.x,p.outbound.y=p.inbound.y;return 0!==a||p.closed||(p.inbound.x=p.outbound.x,p.inbound.y=p.outbound.y),++a,p.isLastVertex=a===c.length,p.isCap=!p.closed&&(p.isFirstVertex||p.isLastVertex),p.distance+=d-h,d=0,h=0,b=p.distance+d-h===l.wrapDistance,p.currentVertex.x=V.x,p.currentVertex.y=V.y,g=V,void(V=null)}p.outbound.x=p.inbound.x,p.outbound.y=p.inbound.y,h+=l.wrapDistance-p.distance,p.distance=l.wrapDistance,b=!0;const t=h/d;p.currentVertex.x=(1-t)*g.x+t*V.x,p.currentVertex.y=(1-t)*g.y+t*V.y}function E(){p.prevNormal.x=-p.inbound.y,p.prevNormal.y=p.inbound.x,p.nextNormal.x=-p.outbound.y,p.nextNormal.y=p.outbound.x}function m(){E(),p.bisector.x=p.prevNormal.x+p.nextNormal.x,p.bisector.y=p.prevNormal.y+p.nextNormal.y;const t=Math.sqrt(p.bisector.x*p.bisector.x+p.bisector.y*p.bisector.y);if(t<.001)return p.bisector.x=void 0,p.bisector.y=void 0,p.cosine=0,void(p.sign=void 0);p.bisector.x/=t,p.bisector.y/=t,p.cosine=p.bisector.x*p.nextNormal.x+p.bisector.y*p.nextNormal.y,p.sign=p.prevNormal.x*p.nextNormal.y-p.prevNormal.y*p.nextNormal.x>=0?1:-1}function v(t){y.vertex(p),1===t?(p.leftEntry0=p.entry0,p.leftEntry1=p.entry1,p.leftEntry2=p.entry2,p.leftExit0=p.exit0,p.leftExit1=p.exit1,p.leftExit2=p.exit2):2===t&&(p.rightEntry0=p.entry0,p.rightEntry1=p.entry1,p.rightEntry2=p.entry2,p.rightExit0=p.exit0,p.rightExit1=p.exit1,p.rightExit2=p.exit2)}function N(t){y.vertex(p),1===t?(p.leftEntry0=p.entry0,p.leftEntry2=p.entry2,p.leftExit0=p.exit0,p.leftExit2=p.exit2):2===t&&(p.rightEntry0=p.entry0,p.rightEntry2=p.entry2,p.rightExit0=p.exit0,p.rightExit2=p.exit2)}class w{constructor(t,e){this.writeVertex=t,this.writeTriangle=e,this.capType=0,this.joinType=2,this.miterLimitCosine=o(2),this.roundLimitCosine=Math.cos(23*Math.PI/180),this.almostParallelCosine=.97,this.radsPerSlice=.8,this.textured=!1,this.joinOnUTurn=!1}vertex(t){const e=2===this.joinType?this.miterLimitCosine:this.roundLimitCosine,r=t.isCap&&0!==this.capType;let i=!1;t.cosine>this.almostParallelCosine?(t.exit0=t.entry0=this.writeVertex(t.currentVertex.x,t.currentVertex.y,0,0,t.bisector.x/t.cosine,t.bisector.y/t.cosine,0,-1,t.distance),t.exit2=t.entry2=this.writeVertex(t.currentVertex.x,t.currentVertex.y,0,0,-t.bisector.x/t.cosine,-t.bisector.y/t.cosine,0,1,t.distance)):t.cosine<1-this.almostParallelCosine?(i=!t.isCap&&this.joinOnUTurn,t.entry0=this.writeVertex(t.currentVertex.x,t.currentVertex.y,0,0,t.prevNormal.x,t.prevNormal.y,0,-1,t.distance),t.entry2=this.writeVertex(t.currentVertex.x,t.currentVertex.y,0,0,-t.prevNormal.x,-t.prevNormal.y,0,1,t.distance),t.exit0=this.writeVertex(t.currentVertex.x,t.currentVertex.y,0,0,t.nextNormal.x,t.nextNormal.y,0,-1,t.distance),t.exit2=this.writeVertex(t.currentVertex.x,t.currentVertex.y,0,0,-t.nextNormal.x,-t.nextNormal.y,0,1,t.distance)):t.canSplit?(u(),t.sign>0?(t.splitInner?(t.exit0=this.writeVertex(t.currentVertex.x,t.currentVertex.y,t.outbound.x,t.outbound.y,t.leftInner.x,t.leftInner.y,0,-1,t.distance),t.entry0=this.writeVertex(t.currentVertex.x,t.currentVertex.y,t.inbound.x,t.inbound.y,t.rightInner.x,t.rightInner.y,0,-1,t.distance)):t.exit0=t.entry0=this.writeVertex(t.currentVertex.x,t.currentVertex.y,t.inbound.x,t.inbound.y,t.bisector.x/t.cosine,t.bisector.y/t.cosine,0,-1,t.distance),t.cosine<e?(i=!t.isCap,t.entry2=this.writeVertex(t.currentVertex.x,t.currentVertex.y,0,0,-t.prevNormal.x,-t.prevNormal.y,0,1,t.distance),t.exit2=this.writeVertex(t.currentVertex.x,t.currentVertex.y,0,0,-t.nextNormal.x,-t.nextNormal.y,0,1,t.distance)):t.splitOuter?(i=i||t.gapOuter,t.entry2=this.writeVertex(t.currentVertex.x,t.currentVertex.y,t.inbound.x,t.inbound.y,-t.leftOuter.x,-t.leftOuter.y,0,1,t.distance),t.exit2=this.writeVertex(t.currentVertex.x,t.currentVertex.y,t.outbound.x,t.outbound.y,-t.rightOuter.x,-t.rightOuter.y,0,1,t.distance)):t.entry2=t.exit2=this.writeVertex(t.currentVertex.x,t.currentVertex.y,0,0,-t.bisector.x/t.cosine,-t.bisector.y/t.cosine,0,1,t.distance)):(t.splitInner?(t.exit2=this.writeVertex(t.currentVertex.x,t.currentVertex.y,t.outbound.x,t.outbound.y,-t.leftInner.x,-t.leftInner.y,0,1,t.distance),t.entry2=this.writeVertex(t.currentVertex.x,t.currentVertex.y,t.inbound.x,t.inbound.y,-t.rightInner.x,-t.rightInner.y,0,1,t.distance)):t.exit2=t.entry2=this.writeVertex(t.currentVertex.x,t.currentVertex.y,0,0,-t.bisector.x/t.cosine,-t.bisector.y/t.cosine,0,1,t.distance),t.cosine<e?(i=!t.isCap,t.entry0=this.writeVertex(t.currentVertex.x,t.currentVertex.y,0,0,t.prevNormal.x,t.prevNormal.y,0,-1,t.distance),t.exit0=this.writeVertex(t.currentVertex.x,t.currentVertex.y,0,0,t.nextNormal.x,t.nextNormal.y,0,-1,t.distance)):t.splitOuter?(i=i||t.gapOuter,t.entry0=this.writeVertex(t.currentVertex.x,t.currentVertex.y,t.inbound.x,t.inbound.y,t.leftOuter.x,t.leftOuter.y,0,-1,t.distance),t.exit0=this.writeVertex(t.currentVertex.x,t.currentVertex.y,t.outbound.x,t.outbound.y,t.rightOuter.x,t.rightOuter.y,0,-1,t.distance)):t.exit0=t.entry0=this.writeVertex(t.currentVertex.x,t.currentVertex.y,0,0,t.bisector.x/t.cosine,t.bisector.y/t.cosine,0,-1,t.distance))):t.sign>0?(t.exit0=t.entry0=this.writeVertex(t.currentVertex.x,t.currentVertex.y,t.inbound.x,t.inbound.y,t.bisector.x/t.cosine,t.bisector.y/t.cosine,0,-1,t.distance),t.cosine<e?(i=!t.isCap,t.entry2=this.writeVertex(t.currentVertex.x,t.currentVertex.y,0,0,-t.prevNormal.x,-t.prevNormal.y,0,1,t.distance),t.exit2=this.writeVertex(t.currentVertex.x,t.currentVertex.y,0,0,-t.nextNormal.x,-t.nextNormal.y,0,1,t.distance)):t.entry2=t.exit2=this.writeVertex(t.currentVertex.x,t.currentVertex.y,0,0,-t.bisector.x/t.cosine,-t.bisector.y/t.cosine,0,1,t.distance)):(t.exit2=t.entry2=this.writeVertex(t.currentVertex.x,t.currentVertex.y,0,0,-t.bisector.x/t.cosine,-t.bisector.y/t.cosine,0,1,t.distance),t.cosine<e?(i=!t.isCap,t.entry0=this.writeVertex(t.currentVertex.x,t.currentVertex.y,0,0,t.prevNormal.x,t.prevNormal.y,0,-1,t.distance),t.exit0=this.writeVertex(t.currentVertex.x,t.currentVertex.y,0,0,t.nextNormal.x,t.nextNormal.y,0,-1,t.distance)):t.exit0=t.entry0=this.writeVertex(t.currentVertex.x,t.currentVertex.y,0,0,t.bisector.x/t.cosine,t.bisector.y/t.cosine,0,-1,t.distance));const n=t.canSplit&&(t.splitInner||t.splitOuter);let o;if(o=t.entry1=t.exit1=n||i||r?this.writeVertex(t.currentVertex.x,t.currentVertex.y,0,0,0,0,0,0,t.distance):null,i&&1!==this.joinType)this.writeTriangle(o,t.sign>0?t.exit2:t.entry0,t.sign>0?t.entry2:t.exit0);else if(r&&1===this.capType||i&&1===this.joinType){let e,r,i,n,x,s;if(t.isCap){const o=Math.PI;x=Math.ceil(o/this.radsPerSlice),s=o/x,t.isFirstVertex?(e=t.prevNormal.x,r=t.prevNormal.y,i=t.entry0,n=t.entry2):t.isLastVertex&&(e=-t.nextNormal.x,r=-t.nextNormal.y,i=t.exit2,n=t.exit0)}else{const o=2*Math.acos(t.cosine);x=Math.ceil(o/this.radsPerSlice),s=o/x,e=t.sign>0?-t.prevNormal.x:t.nextNormal.x,r=t.sign>0?-t.prevNormal.y:t.nextNormal.y,i=t.sign>0?t.entry2:t.exit0,n=t.sign>0?t.exit2:t.entry0}const u=Math.cos(s),c=Math.sin(s),l=c*e+u*r;let y,a;e=u*e-c*r,r=l;for(let s=0;s<x;++s){if(y=a,s<x-1)if(t.isCap){const i=t.isFirstVertex?-1:1;a=this.writeVertex(t.currentVertex.x,t.currentVertex.y,0,0,e,r,i,0,t.distance)}else a=this.writeVertex(t.currentVertex.x,t.currentVertex.y,0,0,e,r,0,t.sign,t.distance);this.writeTriangle(0===s?i:y,o,s===x-1?n:a);const l=c*e+u*r;e=u*e-c*r,r=l}}else if(r&&2===this.capType){const e=t.isFirstVertex?1:-1;let r,i;this.textured?(r=this.writeVertex(t.currentVertex.x,t.currentVertex.y,0,0,t.prevNormal.x-e*t.inbound.x,t.prevNormal.y-e*t.inbound.y,-e,-1,t.distance),i=this.writeVertex(t.currentVertex.x,t.currentVertex.y,0,0,-t.prevNormal.x-e*t.inbound.x,-t.prevNormal.y-e*t.inbound.y,-e,1,t.distance)):(r=this.writeVertex(t.currentVertex.x,t.currentVertex.y,0,0,t.prevNormal.x-e*t.inbound.x,t.prevNormal.y-e*t.inbound.y,0,-1,t.distance),i=this.writeVertex(t.currentVertex.x,t.currentVertex.y,0,0,-t.prevNormal.x-e*t.inbound.x,-t.prevNormal.y-e*t.inbound.y,0,1,t.distance)),e>0?(this.writeTriangle(o,t.entry2,i),this.writeTriangle(o,i,r),this.writeTriangle(o,r,t.entry0)):(this.writeTriangle(o,i,t.exit2),this.writeTriangle(o,r,i),this.writeTriangle(o,t.exit0,r))}}bridge(t){this.writeTriangle(t.leftExit0,t.rightEntry0,null!=t.leftExit1?t.leftExit1:t.leftExit2),this.writeTriangle(t.rightEntry0,null!=t.rightEntry1?t.rightEntry1:t.rightEntry2,null!=t.leftExit1?t.leftExit1:t.leftExit2),null!=t.leftExit1&&null!=t.rightEntry1?(this.writeTriangle(t.leftExit1,t.rightEntry1,t.leftExit2),this.writeTriangle(t.rightEntry1,t.rightEntry2,t.leftExit2)):null!=t.leftExit1?this.writeTriangle(t.leftExit1,t.rightEntry2,t.leftExit2):null!=t.rightEntry1&&this.writeTriangle(t.rightEntry1,t.rightEntry2,t.leftExit2)}}export{w as S,t as a,s as c,i as d,o as g,n as i,r as n,u as s,x as t};
