/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.19/esri/copyright.txt for details.
*/
import{_ as t}from"./tslib.es6.js";import"../core/lang.js";import"./Logger.js";import{property as e}from"../core/accessorSupport/decorators/property.js";import o from"../core/Accessor.js";import{debounce as i}from"../core/promiseUtils.js";import"./ensureType.js";import{subclass as r}from"../core/accessorSupport/decorators/subclass.js";import"../core/urlUtils.js";import"./resourceExtension.js";import{g as s}from"../geometry/SpatialReference.js";import a from"../geometry/Extent.js";import{c as n}from"./aaBoundingRect.js";import p from"../layers/support/TileInfo.js";import{T as m}from"./TileKey.js";import{T as h}from"./TileInfoView.js";import{B as l}from"./Bitmap.js";const c=Math.PI/180;function d(t,e){const o=e.rotation*c;const i=Math.abs(Math.cos(o)),r=Math.abs(Math.sin(o)),[s,a]=e.size;return t[0]=Math.round(a*r+s*i),t[1]=Math.round(a*i+s*r),t}const u=n(),g=[0,0],f=new m(0,0,0,0),x=2048,y=2048,M=!1,v=!1,j=!1;let _=class extends o{constructor(t){super(t),this._imagePromise=null,this.hidpi=j,this.imageMaxWidth=x,this.imageMaxHeight=y,this.imageRotationSupported=M,this.imageNormalizationSupported=v,this.update=i((async(t,e)=>{const o=t.state,i=s(o.spatialReference),r=this.hidpi?t.pixelRatio:1;if(!t.stationary||this.destroyed)return null;this.imageRotationSupported?(g[0]=o.size[0],g[1]=o.size[1]):d(g,o);const a=Math.floor(g[0]*r)>this.imageMaxWidth||Math.floor(g[1]*r)>this.imageMaxHeight,n=i&&(o.extent.xmin<i.valid[0]||o.extent.xmax>i.valid[1]),p=!this.imageNormalizationSupported&&n,m=!a&&!p,h=this.imageRotationSupported?o.rotation:0;if(m)this._imagePromise=this._singleExport(o,g,h,r,e);else{let t=Math.min(this.imageMaxWidth,this.imageMaxHeight);p&&(t=Math.min(o.worldScreenWidth,t)),this._imagePromise=this._tiledExport(o,t,h,r,e)}return this._imagePromise.then((async t=>{if(this._imagePromise=null,!this.destroyed){for(const e of this.container.children)t.includes(e)||e.fadeOut().then((()=>{e.remove()}));for(const e of t)this.container.addChild(e),e.fadeIn()}})).catch((t=>{throw this._imagePromise=null,t}))}),5e3)}destroy(){}get updating(){return null!==this._imagePromise}updateExports(t){for(const e of this.container.children){if(!e.visible||!e.stage)return;t(e)?console.error("ExportStrategy.updateExports doesn't support promise yet"):(e.invalidateTexture(),e.requestRender())}}_export(t,e,o,i,r,s){return Promise.resolve().then((()=>this.fetchSource(t,Math.floor(e*r),Math.floor(o*r),{rotation:i,pixelRatio:r,signal:s}))).then((o=>{const s=new l(o,"additive");return s.x=t.xmin,s.y=t.ymax,s.resolution=t.width/e,s.rotation=i,s.pixelRatio=r,s}))}_singleExport(t,e,o,i,r){!function(t,e,o,i){const[r,s]=e,[a,n]=i,p=.5*o;t[0]=r-p*a,t[1]=s-p*n,t[2]=r+p*a,t[3]=s+p*n}(u,t.center,t.resolution,e);const s=new a(u[0],u[1],u[2],u[3],t.spatialReference);return this._export(s,e[0],e[1],o,i,r).then((t=>[t]))}_tiledExport(t,e,o,i,r){const s=p.create({size:e,spatialReference:t.spatialReference,scales:[t.scale]}),n=new h(s),m=n.getTileCoverage(t);if(!m)return null;const l=[];return m.forEach(((s,p,m,h)=>{f.set(s,p,m,h),n.getTileBounds(u,f);const c=new a(u[0],u[1],u[2],u[3],t.spatialReference);l.push(this._export(c,e,e,o,i,r))})),Promise.all(l)}};t([e()],_.prototype,"_imagePromise",void 0),t([e()],_.prototype,"container",void 0),t([e()],_.prototype,"fetchSource",void 0),t([e()],_.prototype,"hidpi",void 0),t([e()],_.prototype,"imageMaxWidth",void 0),t([e()],_.prototype,"imageMaxHeight",void 0),t([e()],_.prototype,"imageRotationSupported",void 0),t([e()],_.prototype,"imageNormalizationSupported",void 0),t([e()],_.prototype,"requestUpdate",void 0),t([e()],_.prototype,"updating",null),_=t([r("esri.views.2d.layers.support.ExportStrategy")],_);var R=_;export{R as E};
