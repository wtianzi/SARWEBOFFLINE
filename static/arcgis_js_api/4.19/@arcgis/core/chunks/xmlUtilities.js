/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.19/esri/copyright.txt for details.
*/
import{_ as e}from"./tslib.es6.js";import"../core/lang.js";import{L as t,i,u as r}from"./Logger.js";import{property as n}from"../core/accessorSupport/decorators/property.js";import{createAbortController as o,onAbort as s}from"../core/promiseUtils.js";import a from"../core/Error.js";import"./ensureType.js";import{subclass as l}from"../core/accessorSupport/decorators/subclass.js";import{a as c}from"./JSONSupport.js";import{a as u}from"./Promise.js";import"../core/urlUtils.js";import{aliasOf as m}from"../core/accessorSupport/decorators/aliasOf.js";import"./resourceExtension.js";import d,{g as h}from"../geometry/SpatialReference.js";import f from"../request.js";import p from"../geometry/Point.js";import y from"../geometry/Extent.js";import"../geometry.js";import{rasterRendererTypes as g}from"../rasterRenderers.js";import{a as x}from"./arcgisLayerUrl.js";import{u as b}from"./commonProperties2.js";import I from"../layers/support/TileInfo.js";import v from"../layers/support/DimensionalDefinition.js";import{n as w,b as R,a as k,c as _,R as C}from"./rasterRendererHelper.js";import{R as S,d as H}from"./RasterSymbolizer.js";import{m as J,j as M}from"./pixelUtils.js";import{g as D,a as P,p as j,d as B,b as T}from"./RawBlockCache.js";import{l as N,p as O,s as z,a as F,b as L,g as E}from"./rasterProjectionHelper.js";const U=t.getLogger("esri.layers.mixins.ImageryTileMixin"),W=t=>{let r=class extends t{constructor(){super(...arguments),this._rasterJobHandler={instance:null,refCount:0,connectionPromise:null},this.bandIds=null,this.copyright=null,this.fullExtent=null,this.interpolation="nearest",this.raster=null,this.rasterInfo=null,this.sourceJSON=null,this.spatialReference=null,this.tileInfo=null,this.symbolizer=null}set multidimensionalDefinition(e){this.raster&&(this._sliceId=this.raster.getSliceIndex(e)),this._set("multidimensionalDefinition",e)}set url(e){this._set("url",x(e,U))}set renderer(e){this._set("renderer",e),this.updateRenderer()}async updateRenderer(){if(!this.loaded)return;if(JSON.stringify(this._cachedRendererJson)===JSON.stringify(this.renderer))return;const e=this._rasterJobHandler.instance;e&&(this.symbolizer.rendererJSON=w(this.renderer.toJSON()),this.symbolizer.bind(),await e.updateSymbolizer(this.symbolizer),this._cachedRendererJson=this.renderer.toJSON())}async applyRenderer(e,t){const i=e&&e.pixelBlock;if(!(i&&i.pixels&&i.pixels.length>0))return null;let r;this.updateRenderer();const n=this._rasterJobHandler.instance,{bandIds:o}=this;return r=n?await n.symbolize({...e,simpleStretchParams:t,bandIds:o}):this.symbolizer.symbolize({...e,simpleStretchParams:t,bandIds:o}),r}getTileUrl(e,t,i){return"RasterTileServer"===this.raster.datasetFormat?`${this.url}/tile/${e}/${t}/${i}`:""}getCompatibleTileInfo(e,t){if(!this.loaded)return null;const i=h(e);return I.create({size:256,spatialReference:e,origin:i?{x:i.origin[0],y:i.origin[1]}:{x:t.xmin,y:t.ymax}})}getCompatibleFullExtent(e){return this.loaded?(this._compatibleFullExtent&&this._compatibleFullExtent.spatialReference.equals(e)||(this._compatibleFullExtent=this.raster.computeExtent(e)),this._compatibleFullExtent):null}async fetchTile(e,t,i,r={}){if(r.requestAsImageElement){const n=this.getTileUrl(e,t,i);return f(n,{responseType:"image",query:{sliceId:this._sliceId,_ts:r.timestamp},signal:r.signal}).then((e=>e.data))}await this._initJobHandler();const n="raster-shaded-relief"===this.renderer.type?{cols:1,rows:1}:null;if(this.multidimensionalDefinition){const e=this._sliceId;r={multidimensionalDefinition:this.multidimensionalDefinition,sliceId:e,buffer:n,...r}}return this.raster.fetchTile(e,t,i,r)}async fetchPixels(e,t,i,r){if(await this._initJobHandler(),this.multidimensionalDefinition){const e=this._sliceId;r={multidimensionalDefinition:this.multidimensionalDefinition,sliceId:e,...r}}return this.raster.fetchPixels(e,t,i,r)}identify(e,t={}){return this.multidimensionalDefinition&&!t.multidimensionalDefinition&&(t={...t,multidimensionalDefinition:this.multidimensionalDefinition}),this.raster.identify(e,t)}increaseRasterJobHandlerUsage(){this._rasterJobHandler.refCount++}decreaseRasterJobHandlerUsage(){this._rasterJobHandler.refCount--,this._rasterJobHandler.refCount<=0&&this._shutdownJobHandler()}_configDefaultSettings(){this._configDefaultInterpolation(),this._configDefaultSlice(),this._configDefaultRenderer()}_initJobHandler(){if(null!=this._rasterJobHandler.connectionPromise)return this._rasterJobHandler.connectionPromise;const e=new C;return this._rasterJobHandler.connectionPromise=e.initialize().then((()=>{this._rasterJobHandler.instance=e,this.raster.rasterJobHandler=e,this.renderer&&this.updateRenderer()})).catch((()=>null)),this._rasterJobHandler.connectionPromise}_shutdownJobHandler(){this._rasterJobHandler.instance&&this._rasterJobHandler.instance.destroy(),this._rasterJobHandler.instance=null,this._rasterJobHandler.connectionPromise=null,this._rasterJobHandler.refCount=0,this.raster.rasterJobHandler=null}_configDefaultInterpolation(){if(null==this.interpolation){var e;const t=R(this.rasterInfo,this.raster.tileType,null==(e=this.sourceJSON)?void 0:e.defaultResamplingMethod);this._set("interpolation",t)}}_configDefaultSlice(){const{multidimensionalInfo:e}=this.raster.rasterInfo;if(i(e)){if(!this.multidimensionalDefinition){const t=e.variables[0],i=[];t.dimensions.forEach((e=>{i.push(new v({variableName:t.name,dimensionName:e.name,values:e.hasRegularIntervals?e.extent[0]:e.values[0],isSlice:!0}))})),this.multidimensionalDefinition=i}this._sliceId=this.raster.getSliceIndex(this.multidimensionalDefinition)}}_configDefaultRenderer(){const e=this.raster.rasterInfo;var t,i;(this.bandIds||(this.bandIds=k(e)),this.renderer)||(this.renderer=_(e,{bandIds:this.bandIds,variableName:null==(t=this.multidimensionalDefinition)||null==(i=t[0])?void 0:i.variableName}));this.symbolizer?(this.symbolizer.rendererJSON=w(this.renderer.toJSON()),this.symbolizer.rasterInfo=e):this.symbolizer=new S({rendererJSON:this.renderer.toJSON(),rasterInfo:e}),this.symbolizer.bind()||U.warn("imagery-tile-mixin","The given renderer is not supported by the layer.")}};return e([n()],r.prototype,"_cachedRendererJson",void 0),e([n()],r.prototype,"_sliceId",void 0),e([n()],r.prototype,"_compatibleFullExtent",void 0),e([n()],r.prototype,"_rasterJobHandler",void 0),e([n()],r.prototype,"bandIds",void 0),e([n()],r.prototype,"copyright",void 0),e([n({type:y}),m("rasterInfo.extent")],r.prototype,"fullExtent",void 0),e([n()],r.prototype,"interpolation",void 0),e([n()],r.prototype,"ioConfig",void 0),e([n({type:[v]})],r.prototype,"multidimensionalDefinition",null),e([n()],r.prototype,"raster",void 0),e([n({readOnly:!0}),m("raster.rasterInfo")],r.prototype,"rasterInfo",void 0),e([n()],r.prototype,"sourceJSON",void 0),e([n({type:d}),m("rasterInfo.spatialReference")],r.prototype,"spatialReference",void 0),e([n({type:I}),m("rasterInfo.storageInfo.tileInfo")],r.prototype,"tileInfo",void 0),e([n(b)],r.prototype,"url",null),e([n({types:g})],r.prototype,"renderer",null),e([n()],r.prototype,"symbolizer",void 0),r=e([l("esri.layers.ImageryTileMixin")],r),r};let $=class extends c{constructor(){super(...arguments),this.blockWidth=void 0,this.blockHeight=void 0,this.compression=null,this.origin=null,this.firstPyramidLevel=null,this.maximumPyramidLevel=null,this.pyramidScalingFactor=2,this.pyramidBlockWidth=null,this.pyramidBlockHeight=null,this.isVirtualTileInfo=!1,this.tileInfo=null,this.blockBoundary=null}};e([n({type:Number,json:{write:!0}})],$.prototype,"blockWidth",void 0),e([n({type:Number,json:{write:!0}})],$.prototype,"blockHeight",void 0),e([n({type:String,json:{write:!0}})],$.prototype,"compression",void 0),e([n({type:p,json:{write:!0}})],$.prototype,"origin",void 0),e([n({type:Number,json:{write:!0}})],$.prototype,"firstPyramidLevel",void 0),e([n({type:Number,json:{write:!0}})],$.prototype,"maximumPyramidLevel",void 0),e([n()],$.prototype,"pyramidScalingFactor",void 0),e([n({type:Number,json:{write:!0}})],$.prototype,"pyramidBlockWidth",void 0),e([n({type:Number,json:{write:!0}})],$.prototype,"pyramidBlockHeight",void 0),e([n({type:Boolean,json:{write:!0}})],$.prototype,"isVirtualTileInfo",void 0),e([n({json:{write:!0}})],$.prototype,"tileInfo",void 0),e([n()],$.prototype,"blockBoundary",void 0),$=e([l("esri.layers.support.RasterStorageInfo")],$);var q=$;let A=class extends(u(c)){constructor(){super(...arguments),this.rasterJobHandler=null,this.datasetName=null,this.datasetFormat=null,this.rasterInfo=null,this.ioConfig={sampling:"closest"}}async init(){const e=N();this.addResolvingPromise(e),await this.when()}normalizeCtorArgs(e){return e&&e.ioConfig&&(e={...e,ioConfig:{resolution:null,bandIds:null,sampling:"closest",tileInfo:I.create(),...e.ioConfig}}),e}set url(e){this._set("url",x(e,t.getLogger(this.declaredClass)))}async open(e){throw new a("BaseRaster:open-not-implemented","open() is not implemented")}async fetchTile(e,t,r,n={}){var o;const{tileInfo:s}=n,a=s.lodAt(e),l=this.getTileExtent({x:a.resolution,y:a.resolution},t,r,s.origin,s.spatialReference,s.size);return null!=(o=n.multidimensionalDefinition)&&o.length&&i(this.rasterInfo.multidimensionalInfo)&&null==n.sliceId&&(n={...n,sliceId:this.getSliceIndex(n.multidimensionalDefinition)||0}),this.fetchPixels(l,s.size[0],s.size[1],n)}async identify(e,t={}){const{spatialReference:r,extent:n}=this.rasterInfo,{datumTransformation:o}=t;let s=O(e,r,o);if(!n.intersects(s))return{location:s,value:null};if(i(this.rasterInfo.transform)){const e=this.rasterInfo.transform.inverseTransform(s);if(!this.rasterInfo.nativeExtent.intersects(e))return{location:e,value:null};s=e}let a=0;if(t.srcResolution){a=z(t.srcResolution,this.rasterInfo,this.ioConfig.sampling).pyramidLevel}else if(a=await this.computeBestPyramidLevelForLocation(e,t),null==a)return{location:s,value:null};const l=this.identifyPixelLocation(s,a,null);if(null===l)return{location:s,value:null};const{row:c,col:u,rowOffset:m,colOffset:d}=l,h=D(this.url,t.sliceId),f=`${a}/${c}/${u}`;let p=P(h,null,f);i(p)||(p=this.fetchRawTile(a,c,u,t),j(h,null,f,p));const y=await p;if(!(y&&y.pixels&&y.pixels.length>0))return{location:s,value:null};const g=m*this.rasterInfo.storageInfo.blockHeight+d;return{location:s,value:!y.mask||y.mask[g]?y.pixels.map((e=>e[g])):null,pyramidLevel:a}}async fetchPixels(e,t,i,n={}){const o=e.clone().normalize();e=o[0];const s=this.rasterInfo.spatialReference,a=!e.spatialReference.equals(s),{datumTransformation:l}=n,c=new p({x:(e.xmax-e.xmin)/t,y:(e.ymax-e.ymin)/i,spatialReference:e.spatialReference}),u=n.srcResolution||(a?F(c,s,e,l):c);if(!u)return null;const{pyramidLevel:m,pyramidResolution:d,excessiveReading:h}=z(u,this.rasterInfo,this.ioConfig.sampling);if(h)return null;const f=this.rasterInfo.storageInfo;let y=a?L(e,s,l):e;const g=r(this.rasterInfo.transform);if(g&&(y=g.inverseTransform(y)),null==y)return null;const x={x:Math.floor((y.xmin-f.origin.x)/d.x+.1),y:Math.floor((f.origin.y-y.ymax)/d.y+.1)},b=Math.ceil((y.xmax-y.xmin)/d.x-.1),I=Math.ceil((y.ymax-y.ymin)/d.y-.1);if(b/t>8||I/i>8)return null;const v=await this.fetchRawPixels(m,x,{width:b,height:I},n);if(!v)return null;const w=m>0?f.pyramidBlockWidth:f.blockWidth,R=m>0?f.pyramidBlockHeight:f.blockHeight;if(!a&&1===v.pixelBlocks.length&&w===t&&R===i&&u.x===c.x&&u.y===c.y)return{extent:e,srcExtent:y,pixelBlock:v.pixelBlocks[0]};const k=E(e,v.extent,c,l,g);let _;const C=!n.requestRawData,S={rows:k.spacing[0],cols:k.spacing[1]},{pixelBlocks:H,mosaicSize:D,isPartiallyFilled:P}=v;if(this.rasterJobHandler)_=await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:H,srcMosaicSize:D,destDimension:C?{width:t,height:i}:null,coefs:C?k.coefficients:null,sampleSpacing:C?S:null,interpolation:n.interpolation},n);else{const e=J(H,D);_=C?M(e,{width:t,height:i},k.coefficients,S,n.interpolation):e}return n.requestRawData?{srcExtent:y,pixelBlock:_,transformGrid:k,extent:e,isPartiallyFilled:P}:{srcExtent:y,extent:e,pixelBlock:_}}async fetchRawPixels(e,t,i,r){const{origin:n,blockBoundary:o}=this.rasterInfo.storageInfo,{blockWidth:s,blockHeight:a}=this.getBlockWidthHeight(e);let{x:l,y:c}=t,{width:u,height:m}=i;r.buffer&&(l-=r.buffer.cols,c-=r.buffer.rows,u+=2*r.buffer.cols,m+=2*r.buffer.rows);const d=Math.floor(l/s),h=Math.floor(c/a),f=Math.floor((l+u-1)/s),p=Math.floor((c+m-1)/a),g=o[e];if(!g)return null;const{minRow:x,minCol:b,maxCol:I,maxRow:v}=g;if(p<x||f<b||h>v||d>I)return null;const w=[];let R,k=!1;for(let t=h;t<=p;t++)for(let i=d;i<=f;i++)t>=x&&i>=b&&v>=t&&I>=i?(R=this._fetchRawTile(e,t,i,r),this.ioConfig.allowPartialFill&&(R=new Promise((e=>{R.then((t=>e(t))).catch((()=>{k=!0,e(null)}))}))),w.push(R)):w.push(null);if(0===w.length)return null;const _=await Promise.all(w),C={height:(p-h+1)*s,width:(f-d+1)*a},{nativePixelSize:S,spatialReference:H}=this.rasterInfo,J=S.x*2**e,M=S.y*2**e;return{extent:new y({xmin:n.x+d*s*J,xmax:n.x+(f+1)*s*J,ymin:n.y-(p+1)*a*M,ymax:n.y-h*a*M,spatialReference:H}),pixelBlocks:_,mosaicSize:C,isPartiallyFilled:k}}async fetchRawTile(e,t,i,r){throw new a("BaseRaster:read-not-implemented","fetchRawTile() is not implemented")}computeExtent(e){return L(this.rasterInfo.extent,e)}decodePixelBlock(e,t){return!this.rasterJobHandler||t.useCanvas?H(e,t):this.rasterJobHandler.decode({data:e,options:t})}async request(e,t,i){var r,n;const{customFetchParameters:o}=this.ioConfig,{range:s,query:a,headers:l}=t;i=null!=(r=null!=(n=i)?n:t.retryCount)?r:this.ioConfig.retryCount;const c=s?{Range:`bytes=${s.from}-${s.to}`}:null;try{return await f(e,{...t,query:{...a,...o},headers:{...l,...c}})}catch(r){if(i>0)return i--,this.request(e,t,i);throw r}}getSliceIndex(e){const{multidimensionalInfo:t}=this.rasterInfo;if(!i(t)||null==e||!e.length)return null;let r=0;const n=e[0].variableName;for(let i=0;i<t.variables.length;i++){const o=t.variables[i],s=o.dimensions;if(o.name!==n){r+=s.map((e=>this._getDimensionValuesCount(e))).reduce(((e,t)=>e+t));break}const a=s.map((e=>this._getDimensionValuesCount(e))),l=s.length;for(let t=0;t<l;t++){const i=e.filter((e=>e.dimensionName===s[t].name))[0];if(null==i)return null;const n=Array.isArray(i.values[0])?i.values[0][0]:i.values[0],o=this._getIndexFromDimensions(n,s[t]);if(-1===o)return null;a.shift(),r+=t===l-1?o:o*a.reduce(((e,t)=>e+t))}}return r}updateTileInfo(){const{storageInfo:e,spatialReference:t,extent:i,pixelSize:r}=this.rasterInfo;if(!e.tileInfo){const n=[],o=e.maximumPyramidLevel||0;let s=Math.max(r.x,r.y),a=1/.0254*96*s;for(let e=0;e<=o;e++)n.push({level:o-e,resolution:s,scale:a}),s*=2,a*=2;const l=new p({x:i.xmin,y:i.ymax,spatialReference:t});e.tileInfo=new I({origin:l,size:[e.blockWidth,e.blockHeight],spatialReference:t,lods:n}),e.isVirtualTileInfo=!0}}createRemoteDatasetStorageInfo(e,t=512,i=512,r){const{width:n,height:o,nativeExtent:s,pixelSize:a,spatialReference:l}=e,c=new p({x:s.xmin,y:s.ymax,spatialReference:l});null==r&&(r=Math.max(0,Math.round(Math.log(Math.max(n,o))/Math.LN2-8)));const u=this._computeBlockBoundary(s,a,r,512,512);e.storageInfo=new q({blockWidth:t,blockHeight:i,pyramidBlockWidth:t,pyramidBlockHeight:i,origin:c,firstPyramidLevel:1,maximumPyramidLevel:r,blockBoundary:u})}async computeBestPyramidLevelForLocation(e,t={}){return 0}identifyPixelLocation(e,t,i){const{spatialReference:r,nativePixelSize:n,nativeExtent:o}=this.rasterInfo,{blockWidth:s,blockHeight:a,maximumPyramidLevel:l,pyramidScalingFactor:c,origin:u}=this.rasterInfo.storageInfo,m=O(e,r,i);if(!o.intersects(m))return null;if(t<0||t>l)return null;const d=c**t,h=d*n.x,f=d*n.y,p=(u.y-m.y)/f/a,y=(m.x-u.x)/h/s,g=Math.min(a-1,Math.floor((p-Math.floor(p))*a)),x=Math.min(s-1,Math.floor((y-Math.floor(y))*s));return{pyramidLevel:t,row:Math.floor(p),col:Math.floor(y),rowOffset:g,colOffset:x,srcLocation:m}}getTileExtent(e,t,i,r,n,o){const[s,a]=o,l=r.x+i*s*e.x,c=l+s*e.x,u=r.y-t*a*e.y,m=u-a*e.y;return new y({xmin:l,xmax:c,ymin:m,ymax:u,spatialReference:n})}getBlockWidthHeight(e){return{blockWidth:e>0?this.rasterInfo.storageInfo.pyramidBlockWidth:this.rasterInfo.storageInfo.blockWidth,blockHeight:e>0?this.rasterInfo.storageInfo.pyramidBlockHeight:this.rasterInfo.storageInfo.blockHeight}}isBlockOutside(e,t,i){const r=this.rasterInfo.storageInfo.blockBoundary[e];return!r||r.maxRow<t||r.maxCol<i||r.minRow>t||r.minCol>i}_computeBlockBoundary(e,t,i,r,n){let{x:o,y:s}=t;const a=e.xmin,l=e.ymax,c=[{minCol:Math.floor((e.xmin-a+.1*o)/r/o),maxCol:Math.floor((e.xmax-a-.1*o)/r/o),minRow:Math.floor((l-e.ymax+.1*s)/n/s),maxRow:Math.floor((l-e.ymin-.1*s)/n/s)}];if(i>0)for(let t=0;t<i;t++)o*=2,s*=2,c.push({minCol:Math.floor((e.xmin-a+.1*o)/r/o),maxCol:Math.floor((e.xmax-a-.1*o)/r/o),minRow:Math.floor((l-e.ymax+.1*s)/n/o),maxRow:Math.floor((l-e.ymin-.1*s)/n/o)});return c}_fetchRawTile(e,t,r,n){const a=this.rasterInfo.storageInfo.blockBoundary[e];if(!a)return Promise.resolve(null);const{minRow:l,minCol:c,maxCol:u,maxRow:m}=a;if(t<l||r<c||t>m||r>u)return Promise.resolve(null);const d=D(this.url,n.sliceId),h=`${e}/${t}/${r}`;let f=P(d,n.registryId,h);if(!i(f)){const i=o();f=this.fetchRawTile(e,t,r,{...n,signal:i.signal}),j(d,n.registryId,h,f,i),f.catch((()=>{B(d,n.registryId,h)}))}return n.signal&&s(n,(()=>{T(d,n.registryId,h)})),f}_getIndexFromDimensions(e,t){const{extent:i,interval:r,unit:n,values:o}=t;if(null!=o&&o.length)return Array.isArray(o[0])?o.findIndex((t=>t[0]<=e&&t[1]>=e)):o.indexOf(e);if(e>i[1])return-1;const s=i[0];let a=-1;if("ISO8601"===n){var l;switch((null==(l=t.intervalUnit)?void 0:l.toLowerCase())||"seconds"){case"seconds":a=Math.round((e-s)/1e3/r);break;case"minutes":a=Math.round((e-s)/6e4/r);break;case"hours":a=Math.round((e-s)/36e5/r);break;case"days":a=Math.round((e-s)/864e5/r);break;case"years":a=Math.round((new Date(e).getUTCFullYear()-new Date(s).getUTCFullYear())/r);break;case"decades":a=Math.round((new Date(e).getUTCFullYear()-new Date(s).getUTCFullYear())/10/r)}return a}return Math.round((e-s)/r)}_getDimensionValuesCount(e){const{extent:t,interval:i,unit:r,values:n}=e;let o=(null==n?void 0:n.length)||0;if(o)return o;const s=t[0];if(0===o&&"ISO8601"===r){var a;switch((null==(a=e.intervalUnit)?void 0:a.toLowerCase())||"seconds"){case"seconds":o=Math.round((t[1]-t[0])/1e3/i);break;case"minutes":o=Math.round((t[1]-t[0])/6e4/i);break;case"hours":o=Math.round((t[1]-t[0])/36e5/i);break;case"days":o=Math.round((t[1]-t[0])/864e5/i);break;case"years":o=Math.round((new Date(t[1]).getUTCFullYear()-new Date(s).getUTCFullYear())/i);break;case"decades":o=Math.round((new Date(t[1]).getUTCFullYear()-new Date(s).getUTCFullYear())/10/i)}return o}return Math.round((t[1]-t[0])/i)}};e([n(b)],A.prototype,"url",null),e([n({type:String,json:{write:!0}})],A.prototype,"datasetName",void 0),e([n({type:String,json:{write:!0}})],A.prototype,"datasetFormat",void 0),e([n()],A.prototype,"rasterInfo",void 0),e([n()],A.prototype,"ioConfig",void 0),e([n()],A.prototype,"sourceJSON",void 0),A=e([l("esri.layers.support.rasterDatasets.BaseRaster")],A);var V=A;function Y(e,t){if(!e||!t)return[];let i=t;t.indexOf("/")>-1?(i=t.slice(0,t.indexOf("/")),t=t.slice(t.indexOf("/")+1)):t="";const r=[];if(t){const n=Y(e,i);for(let e=0;e<n.length;e++){Y(n[e],t).forEach((e=>r.push(e)))}return r}const n=e.getElementsByTagNameNS("*",i);if(!n||0===n.length)return[];for(let e=0;e<n.length;e++)r.push(n[e]||n.item[e]);return r}function G(e,t){if(!e||!t)return null;let i=t;t.indexOf("/")>-1?(i=t.slice(0,t.indexOf("/")),t=t.slice(t.indexOf("/")+1)):t="";const r=Y(e,i);return r.length>0?t?G(r[0],t):r[0]:null}function K(e,t=null){const i=t?G(e,t):e;let r;return i?(r=i.textContent||i.nodeValue,r?r.trim():null):null}function Q(e,t){const i=Y(e,t),r=[];let n;for(let e=0;e<i.length;e++)n=i[e].textContent||i[e].nodeValue,n&&(n=n.trim(),""!==n&&r.push(n));return r}function X(e,t=null){const i=K(e,t);return null==i?void 0:i.split(" ").map((e=>Number(e)))}function Z(e,t){return Q(e,t).map((e=>Number(e)))}function ee(e,t){const i=K(e,t);return Number(i)}function te(e,t){var i;const r=null==e||null==(i=e.nodeName)?void 0:i.toLowerCase(),n=t.toLowerCase();return r.slice(r.lastIndexOf(":")+1)===n}function ie(e){return e.nodeName.slice(e.nodeName.lastIndexOf(":")+1)}export{V as B,W as I,q as R,Y as a,G as b,ee as c,Z as d,X as e,Q as f,K as g,ie as h,te as i};
