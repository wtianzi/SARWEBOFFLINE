/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.19/esri/copyright.txt for details.
*/
import{c as t}from"./mathUtils2.js";import{j as s}from"./definitions.js";import{S as e}from"./FeatureSetReader.js";const i=0,o=1,h=2;class r{constructor(t,s){this.width=t,this.height=s;const i=Math.ceil(t/1),o=Math.ceil(s/1);this._cols=i,this._rows=o,this._cells=e.create(i*o)}insertMetrics(t){const s=this._hasCollision(t);return 0===s&&this._markMetrics(t),s}getCellId(t,s){return t+s*this._cols}has(t){return this._cells.has(t)}hasRange(t,s){return this._cells.hasRange(t,s)}set(t){this._cells.set(t)}setRange(t,s){this._cells.setRange(t,s)}_hasCollision(t){const s=t.id;let e=0,i=0;t.save();do{const s=t.boundsCount;e+=s;for(let e=0;e<s;e++){const s=t.boundsComputedAnchorX(e),o=t.boundsComputedAnchorY(e),h=t.boundsWidth(e)+2,r=t.boundsHeight(e)+2;switch(this._collide(s,o,h,r)){case 2:return 2;case 1:i++}}}while(t.peekId()===s&&t.next());return t.restore(),e===i?1:0}_collide(s,e,i,o){const h=s-i/2,r=s+i/2,n=e-o/2,c=e+o/2;if(r<0||c<0||h>this.width||n>this.height)return 1;const l=t(Math.floor(h/1),0,this._cols),a=t(Math.floor(n/1),0,this._rows),_=t(Math.ceil(r/1),0,this._cols),d=t(Math.ceil(c/1),0,this._rows);for(let t=a;t<=d;t++)for(let s=l;s<=_;s++){const e=this.getCellId(s,t);if(this.has(e))return 2}return 0}_mark(s,e,i,o){const h=s-i/2,r=s+i/2,n=e-o/2,c=e+o/2,l=t(Math.floor(h/1),0,this._cols),a=t(Math.floor(n/1),0,this._rows),_=t(Math.ceil(r/1),0,this._cols),d=t(Math.ceil(c/1),0,this._rows);for(let t=a;t<=d;t++)for(let s=l;s<=_;s++){const e=this.getCellId(s,t);this.set(e)}return!1}_markMetrics(t){const s=t.id;do{const s=t.boundsCount;for(let e=0;e<s;e++){const s=t.boundsComputedAnchorX(e),i=t.boundsComputedAnchorY(e),o=t.boundsWidth(e)+2,h=t.boundsHeight(e)+2;this._mark(s,i,o,h)}}while(t.peekId()===s&&t.next())}}class n{constructor(t,e=2){this._bucketSize=t,this._rowsLength=s/t,this._colsLength=s/t,this._elementsPerBucket=e,this._grid=this._initGrid()}checkOverlap(t,s){const e=Math.floor(t/this._bucketSize),i=Math.floor(s/this._bucketSize);return e<0||e>=this._rowsLength||i<0||i>=this._colsLength||this._grid[i*this._colsLength+e]>=this._elementsPerBucket}markUsed(t,s){const e=Math.floor(t/this._bucketSize),i=Math.floor(s/this._bucketSize);this._grid[i*this._colsLength+e]+=1}reset(){this._grid=this._initGrid()}_initGrid(){return new Uint8Array(this._rowsLength*this._colsLength)}}export{r as C,h as H,i as N,o as O,n as a};
