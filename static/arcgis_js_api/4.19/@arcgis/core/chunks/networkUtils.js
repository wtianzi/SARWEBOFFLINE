/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.19/esri/copyright.txt for details.
*/
import{_ as e}from"./tslib.es6.js";import"../core/lang.js";import{g as r}from"./object.js";import{i as t}from"./Logger.js";import{property as s}from"../core/accessorSupport/decorators/property.js";import o from"../core/Error.js";import"./ensureType.js";import{subclass as a}from"../core/accessorSupport/decorators/subclass.js";import{a as i}from"./JSONSupport.js";import"../core/urlUtils.js";import{r as n}from"./reader.js";import"./resourceExtension.js";import l from"../request.js";import p from"../Graphic.js";import u from"../tasks/support/FeatureSet.js";import{p as f}from"./utils4.js";import d from"../tasks/support/NAMessage.js";import c from"../tasks/support/RouteResult.js";class m{constructor(e={}){this._options=e}toQueryParams(e){if(!e)return null;const r=e.toJSON(),t={};return Object.keys(r).forEach((e=>{const s=this._options[e];if(s){const o="boolean"!=typeof s&&s.name?s.name:e,a="boolean"!=typeof s&&s.getter?s.getter(r):r[e];null!=a&&(t[o]=(e=>{if(!Array.isArray(e))return!1;const[r]=e;return"number"==typeof r||"string"==typeof r})(a)?a.join(","):"object"==typeof a?JSON.stringify(a):a)}else t[e]=r[e]}),this),t}}function y(e){return new m(e)}function v(e){return e&&u.fromJSON(e).features.map((e=>e))}let g=class extends i{constructor(e){super(e),this.barriers=null,this.messages=null,this.pointBarriers=null,this.polylineBarriers=null,this.polygonBarriers=null,this.routeResults=null}readPointBarriers(e,r){return v(r.barriers||r.pointBarriers)}readPolylineBarriers(e){return v(e)}readPolygonBarriers(e){return v(e)}};e([s({aliasOf:"pointBarriers"})],g.prototype,"barriers",void 0),e([s({type:[d]})],g.prototype,"messages",void 0),e([s({type:[p]})],g.prototype,"pointBarriers",void 0),e([n("pointBarriers",["barriers","pointBarriers"])],g.prototype,"readPointBarriers",null),e([s({type:[p]})],g.prototype,"polylineBarriers",void 0),e([n("polylineBarriers")],g.prototype,"readPolylineBarriers",null),e([s({type:[p]})],g.prototype,"polygonBarriers",void 0),e([n("polygonBarriers")],g.prototype,"readPolygonBarriers",null),e([s({type:[c]})],g.prototype,"routeResults",void 0),g=e([a("esri.tasks.support.RouteResultsContainer")],g);var h=g;function T(e,r,t,s){s[t]=[r.length,r.length+e.length],e.forEach((e=>{r.push(e.geometry)}))}function M(e,r){for(let t=0;t<r.length;t++){const s=e[r[t]];if(s&&s.length)for(const e of s)e.z=void 0}console.log("The remote Network Analysis service is powered by a network dataset which is not Z-aware.\nZ-coordinates of the input geometry are ignored.")}function j(e){const r=[],t=[],{directions:s=[],routes:{features:o=[],spatialReference:a=null}={},stops:{features:i=[],spatialReference:n=null}={},barriers:l,polygonBarriers:p,polylineBarriers:u,messages:f}=e.data,d="esri.tasks.RouteTask.NULL_ROUTE_NAME";let c,m,y=!0;const v=o&&a||i&&n||l&&l.spatialReference||p&&p.spatialReference||u&&u.spatialReference;s.forEach((e=>{r.push(c=e.routeName),t[c]={directions:e}})),o.forEach((e=>{-1===r.indexOf(c=e.attributes.Name)&&(r.push(c),t[c]={}),e.geometry&&(e.geometry.spatialReference=v),t[c].route=e})),i.forEach((e=>{m=e.attributes,-1===r.indexOf(c=m.RouteName||d)&&(r.push(c),t[c]={}),c!==d&&(y=!1),e.geometry&&(e.geometry.spatialReference=v),null==t[c].stops&&(t[c].stops=[]),t[c].stops.push(e)})),i.length>0&&!0===y&&(t[r[0]].stops=t[d].stops,delete t[d],r.splice(r.indexOf(d),1));const g=r.map((e=>(t[e].routeName=e===d?null:e,t[e])));return h.fromJSON({routeResults:g,pointBarriers:l,polygonBarriers:p,polylineBarriers:u,messages:f})}function B(e,r){for(let s=0;s<r.length;s++){const o=e[r[s]];if(o&&o.length)for(const e of o)if(t(e)&&e.hasZ)return!0}return!1}async function w(e){if(!e)throw new o("network-service:missing-url","Url to Network service is missing");const{data:t}=await l(e,{query:{f:"json"}});t.supportedTravelModes||(t.supportedTravelModes=[]);for(let e=0;e<t.supportedTravelModes.length;e++)t.supportedTravelModes[e].id||(t.supportedTravelModes[e].id=t.supportedTravelModes[e].itemId);const s=t.currentVersion>=10.4?async function(e){try{const{data:{supportedTravelModes:r,defaultTravelMode:t}}=await l(e+("/"===e[e.length-1]?"":"/")+"retrieveTravelModes",{query:{f:"json"}});return{supportedTravelModes:r,defaultTravelMode:t}}catch(e){throw new o("network-service:retrieveTravelModes","Could not get to the NAServer's retrieveTravelModes.",{error:e})}}(e):async function(e){const{data:t}=await l(e.substring(0,e.indexOf("/rest/")+6)+"info",{query:{f:"json"}});if(!t||!t.owningSystemUrl)return{supportedTravelModes:[],defaultTravelMode:null};e=t.owningSystemUrl;const{data:s}=await l(e+("/"===e[e.length-1]?"":"/")+"sharing/rest/portals/self",{query:{f:"json"}}),o=r("helperServices.routingUtilities.url",s);if(!o)return{supportedTravelModes:[],defaultTravelMode:null};const a=f(e),i=/\/solve$/.test(a.path)?"Route":/\/solveClosestFacility$/.test(a.path)?"ClosestFacility":"ServiceAreas",n=await l(o+("/"===o[o.length-1]?"":"/")+"GetTravelModes/execute",{query:{f:"json",serviceName:i}}),p=[];let u=null;if(n&&n.data&&n.data.results&&n.data.results.length){const e=n.data.results;for(const r of e)if("supportedTravelModes"===r.paramName){if(r.value&&r.value.features)for(const{attributes:e}of r.value.features)if(e){const r=JSON.parse(e.TravelMode);p.push(r)}}else"defaultTravelMode"===r.paramName&&(u=r.value)}return{supportedTravelModes:p,defaultTravelMode:u}}(e),{defaultTravelMode:a,supportedTravelModes:i}=await s;return t.defaultTravelMode=a,t.supportedTravelModes=i,t}export{y as a,T as c,M as d,w as f,j as h,B as i};
