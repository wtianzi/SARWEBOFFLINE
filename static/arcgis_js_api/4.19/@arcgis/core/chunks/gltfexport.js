/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.19/esri/copyright.txt for details.
*/
import"./tslib.es6.js";import"./ArrayPool.js";import{h as t}from"../core/lang.js";import"./deprecate.js";import"./object.js";import"../kernel.js";import"../config.js";import{i as e,b as s}from"./Logger.js";import"./string.js";import"./metadata.js";import"../core/accessorSupport/decorators/property.js";import"../core/Accessor.js";import"./PropertyOrigin.js";import"../core/scheduling.js";import{eachAlways as r}from"../core/promiseUtils.js";import"./Message.js";import i from"../core/Error.js";import"./ensureType.js";import"../core/accessorSupport/decorators/subclass.js";import"./JSONSupport.js";import"../core/urlUtils.js";import"../core/accessorSupport/decorators/cast.js";import"./jsonMap.js";import"./reader.js";import"./writer.js";import"./resourceExtension.js";import"./persistableUrlUtils.js";import"../geometry/SpatialReference.js";import"../request.js";import"./assets.js";import"../geometry/Geometry.js";import o from"../geometry/Point.js";import"./Ellipsoid.js";import"../geometry/support/webMercatorUtils.js";import"../geometry/Extent.js";import{q as n}from"./mathUtils2.js";import{c as a,Z as c,a as h,O as u}from"./vec3f64.js";import"./common.js";import{a as l,s as f,c as m,n as p,u as d}from"./vec3.js";import"./colorUtils.js";import"../Color.js";import"./zmUtils.js";import"../geometry/Multipoint.js";import"../geometry/Polygon.js";import"./extentUtils.js";import"../geometry/Polyline.js";import"./typeUtils.js";import"../geometry/support/jsonUtils.js";import"../geometry.js";import"./unitUtils.js";import"./mat4.js";import"./pe.js";import"./aaBoundingRect.js";import"./geodesicConstants.js";import"../geometry/support/GeographicTransformationStep.js";import"../geometry/support/GeographicTransformation.js";import"../geometry/projection.js";import"./vec4f64.js";import"./screenshotUtils.js";import"../geometry/support/MeshTexture.js";import"../geometry/support/MeshMaterial.js";import g from"../geometry/support/MeshMaterialMetallicRoughness.js";import"../geometry/support/MeshComponent.js";import"./earcut.js";import"./deduplicate.js";import"./triangulationUtils.js";import{i as A,j as b,b as x}from"./quatf64.js";import"./mat3.js";import"./BufferView.js";import"./vec2.js";import"./vec4.js";import"./projection.js";import{u as E}from"../geometry/Mesh.js";import"./vec32.js";import{e as w,f as T}from"./quat.js";class y{constructor(t,e){if(!t)throw new Error("GLB requires a JSON gltf chunk");this.length=y.HEADER_SIZE,this.length+=y.CHUNK_HEADER_SIZE;const s=this.textToArrayBuffer(t);if(this.length+=this.alignTo(s.byteLength,4),e&&(this.length+=y.CHUNK_HEADER_SIZE,this.length+=e.byteLength,e.byteLength%4))throw new Error("Expected BIN chunk length to be divisible by 4 at this point");this.buffer=new ArrayBuffer(this.length),this.outView=new DataView(this.buffer),this.writeHeader();const r=this.writeChunk(s,12,1313821514,32);e&&this.writeChunk(e,r,5130562)}writeHeader(){this.outView.setUint32(0,y.MAGIC,!0),this.outView.setUint32(4,y.VERSION,!0),this.outView.setUint32(8,this.length,!0)}writeChunk(t,e,s,r=0){const i=this.alignTo(t.byteLength,4);for(this.outView.setUint32(e,i,!0),this.outView.setUint32(e+=4,s,!0),this.writeArrayBuffer(this.outView.buffer,t,e+=4,0,t.byteLength),e+=t.byteLength;e%4;)r&&this.outView.setUint8(e,r),e++;return e}writeArrayBuffer(t,e,s,r,i){new Uint8Array(t,s,i).set(new Uint8Array(e,r,i),0)}textToArrayBuffer(e){if(t("esri-text-encoder"))return(new TextEncoder).encode(e).buffer;const s=new Uint8Array(e.length);for(let t=0;t<s.length;++t)s[t]=e.charCodeAt(t);return s.buffer}alignTo(t,e){return e*Math.ceil(t/e)}}var R,N,v,S,I,M,O,B,L;y.HEADER_SIZE=12,y.CHUNK_HEADER_SIZE=8,y.MAGIC=1179937895,y.VERSION=2,function(t){t[t.External=0]="External",t[t.DataURI=1]="DataURI",t[t.GLB=2]="GLB"}(R||(R={})),function(t){t[t.External=0]="External",t[t.DataURI=1]="DataURI",t[t.GLB=2]="GLB"}(N||(N={})),function(t){t[t.BYTE=5120]="BYTE",t[t.UNSIGNED_BYTE=5121]="UNSIGNED_BYTE",t[t.SHORT=5122]="SHORT",t[t.UNSIGNED_SHORT=5123]="UNSIGNED_SHORT",t[t.UNSIGNED_INT=5125]="UNSIGNED_INT",t[t.FLOAT=5126]="FLOAT"}(v||(v={})),function(t){t[t.ARRAY_BUFFER=34962]="ARRAY_BUFFER",t[t.ELEMENT_ARRAY_BUFFER=34963]="ELEMENT_ARRAY_BUFFER"}(S||(S={})),function(t){t.SCALAR="SCALAR",t.VEC2="VEC2",t.VEC3="VEC3",t.VEC4="VEC4",t.MAT2="MAT2",t.MAT3="MAT3",t.MAT4="MAT4"}(I||(I={})),function(t){t[t.POINTS=0]="POINTS",t[t.LINES=1]="LINES",t[t.LINE_LOOP=2]="LINE_LOOP",t[t.LINE_STRIP=3]="LINE_STRIP",t[t.TRIANGLES=4]="TRIANGLES",t[t.TRIANGLE_STRIP=5]="TRIANGLE_STRIP",t[t.TRIANGLE_FAN=6]="TRIANGLE_FAN"}(M||(M={})),function(t){t.OPAQUE="OPAQUE",t.MASK="MASK",t.BLEND="BLEND"}(O||(O={})),function(t){t[t.NoColor=0]="NoColor",t[t.FaceColor=1]="FaceColor",t[t.VertexColor=2]="VertexColor"}(B||(B={})),function(t){t[t.NEAREST=9728]="NEAREST",t[t.LINEAR=9729]="LINEAR",t[t.NEAREST_MIPMAP_NEAREST=9984]="NEAREST_MIPMAP_NEAREST",t[t.LINEAR_MIPMAP_NEAREST=9985]="LINEAR_MIPMAP_NEAREST",t[t.NEAREST_MIPMAP_LINEAR=9986]="NEAREST_MIPMAP_LINEAR",t[t.LINEAR_MIPMAP_LINEAR=9987]="LINEAR_MIPMAP_LINEAR"}(L||(L={}));class j{constructor(t,e,s,r,i){this.buffer=t,this.componentType=s,this.dataType=r,this.data=[],this.isFinalized=!1,this.accessorIndex=-1,this.accessorAttribute=null,this.accessorMin=null,this.accessorMax=null,e.bufferViews||(e.bufferViews=[]),this.index=e.bufferViews.length,this.bufferView={buffer:t.index,byteLength:-1,target:i};const o=this.getElementSize();o>=4&&i!==S.ELEMENT_ARRAY_BUFFER&&(this.bufferView.byteStride=o),e.bufferViews.push(this.bufferView)}push(t){const e=this.data.length;if(this.data.push(t),this.accessorIndex>=0){const s=e%this.numComponentsForDataType(),r=this.accessorMin[s];this.accessorMin[s]="number"!=typeof r?t:Math.min(r,t);const i=this.accessorMax[s];this.accessorMax[s]="number"!=typeof i?t:Math.max(i,t)}}get dataSize(){return this.data.length*this.sizeComponentType()}get size(){return t=this.dataSize,(e=4)*Math.ceil(t/e);var t,e}getByteOffset(){if(!this.isFinalized)throw new Error("Cannot get BufferView offset until it is finalized");return this.buffer.getByteOffset(this)}get byteOffset(){if(!this.isFinalized)throw new Error("Cannot get BufferView offset until it is finalized");return this.buffer.getByteOffset(this)}writeOutToBuffer(t,e=this.size){const s=new DataView(t,e),r=this.sizeComponentType();for(let t=0;t<this.data.length;++t)this.writeValue(s,t*r,this.data[t])}writeAsync(t){if(this.asyncWritePromise)throw new Error("Can't write multiple bufferView vlaues asynchronously");return this.asyncWritePromise=t.then((t=>{const e=new Uint8Array(t);for(let t=0;t<e.byteLength;++t)this.data.push(e[t]);delete this.asyncWritePromise})),this.asyncWritePromise}startAccessor(t){if(this.accessorIndex>=0)throw new Error("Accessor was started without ending the previous one");this.accessorIndex=this.data.length,this.accessorAttribute=t;const e=this.numComponentsForDataType();this.accessorMin=new Array(e),this.accessorMax=new Array(e)}endAccessor(){if(this.accessorIndex<0)throw new Error("An accessor was not started, but was attempted to be ended");const t=this.getElementSize(),e=this.numComponentsForDataType(),s=(this.data.length-this.accessorIndex)/e;if(s%1)throw new Error("An accessor was ended with missing component values");for(let t=0;t<this.accessorMin.length;++t)"number"!=typeof this.accessorMin[t]&&(this.accessorMin[t]=0),"number"!=typeof this.accessorMax[t]&&(this.accessorMax[t]=0);const r={byteOffset:t*(this.accessorIndex/e),componentType:this.componentType,count:s,type:this.dataType,min:this.accessorMin,max:this.accessorMax,name:this.accessorAttribute};switch(this.accessorAttribute){case"TEXCOORD_0":case"TEXCOORD_1":case"COLOR_0":case"WEIGHTS_0":switch(this.componentType){case v.UNSIGNED_BYTE:case v.UNSIGNED_SHORT:r.normalized=!0}}return this.accessorIndex=-1,this.accessorAttribute=null,this.accessorMin=null,this.accessorMax=null,r}get finalized(){return this.finalizedPromise?this.finalizedPromise:this.isFinalized?this.finalizedPromise=Promise.resolve():this.finalizedPromise=new Promise((t=>this.finalizedPromiseResolve=t))}finalize(){const t=this.bufferView;return new Promise((t=>{const e=this.buffer.getViewFinalizePromises(this);this.asyncWritePromise&&e.push(this.asyncWritePromise),t(r(e))})).then((()=>{this.isFinalized=!0,t.byteOffset=this.getByteOffset(),t.byteLength=this.dataSize,this.finalizedPromiseResolve&&this.finalizedPromiseResolve()}))}getElementSize(){return this.sizeComponentType()*this.numComponentsForDataType()}sizeComponentType(){switch(this.componentType){case v.BYTE:case v.UNSIGNED_BYTE:return 1;case v.SHORT:case v.UNSIGNED_SHORT:return 2;case v.UNSIGNED_INT:case v.FLOAT:return 4}}numComponentsForDataType(){switch(this.dataType){case I.SCALAR:return 1;case I.VEC2:return 2;case I.VEC3:return 3;case I.VEC4:case I.MAT2:return 4;case I.MAT3:return 9;case I.MAT4:return 16}}writeValue(t,e,s){switch(this.componentType){case v.BYTE:t.setInt8(e,s);break;case v.UNSIGNED_BYTE:t.setUint8(e,s);break;case v.SHORT:t.setInt16(e,s,!0);break;case v.UNSIGNED_SHORT:t.setUint16(e,s,!0);break;case v.UNSIGNED_INT:t.setUint32(e,s,!0);break;case v.FLOAT:t.setFloat32(e,s,!0);break;default:throw new Error(`Unsupported data type: ${this.componentType}`)}}}class C{constructor(t){this.gltf=t,this.bufferViews=[],this.isFinalized=!1,t.buffers||(t.buffers=[]),this.index=t.buffers.length;const e={byteLength:-1};t.buffers.push(e),this.buffer=e}addBufferView(t,e,s){if(this.finalizePromise)throw new Error("Cannot add buffer view after fiinalizing buffer");const r=new j(this,this.gltf,t,e,s);return this.bufferViews.push(r),r}getByteOffset(t){let e=0;for(const s of this.bufferViews){if(s===t)return e;e+=s.size}throw new Error("Given bufferView was not present in this buffer")}getViewFinalizePromises(t){const e=[];for(const s of this.bufferViews){if(t&&s===t)return e;e.push(s.finalized)}return e}getArrayBuffer(){if(!this.isFinalized)throw new Error("Cannot get ArrayBuffer from Buffer before it is finalized");const t=this.getTotalSize(),e=new ArrayBuffer(t);let s=0;for(const t of this.bufferViews)t.writeOutToBuffer(e,s),s+=t.size;return e}finalize(){if(this.finalizePromise)throw new Error(`Buffer ${this.index} was already finalized`);return this.finalizePromise=new Promise((t=>{t(r(this.getViewFinalizePromises()))})).then((()=>{this.isFinalized=!0;const t=this.getArrayBuffer();this.buffer.byteLength=t.byteLength,this.buffer.uri=t})),this.gltf.extras.promises.push(this.finalizePromise),this.finalizePromise}getTotalSize(){let t=0;for(const e of this.bufferViews)t+=e.size;return t}}function _(t,e){t.vertexAttributes.normal||(t.vertexAttributes.normal=new Float32Array(t.vertexAttributes.position.length));const s=e.faces.length/3;for(let r=0;r<s;++r){const s=e.faces[3*r+0],i=e.faces[3*r+1],o=e.faces[3*r+2],a=l(U,t.vertexAttributes.position[3*s+0],t.vertexAttributes.position[3*s+1],t.vertexAttributes.position[3*s+2]),c=l(z,t.vertexAttributes.position[3*i+0],t.vertexAttributes.position[3*i+1],t.vertexAttributes.position[3*i+2]),h=l(V,t.vertexAttributes.position[3*o+0],t.vertexAttributes.position[3*o+1],t.vertexAttributes.position[3*o+2]),u=f(c,c,a),p=f(h,h,a),d=m(u,u,p);n(t.vertexAttributes.normal[3*s+0])&&(t.vertexAttributes.normal[3*s+0]=0),n(t.vertexAttributes.normal[3*s+1])&&(t.vertexAttributes.normal[3*s+1]=0),n(t.vertexAttributes.normal[3*s+2])&&(t.vertexAttributes.normal[3*s+2]=0),n(t.vertexAttributes.normal[3*i+0])&&(t.vertexAttributes.normal[3*i+0]=0),n(t.vertexAttributes.normal[3*i+1])&&(t.vertexAttributes.normal[3*i+1]=0),n(t.vertexAttributes.normal[3*i+2])&&(t.vertexAttributes.normal[3*i+2]=0),n(t.vertexAttributes.normal[3*o+0])&&(t.vertexAttributes.normal[3*o+0]=0),n(t.vertexAttributes.normal[3*o+1])&&(t.vertexAttributes.normal[3*o+1]=0),n(t.vertexAttributes.normal[3*o+2])&&(t.vertexAttributes.normal[3*o+2]=0),t.vertexAttributes.normal[3*s+0]+=d[0],t.vertexAttributes.normal[3*s+1]+=d[1],t.vertexAttributes.normal[3*s+2]+=d[2],t.vertexAttributes.normal[3*i+0]+=d[0],t.vertexAttributes.normal[3*i+1]+=d[1],t.vertexAttributes.normal[3*i+2]+=d[2],t.vertexAttributes.normal[3*o+0]+=d[0],t.vertexAttributes.normal[3*o+1]+=d[1],t.vertexAttributes.normal[3*o+2]+=d[2]}for(let e=0;e<t.vertexAttributes.normal.length;e+=3)l(P,t.vertexAttributes.normal[e],t.vertexAttributes.normal[e+1],t.vertexAttributes.normal[e+2]),p(P,P),t.vertexAttributes.normal[e+0]=P[0],t.vertexAttributes.normal[e+1]=P[1],t.vertexAttributes.normal[e+2]=P[2]}const U=a(),z=a(),V=a(),P=a();async function F(t){const e=G(t);if(s(e))throw new i("imageToArrayBuffer","Unsupported image type");const r=async t=>{if(!t)throw new i("imageToArrayBuffer","Unable to convert image to PNG");const e=new FileReader,s=new Promise((t=>{e.addEventListener("loadend",(()=>{t(e.result)}))}));return e.readAsArrayBuffer(t),s};if(e.toBlob)return new Promise(((t,s)=>{e.toBlob((e=>{r(e).then(t,s)}),"image/png")}));if("msToBlob"in e)return r(e.msToBlob());throw new i("imageToArrayBuffer","Could not convert canvas to blob")}function G(t){if(t instanceof HTMLCanvasElement)return t;if(t instanceof HTMLVideoElement)return null;const e=document.createElement("canvas");e.width=t.width,e.height=t.height;const s=e.getContext("2d");return t instanceof HTMLImageElement?s.drawImage(t,0,0,t.width,t.height):t instanceof ImageData&&s.putImageData(t,t.width,t.height),e}class D{constructor(t,e,s){this.params={},this.materialMap=new Array,this.gltf={asset:{version:"2.0",copyright:t.copyright,generator:t.generator},extras:{options:e,binChunkBuffer:null,promises:[]}},s&&(this.params=s),this.addScenes(t)}addScenes(t){this.gltf.scene=t.defaultScene;const e=this.gltf.extras.options.bufferOutputType===R.GLB||this.gltf.extras.options.imageOutputType===N.GLB;e&&(this.gltf.extras.binChunkBuffer=new C(this.gltf)),t.forEachScene((t=>{this.addScene(t)})),e&&this.gltf.extras.binChunkBuffer.finalize()}addScene(t){this.gltf.scenes||(this.gltf.scenes=[]);const e={};t.name&&(e.name=t.name),t.forEachNode((t=>{e.nodes||(e.nodes=[]);const s=this.addNode(t);e.nodes.push(s)})),this.gltf.scenes.push(e)}addNode(t){this.gltf.nodes||(this.gltf.nodes=[]);const e={};t.name&&(e.name=t.name);const s=t.translation;d(s,c)||(e.translation=h(s));const r=t.rotation;w(r,A)||(e.rotation=b(r));const i=t.scale;d(i,u)||(e.scale=h(i)),t.mesh&&t.mesh.vertexAttributes.position?e.mesh=this.addMesh(t.mesh):t.forEachNode((t=>{e.children||(e.children=[]);const s=this.addNode(t);e.children.push(s)}));const o=this.gltf.nodes.length;return this.gltf.nodes.push(e),o}addMesh(t){this.gltf.meshes||(this.gltf.meshes=[]);const e={primitives:[]},s=this.gltf.extras.options.bufferOutputType===R.GLB;let r;r=s?this.gltf.extras.binChunkBuffer:new C(this.gltf);const i=t.clone();this.params.origin||(this.params.origin=function(t){const e=t.extent.xmax-t.extent.width/2,s=t.extent.ymax-t.extent.height/2,r=t.extent.zmin;return new o({x:e,y:s,z:r,spatialReference:t.extent.spatialReference})}(i)),i.rotate(-90,0,0,{origin:this.params.origin}),function(t){if(t.components){for(const e of t.components)"smooth"===e.shading&&e.faces&&_(t,e);t.vertexAttributesChanged()}}(i);const n=E(i.vertexAttributes,this.params.origin,{geographic:this.params.geographic,unit:"meters"});i.vertexAttributes.position=n.position,i.vertexAttributes.normal=n.normal,i.vertexAttributes.tangent=n.tangent;const a=r.addBufferView(v.FLOAT,I.VEC3,S.ARRAY_BUFFER);let c,h,u,l;i.vertexAttributes.normal&&(c=r.addBufferView(v.FLOAT,I.VEC3,S.ARRAY_BUFFER)),i.vertexAttributes.uv&&(h=r.addBufferView(v.FLOAT,I.VEC2,S.ARRAY_BUFFER)),i.vertexAttributes.tangent&&(u=r.addBufferView(v.FLOAT,I.VEC4,S.ARRAY_BUFFER)),i.vertexAttributes.color&&(l=r.addBufferView(v.UNSIGNED_BYTE,I.VEC4,S.ARRAY_BUFFER)),a.startAccessor("POSITION"),c&&c.startAccessor("NORMAL"),h&&h.startAccessor("TEXCOORD_0"),u&&u.startAccessor("TANGENT"),l&&l.startAccessor("COLOR_0");const f=i.vertexAttributes.position.length/3;for(let t=0;t<f;++t)a.push(i.vertexAttributes.position[3*t+0]),a.push(i.vertexAttributes.position[3*t+1]),a.push(i.vertexAttributes.position[3*t+2]),c&&(c.push(i.vertexAttributes.normal[3*t+0]),c.push(i.vertexAttributes.normal[3*t+1]),c.push(i.vertexAttributes.normal[3*t+2])),h&&(h.push(i.vertexAttributes.uv[2*t+0]),h.push(i.vertexAttributes.uv[2*t+1])),u&&(u.push(i.vertexAttributes.tangent[4*t+0]),u.push(i.vertexAttributes.tangent[4*t+1]),u.push(i.vertexAttributes.tangent[4*t+2]),u.push(i.vertexAttributes.tangent[4*t+3])),l&&(l.push(i.vertexAttributes.color[4*t+0]),l.push(i.vertexAttributes.color[4*t+1]),l.push(i.vertexAttributes.color[4*t+2]),l.push(i.vertexAttributes.color[4*t+3]));const m=a.endAccessor(),p=this.addAccessor(a.index,m);let d,g,A,b,x;if(c){const t=c.endAccessor();d=this.addAccessor(c.index,t)}if(h){const t=h.endAccessor();g=this.addAccessor(h.index,t)}if(u){const t=u.endAccessor();A=this.addAccessor(u.index,t)}if(l){const t=l.endAccessor();b=this.addAccessor(l.index,t)}i.components&&i.components.length>0&&i.components[0].faces?(x=r.addBufferView(v.UNSIGNED_INT,I.SCALAR,S.ELEMENT_ARRAY_BUFFER),this.addMeshVertexIndexed(x,i.components,e,p,d,g,A,b)):this.addMeshVertexNonIndexed(i.components,e,p,d,g,A,b),a.finalize(),c&&c.finalize(),h&&h.finalize(),u&&u.finalize(),x&&x.finalize(),l&&l.finalize(),s||r.finalize();const w=this.gltf.meshes.length;return this.gltf.meshes.push(e),w}addMaterial(t){if(null===t)return;const e=this.materialMap.indexOf(t);if(-1!==e)return e;this.gltf.materials||(this.gltf.materials=[]);const s={};switch(t.alphaMode){case"mask":s.alphaMode=O.MASK;break;case"auto":case"blend":s.alphaMode=O.BLEND}.5!==t.alphaCutoff&&(s.alphaCutoff=t.alphaCutoff),t.doubleSided&&(s.doubleSided=t.doubleSided),s.pbrMetallicRoughness={};const r=t=>t**2.1,i=t=>{const e=t.toRgba();return e[0]=r(e[0]/255),e[1]=r(e[1]/255),e[2]=r(e[2]/255),e};if(t.color&&(s.pbrMetallicRoughness.baseColorFactor=i(t.color)),t.colorTexture&&(s.pbrMetallicRoughness.baseColorTexture={index:this.addTexture(t.colorTexture)}),t.normalTexture&&(s.normalTexture={index:this.addTexture(t.normalTexture)}),t instanceof g){if(t.emissiveTexture&&(s.emissiveTexture={index:this.addTexture(t.emissiveTexture)}),t.emissiveColor){const e=i(t.emissiveColor);s.emissiveFactor=[e[0],e[1],e[2]]}t.occlusionTexture&&(s.occlusionTexture={index:this.addTexture(t.occlusionTexture)}),t.metallicRoughnessTexture&&(s.pbrMetallicRoughness.metallicRoughnessTexture={index:this.addTexture(t.metallicRoughnessTexture)}),s.pbrMetallicRoughness.metallicFactor=t.metallic,s.pbrMetallicRoughness.roughnessFactor=t.roughness}else s.pbrMetallicRoughness.metallicFactor=1,s.pbrMetallicRoughness.roughnessFactor=1;const o=this.gltf.materials.length;return this.gltf.materials.push(s),this.materialMap.push(t),o}addTexture(t){this.gltf.textures||(this.gltf.textures=[]);const e={sampler:this.addSampler(t),source:this.addImage(t)},s=this.gltf.textures.length;return this.gltf.textures.push(e),s}addImage(t){this.gltf.images||(this.gltf.images=[]);const s={};if(t.url)s.uri=t.url;else{s.extras=t.data;for(let e=0;e<this.gltf.images.length;++e)if(t.data===this.gltf.images[e].extras)return e;switch(this.gltf.extras.options.imageOutputType){case N.GLB:{const e=this.gltf.extras.binChunkBuffer.addBufferView(v.UNSIGNED_BYTE,I.SCALAR);e.writeAsync(F(t.data)).then((()=>{e.finalize()})),s.bufferView=e.index,s.mimeType="image/png";break}case N.DataURI:s.uri=function(t){const s=G(t);return e(s)?s.toDataURL():""}(t.data);break;default:this.gltf.extras.promises.push(F(t.data).then((t=>{s.uri=t})))}}const r=this.gltf.images.length;return this.gltf.images.push(s),r}addSampler(t){this.gltf.samplers||(this.gltf.samplers=[]);let e=10497,s=10497;if("string"==typeof t.wrap)switch(t.wrap){case"clamp":e=33071,s=33071;break;case"mirror":e=33648,s=33648}else{switch(t.wrap.vertical){case"clamp":s=33071;break;case"mirror":s=33648}switch(t.wrap.horizontal){case"clamp":e=33071;break;case"mirror":e=33648}}const r={wrapS:e,wrapT:s};for(let t=0;t<this.gltf.samplers.length;++t)if(JSON.stringify(r)===JSON.stringify(this.gltf.samplers[t]))return t;const i=this.gltf.samplers.length;return this.gltf.samplers.push(r),i}addAccessor(t,e){this.gltf.accessors||(this.gltf.accessors=[]);const s={bufferView:t,byteOffset:e.byteOffset,componentType:e.componentType,count:e.count,type:e.type,min:e.min,max:e.max,name:e.name};e.normalized&&(s.normalized=!0);const r=this.gltf.accessors.length;return this.gltf.accessors.push(s),r}addMeshVertexIndexed(t,e,s,r,i,o,n,a){for(const c of e){t.startAccessor("INDICES");for(let e=0;e<c.faces.length;++e)t.push(c.faces[e]);const e=t.endAccessor(),h={attributes:{POSITION:r},indices:this.addAccessor(t.index,e),material:this.addMaterial(c.material)};i&&"flat"!==c.shading&&(h.attributes.NORMAL=i),o&&(h.attributes.TEXCOORD_0=o),n&&"flat"!==c.shading&&(h.attributes.TANGENT=n),a&&(h.attributes.COLOR_0=a),s.primitives.push(h)}}addMeshVertexNonIndexed(t,e,s,r,i,o,n){const a={attributes:{POSITION:s}};r&&(a.attributes.NORMAL=r),i&&(a.attributes.TEXCOORD_0=i),o&&(a.attributes.TANGENT=o),n&&(a.attributes.COLOR_0=n),t&&(a.material=this.addMaterial(t[0].material)),e.primitives.push(a)}}class k{constructor(){this.copyright="",this.defaultScene=0,this.generator="",this._scenes=[]}addScene(t){if(this._scenes.indexOf(t)>=0)throw new Error("Scene already added");this._scenes.push(t)}removeScene(t){const e=this._scenes.indexOf(t);e>=0&&this._scenes.splice(e,1)}forEachScene(t){this._scenes.forEach(t)}}class H{constructor(){this.name="",this.nodes=[]}addNode(t){if(this.nodes.indexOf(t)>=0)throw new Error("Node already added");this.nodes.push(t)}forEachNode(t){this.nodes.forEach(t)}}class Y{constructor(){this.name="",this.mesh=null,this.translation=a(),this.rotation=x(),this.scale=h(u),this.nodes=[]}addNode(t){if(this.nodes.indexOf(t)>=0)throw new Error("Node already added");this.nodes.push(t)}forEachNode(t){this.nodes.forEach(t)}set rotationAngles(t){T(this.rotation,t[0],t[1],t[2])}}function W(t,e,s){const i=new D(t,e=e||{},s);let n=i.params;n?n.origin||(n.origin=new o({x:-1,y:-1,z:-1})):n={origin:new o({x:-1,y:-1,z:-1})};const a=n.origin,c=i.gltf,h=c.extras.promises;let u=1,l=1,f=null;return r(h).then((()=>{const t={origin:a};delete c.extras;const s="number"==typeof e.jsonSpacing?e.jsonSpacing:4,r=JSON.stringify(c,((s,r)=>{if("extras"!==s){if(r instanceof ArrayBuffer){if(function(t){if(t.byteLength<8)return!1;const e=new Uint8Array(t);return 137===e[0]&&80===e[1]&&78===e[2]&&71===e[3]&&13===e[4]&&10===e[5]&&26===e[6]&&10===e[7]}(r))switch(e.imageOutputType){case N.DataURI:case N.GLB:break;case N.External:default:{const e=`img${l}.png`;return l++,t[e]=r,e}}switch(e.bufferOutputType){case R.DataURI:return function(t){const e=[],s=new Uint8Array(t);for(let t=0;t<s.length;t++)e.push(String.fromCharCode(s[t]));return"data:application/octet-stream;base64,"+btoa(e.join(""))}(r);case R.GLB:if(f)throw new Error("Already encountered an ArrayBuffer, there should only be one in the GLB format.");return void(f=r);case R.External:default:{const e=`data${u}.bin`;return u++,t[e]=r,e}}}return r}}),s);return e.bufferOutputType===R.GLB||e.imageOutputType===N.GLB?t["model.glb"]=new y(r,f).buffer:t["model.gltf"]=r,t}))}class K{constructor(t,e){this.file={type:"model/gltf-binary",data:t},this.origin=e}buffer(){return Promise.resolve(this.file)}download(t){return new Promise((()=>{const e=new Blob([this.file.data],{type:this.file.type});let s=t;s||(s="model.glb");if("glb"!==s.split(".").pop()&&(s+=".glb"),window.navigator.msSaveOrOpenBlob)window.navigator.msSaveOrOpenBlob(e,s);else{const t=document.createElement("a"),r=URL.createObjectURL(e);t.href=r,t.download=s,document.body.appendChild(t),t.click(),setTimeout((function(){document.body.removeChild(t),window.URL.revokeObjectURL(r)}),0)}}))}}function Z(t,e){const s=new k,r=new H;s.addScene(r);const i=new Y;return r.addNode(i),i.mesh=t,function(t,e){return W(t,{bufferOutputType:R.GLB,imageOutputType:N.GLB,jsonSpacing:0},e)}(s,e).then((t=>new K(t["model.glb"],t.origin)))}export{Z as toBinaryGLTF};
