/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.19/esri/copyright.txt for details.
*/
import{_ as e}from"./tslib.es6.js";import"../core/lang.js";import{i as t,L as a,u as r}from"./Logger.js";import{property as i}from"../core/accessorSupport/decorators/property.js";import{p as n}from"../core/scheduling.js";import{throwIfAborted as s,createAbortController as o,timeout as l,eachAlways as u}from"../core/promiseUtils.js";import c from"../core/Error.js";import"./ensureType.js";import{subclass as m}from"../core/accessorSupport/decorators/subclass.js";import{a as d}from"./JSONSupport.js";import{L as p}from"./Loadable.js";import"../core/urlUtils.js";import"./resourceExtension.js";import{m as h,g as f}from"../geometry/SpatialReference.js";import y from"../request.js";import g from"../geometry/Point.js";import"../geometry.js";import{l as F}from"./arcadeOnDemand.js";import{isNumericField as v,numericTypes as x,isDateField as w,getField as S}from"../layers/support/fieldUtils.js";import _ from"../Graphic.js";import{fromJSON as V}from"../renderers/support/jsonUtils.js";import{whenFalseOnce as b}from"../core/watchUtils.js";import{b as z}from"./arcgisLayerUrl.js";import E from"../tasks/support/FeatureSet.js";import{D as T}from"./DataLayerSource.js";import q,{Q as L}from"../tasks/support/Query.js";import M from"../tasks/support/StatisticDefinition.js";import{C as j,a as C}from"./ClassBreaksDefinition.js";import I from"../tasks/Task.js";import k from"../tasks/QueryTask.js";import{g as P,i as B,c as D,a as Q}from"./utils5.js";import{t as N,q as R}from"./quantizationUtils.js";import{g as A,a as O,n as U}from"./predominanceUtils.js";import{c as G,a as $}from"./heatmapUtils.js";function W(e,t){return Number(e.toFixed(t))}function H(e){const{normalizationTotal:t}=e;return{classBreaks:function(e){const t=e.definition,{classificationMethod:a,breakCount:r,normalizationType:i,definedInterval:n}=t,s=[];let o=e.values;if(0===o.length)return[];o=o.sort(((e,t)=>e-t));const l=o[0],u=o[o.length-1];if("equal-interval"===a)if(o.length>=r){const e=(u-l)/r;let t=l;for(let a=1;a<r;a++){const r=W(l+a*e,6);s.push({minValue:t,maxValue:r,label:J(t,r,i)}),t=r}s.push({minValue:t,maxValue:u,label:J(t,u,i)})}else o.forEach((e=>{s.push({minValue:e,maxValue:e,label:J(e,e,i)})}));else if("natural-breaks"===a){const t=Y(o),a=e.valueFrequency||t.valueFrequency,n=function(e,t,a){const r=e.length,i=[];a>r&&(a=r);for(let e=0;e<a;e++)i.push(Math.round(e*r/a-1));i.push(r-1);let n=Z(i,e,t,a);(function(e,t,a,r,i,n){let s=0,o=0,l=0,u=0,c=!0;for(let m=0;m<2&&c;m++){0===m&&(c=!1);for(let m=0;m<n-1;m++)for(;a[m+1]+1!==a[m+2];){a[m+1]=a[m+1]+1;const n=X(m,a,r,i);l=n.sbMean,s=n.sbSdcm;const d=X(m+1,a,r,i);if(u=d.sbMean,o=d.sbSdcm,!(s+o<t[m]+t[m+1])){a[m+1]=a[m+1]-1;break}t[m]=s,t[m+1]=o,e[m]=l,e[m+1]=u,c=!0}for(let m=n-1;m>0;m--)for(;a[m]!==a[m-1]+1;){a[m]=a[m]-1;const n=X(m-1,a,r,i);l=n.sbMean,s=n.sbSdcm;const d=X(m,a,r,i);if(u=d.sbMean,o=d.sbSdcm,!(s+o<t[m-1]+t[m])){a[m]=a[m]+1;break}t[m-1]=s,t[m]=o,e[m-1]=l,e[m]=u,c=!0}}return c})(n.mean,n.sdcm,i,e,t,a)&&(n=Z(i,e,t,a));return i}(t.uniqueValues,a,r);let c=l;for(let e=1;e<r;e++)if(t.uniqueValues.length>e){const a=W(t.uniqueValues[n[e]],6);s.push({minValue:c,maxValue:a,label:J(c,a,i)}),c=a}s.push({minValue:c,maxValue:u,label:J(c,u,i)})}else if("quantile"===a)if(o.length>=r&&l!==u){let e=l,t=Math.ceil(o.length/r),a=0;for(let n=1;n<r;n++){let l=t+a-1;l>o.length&&(l=o.length-1),l<0&&(l=0),s.push({minValue:e,maxValue:o[l],label:J(e,o[l],i)}),e=o[l],a+=t,t=Math.ceil((o.length-a)/(r-n))}s.push({minValue:e,maxValue:u,label:J(e,u,i)})}else{let e=-1;for(let t=0;t<o.length;t++){const a=o[t];a!==e&&(e=a,s.push({minValue:e,maxValue:a,label:J(e,a,i)}),e=a)}}else if("standard-deviation"===a){const e=function(e){let t=0;for(let a=0;a<e.length;a++)t+=e[a];return t/=e.length,t}(o),t=function(e,t){let a=0;for(let r=0;r<e.length;r++){const i=e[r];a+=(i-t)*(i-t)}a/=e.length;return Math.sqrt(a)}(o,e);if(0===t)s.push({minValue:o[0],maxValue:o[0],label:J(o[0],o[0],i)});else{const a=function(e,t,a,r,i){const n=Math.max(r-e,t-r);let s=n/i/a;s=s>=1?1:s>=.5?.5:.25;return s}(l,u,r,e,t)*t;let n=0,o=l;for(let t=r;t>=1;t--){const r=W(e-(t-.5)*a,6);s.push({minValue:o,maxValue:r,label:J(o,r,i)}),o=r,n++}let c=W(e+.5*a,6);s.push({minValue:o,maxValue:c,label:J(o,c,i)}),o=c,n++;for(let t=1;t<=r;t++)c=n===2*r?u:W(e+(t+.5)*a,6),s.push({minValue:o,maxValue:c,label:J(o,c,i)}),o=c,n++}}else if("defined-interval"===a){if(!n)return s;const e=o[0],t=o[o.length-1],a=Math.ceil((t-e)/n);let r=e;for(let t=1;t<a;t++){const a=W(e+t*n,6);s.push({minValue:r,maxValue:a,label:J(r,a,i)}),r=a}s.push({minValue:r,maxValue:t,label:J(r,t,i)})}return s}(e),normalizationTotal:t}}function J(e,t,a){let r=null;return r=e===t?a&&"percent-of-total"===a?e+"%":e.toString():a&&"percent-of-total"===a?e+"% - "+t+"%":e+" - "+t,r}function Y(e){const t=[],a=[];let r=Number.MIN_VALUE,i=1,n=-1;for(let s=0;s<e.length;s++){const o=e[s];o===r?(i++,a[n]=i):null!==o&&(t.push(o),r=o,i=1,a.push(i),n++)}return{uniqueValues:t,valueFrequency:a}}function Z(e,t,a,r){let i=[],n=[],s=[],o=0;const l=[],u=[];for(let i=0;i<r;i++){const r=X(i,e,t,a);l.push(r.sbMean),u.push(r.sbSdcm),o+=u[i]}let c,m=o,d=!0;for(;d||o<m;){d=!1,i=[];for(let t=0;t<r;t++)i.push(e[t]);for(let a=0;a<r;a++)for(let i=e[a]+1;i<=e[a+1];i++)if(c=t[i],a>0&&i!==e[a+1]&&Math.abs(c-l[a])>Math.abs(c-l[a-1]))e[a]=i;else if(a<r-1&&e[a]!==i-1&&Math.abs(c-l[a])>Math.abs(c-l[a+1])){e[a+1]=i-1;break}m=o,o=0,n=[],s=[];for(let i=0;i<r;i++){n.push(l[i]),s.push(u[i]);const r=X(i,e,t,a);l[i]=r.sbMean,u[i]=r.sbSdcm,o+=u[i]}}if(o>m){for(let t=0;t<r;t++)e[t]=i[t],l[t]=n[t],u[t]=s[t];o=m}return{mean:l,sdcm:u}}function X(e,t,a,r){let i=0,n=0;for(let s=t[e]+1;s<=t[e+1];s++){const e=r[s];i+=a[s]*e,n+=e}n<=0&&console.log("Exception in Natural Breaks calculation");const s=i/n;let o=0;for(let i=t[e]+1;i<=t[e+1];i++)o+=r[i]*(a[i]-s)**2;return{sbMean:s,sbSdcm:o}}function K(e){const t=e.field,a=e.normalizationType,r=e.normalizationField;let i;return"log"===a?i="(NOT "+t+" = 0)":"field"===a?i="(NOT "+r+" = 0)":"natural-log"!==a&&"square-root"!==a||(i=`(${t} > 0)`),i}function ee(e,t){return new c(e,t)}function te(e,t,a){const r=null!=t?e+" >= "+t:"",i=null!=a?e+" <= "+a:"";let n="";return n=r&&i?ie(r,i):r||i,n?"("+n+")":""}function ae(e,t,a,r){let i=null;return t?t.name!==e.objectIdField&&-1!==r.indexOf(t.type)||(i=ee(a,"'field' should be one of these types: "+r.join(","))):i=ee(a,"'field' is not defined in the layer schema"),i}function re(e,t,a){let r;return t?t.name!==e.objectIdField&&v(t)||(r=ee(a,"'field' should be one of these numeric types: "+x.join(","))):r=ee(a,"'field' is not defined in the layer schema"),r}function ie(e,a){let r=t(e)?e:"";return t(a)&&a&&(r=r?"("+r+") AND ("+a+")":a),r}function ne(e,t,a){const r=function(e){const t=e.layer;return e.fields.filter((e=>!t.getField(e)))}({layer:e,fields:t});if(r.length)return ee(a,"Unknown fields: "+r.join(", ")+". You can only use fields defined in the layer schema");const i=function(e){const t=e.layer;return e.fields.filter((e=>{const a=t.getFieldUsageInfo(e);return!a||!a.supportsStatistics}))}({layer:e,fields:t});return i.length?ee(a,"Unsupported fields: "+i.join(", ")+". You can only use fields that can be fetched i.e. AdapterFieldUsageInfo.supportsStatistics must be true"):void 0}let se=class extends p{constructor(e){super(e)}};e([i({constructOnly:!0})],se.prototype,"layer",void 0),e([i()],se.prototype,"geometryType",void 0),e([i()],se.prototype,"objectIdField",void 0),e([i()],se.prototype,"supportsSQLExpression",void 0),e([i()],se.prototype,"hasQueryEngine",void 0),e([i()],se.prototype,"minScale",void 0),e([i()],se.prototype,"maxScale",void 0),e([i()],se.prototype,"fullExtent",void 0),se=e([m("esri.smartMapping.support.adapters.LayerAdapter")],se);var oe=se;const le=/_value$/i,ue=/\s*(\+|-)?((\d+(\.\d+)?)|(\.\d+))\s*/gi,ce=Math.LOG10E,me=["min","max","avg","stddev","count","sum","variance"];let de=null;async function pe(e,t,a){const r=[];if(t)for(const i of t){const t=e.getField(i);"availableFields"in a&&-1===a.availableFields.indexOf(t.name)&&r.push(t.name)}return r}function he(e,t){const a=e&&e.features,r=a&&a[0]&&a[0].attributes,i={};for(const e in r)i[e.replace(le,"").toLowerCase()]=r[e];return i.min===i.max&&null!=i.min&&null==i.stddev&&(i.stddev=i.variance=0),t&&(["min","max","avg","stddev","sum","variance"].forEach((e=>{null!=i[e]&&(i[e]=Math.ceil(i[e]))})),i.min===i.max&&null!=i.min&&(i.avg=i.min,i.stddev=i.variance=0)),i}async function fe(e,t,a){let r=await ge(e,t);r=ye(r,e.minValue,e.maxValue);const i=function(e,t){let a=Number.POSITIVE_INFINITY,r=Number.NEGATIVE_INFINITY,i=null,n=null,s=null,o=null;for(const t of e)i+=t,a=Math.min(a,t),r=Math.max(r,t);const l=e.length;if(l){n=i/l;let a=0;for(const t of e)a+=(t-n)**2;o=t?l>1?a/(l-1):0:l>0?a/l:0,s=Math.sqrt(o)}else a=null,r=null;return{avg:n,count:l,max:r,min:a,stddev:s,sum:i,variance:o}}(r,!e.normalizationType);return a&&["avg","stddev","variance"].forEach((e=>{null!=i[e]&&(i[e]=Math.ceil(i[e]))})),i}function ye(e,t,a){return t=null==t?-1/0:t,a=null==a?1/0:a,e.filter((e=>null!=e&&ke(e)&&e>=t&&e<=a))}async function ge(e,t){const a=e.field,r="function"==typeof a,i=e.valueExpression,n=e.normalizationType,s=e.normalizationField,o=e.normalizationTotal,l=[],u=e.view;let c=null,m=null;if(i){if(!de){const{arcadeUtils:e}=await F();de=e}c=de.createFunction(i),m=u&&de.getViewInfo({viewingMode:"2d"===u.type?"map":u.viewingMode,scale:u.scale,spatialReference:u.spatialReference})}return t?(t.forEach((e=>{const t=e.attributes;let u;if(i){const t=de.createExecContext(e,m);u=de.executeFunction(c,t)}else r?u=a.call(null,e):t&&(u=t[a]);if(n&&null!=u&&ke(u)){const e=t&&parseFloat(t[s]),a=u;u=null,"log"===n&&0!==a?u=Math.log(a)*Math.LOG10E:"percent-of-total"===n&&ke(o)&&0!==o?u=a/o*100:"field"===n&&ke(e)&&0!==e?u=a/e:"natural-log"===n&&a>0?u=Math.log(a):"square-root"===n&&a>0&&(u=a**.5)}l.push(u)})),l):l}function Fe(e){let t;for(t in e)me.indexOf(t)>-1&&(ke(e[t])||(e[t]=null));return e}function ve(e){const t=e.field,a=e.classificationMethod||"equal-interval",r=e.normalizationType,i=e.normalizationField,n=new j;return n.classificationField=t,n.breakCount=e.breakCount,n.classificationMethod=a,n.standardDeviationInterval="standard-deviation"===a?e.standardDeviationInterval||1:void 0,n.normalizationType=r,n.normalizationField="field"===r?i:void 0,n}async function xe(e,t){const a=e.normalizationTotal,r=ve({field:e.field,normalizationType:e.normalizationType,normalizationField:e.normalizationField,classificationMethod:e.classificationMethod,standardDeviationInterval:e.standardDeviationInterval,breakCount:e.numClasses||5});let i=await ge(e,t);i=ye(i,e.minValue,e.maxValue);return we(e,H({definition:r,values:i,normalizationTotal:a}))}function we(e,t){let a=t.classBreaks;const r=a.length,i=a[0].minValue,n=a[r-1].maxValue,s="standard-deviation"===e.classificationMethod,o=ue;return a=a.map((e=>{const t=e.label,a={minValue:e.minValue,maxValue:e.maxValue,label:t};if(s&&t){const e=t.match(o).map((e=>+e.trim()));2===e.length?(a.minStdDev=e[0],a.maxStdDev=e[1],e[0]<0&&e[1]>0&&(a.hasAvg=!0)):1===e.length&&(t.indexOf("<")>-1?(a.minStdDev=null,a.maxStdDev=e[0]):t.indexOf(">")>-1&&(a.minStdDev=e[0],a.maxStdDev=null))}return a})),{minValue:i,maxValue:n,classBreakInfos:a,normalizationTotal:t.normalizationTotal}}function Se(e,t,a){const r=(t-e)/a,i=[];let n,s=e;for(let e=1;e<=a;e++)n=s+r,n=Number(n.toFixed(16)),i.push([s,e===a?t:n]),s=n;return i}function _e(e){const t=[],a=e.classBreaks,r=a[0].minValue,i=a[a.length-1].maxValue;a.forEach((e=>{t.push([e.minValue,e.maxValue])}));const n={field:e.field,normalizationType:e.normalizationType,normalizationField:e.normalizationField,normalizationTotal:e.normalizationTotal,layer:e.layer};return{min:r,max:i,intervals:t,sqlExpr:Ve(n),excludeZerosExpr:e.where,normTotal:e.normalizationTotal}}function Ve(e){const{field:t,normalizationType:a,normalizationField:r,normalizationTotal:i,layer:n}=e,s=B(n,t);let o=t;return"percent-of-total"===a?o=`((${s?D(t):t} / ${i}) * 100)`:"log"===a?o=`(log(${t}) * ${ce})`:"field"===a?o=`(${s?D(t):t} / ${r})`:"natural-log"===a?o=`(log(${s?D(t):t}))`:"square-root"===a&&(o=`(power(${s?D(t):t}, 0.5))`),o}async function be(e,t,a){const{min:r,max:i,normTotal:n}=t,s=e.numBins||10,o=t.intervals||Se(r,i,s),l=o.map(((e,t)=>({minValue:o[t][0],maxValue:o[t][1],count:0}))),u=await ge(e,a);for(const e of u)if(null!=e&&e>=r&&e<=i){const t=ze(o,e);t>-1&&l[t].count++}return{bins:l,minValue:r,maxValue:i,normalizationTotal:n}}function ze(e,t){let a=-1;for(let r=e.length-1;r>=0;r--){if(t>=e[r][0]){a=r;break}}return a}function Ee(e,t){let a;if(t=t.toLowerCase(),e)for(const r in e)if(r.toLowerCase()!==t){a=e[r];break}return a}function Te(e,t){let a;if(t=t.toLowerCase(),e)for(const r in e)if(r.toLowerCase()===t){a=e[r];break}return a}function qe(e,t,a,r,i){const n={},s="countOFExpr";e&&e.features&&e.features.forEach((e=>{const t=e.attributes,a=Ee(t,s),r=Te(t,s);0!==a&&(n[a]=r)}));const o=[];return Se(t,a,r).forEach(((e,t)=>{const a=(t+1).toString();o.push({minValue:e[0],maxValue:e[1],count:n.hasOwnProperty(a)?n[a]:0})})),{bins:o,minValue:t,maxValue:a,normalizationTotal:i}}function Le(e,t,a,r,i){const n=e&&e.features,o="countOF"+(a||"Expr"),l={};let u=!1;if(n.forEach((e=>{const t=e.attributes,r=Te(t,o);let i=a?Te(t,a):Ee(t,o);null===i&&0===r&&(u=!0),(null==i||"string"==typeof i&&""===i.trim())&&(i=null),null==l[i]?l[i]={count:r,data:i}:l[i].count=l[i].count+r})),a&&u){const e=a+" is NULL";return t.queryFeatureCount(e,i).then((e=>(e=e||0,l.null.count=l.null.count+e,Me(l,r)))).catch((()=>(s(i),Me(l,r))))}return Promise.resolve(Me(l,r))}function Me(e,t){if(t)for(const a in e)e[a].label=t[a];return{count:e}}function je(e,t,a){const r=e.count,i=[];if(a&&t&&"coded-value"===t.type){t.codedValues.forEach((e=>{const t=e.code;r.hasOwnProperty(t)||(r[t]={data:t,count:0})}))}for(const e in r){const t=r[e];i.push({value:t.data,count:t.count,label:t.label})}return{uniqueValueInfos:i}}async function Ce(e,t,a){const r=await ge(e,t),i={};for(let e of r)(null==e||"string"==typeof e&&""===e.trim())&&(e=null),null==i[e]?i[e]={count:1,data:e}:i[e].count++;return je({count:i},a,e.returnAllCodedValues)}function Ie(e,t){return P(e,new Date(0),t,"milliseconds").sqlExpression}function ke(e){return"number"==typeof e&&!isNaN(e)&&e!==1/0&&e!==-1/0}let Pe=class extends I{constructor(e){super(e),this._field=null,this.checkValueRange=null,this.gdbVersion=null,this.source=null}get parsedUrl(){const e=this._parseUrl(this.url);return e.path+="/generateRenderer",e}execute(e,t){const{classificationDefinition:a}=e,r={...e.toJSON(),f:"json"};if("esri.tasks.support.ClassBreaksDefinition"===a.declaredClass?this._field=a.classificationField:this._field=a.attributeField,this.source){var i;const e={source:null==(i=this.source)?void 0:i.toJSON()};r.layer=JSON.stringify(e)}this.gdbVersion&&(r.gdbVersion=this.gdbVersion),r.classificationDef&&(r.classificationDef=JSON.stringify(r.classificationDef));let n={query:r};return(this.requestOptions||t)&&(n={...this.requestOptions,...t,...n}),y(this.parsedUrl.path,n).then((e=>this._handleExecuteResponse(e)))}_handleExecuteResponse(e){const t=e&&e.data;if(!t)return;if(!this.checkValueRange){const e=this._processRendererJSON(t);return Promise.resolve(e)}const a=new k({url:this.url}),r=new M({statisticType:"min",onStatisticField:this._field}),i=new M({statisticType:"max",onStatisticField:this._field}),n=new q({outStatistics:[r,i]});return a.execute(n).then((e=>{const a=e.features[0].attributes;let r=null,i=null;for(const e in a)0===e.toLowerCase().indexOf("min")?r=a[e]:i=a[e];return this._processRendererJSON(t,r,i)}))}_processRendererJSON(e,t,a){if("classBreaks"===e.type){const r=V(e);return{classBreaks:r.classBreakInfos.map(((e,i)=>(0===i&&null!=t&&(e.minValue=t),i===r.classBreakInfos.length-1&&null!=a&&(e.maxValue=a),{minValue:e.minValue,maxValue:e.maxValue,label:e.label}))),normalizationTotal:r.normalizationTotal}}return{uniqueValues:e.uniqueValueInfos.map(((r,i)=>(0===i&&null!=t&&(r.value=t),i===e.uniqueValueInfos.length-1&&null!=a&&(r.value=a),{count:r.count,value:r.value,label:r.label})))}}};e([i()],Pe.prototype,"checkValueRange",void 0),e([i()],Pe.prototype,"gdbVersion",void 0),e([i({type:T})],Pe.prototype,"source",void 0),e([i({readOnly:!0})],Pe.prototype,"parsedUrl",null),Pe=e([m("esri.tasks.GenerateRendererTask")],Pe);var Be=Pe;let De=class extends d{constructor(){super(...arguments),this.classificationDefinition=null,this.where=null}};e([i({type:C,json:{read:{source:"classificationDef"},write:{target:"classificationDef"}}})],De.prototype,"classificationDefinition",void 0),e([i({type:String,json:{write:!0}})],De.prototype,"where",void 0),De=e([m("esri.tasks.support.GenerateRendererParameters")],De);var Qe=De;let Ne=class extends C{constructor(){super(...arguments),this.attributeField=null,this.attributeField2=null,this.attributeField3=null,this.fieldDelimiter=null,this.type="unique-value-definition"}get uniqueValueFields(){const e=[];return this.attributeField&&e.push(this.attributeField),this.attributeField2&&e.push(this.attributeField2),this.attributeField3&&e.push(this.attributeField3),e}};e([i()],Ne.prototype,"attributeField",void 0),e([i()],Ne.prototype,"attributeField2",void 0),e([i()],Ne.prototype,"attributeField3",void 0),e([i({json:{write:!0}})],Ne.prototype,"fieldDelimiter",void 0),e([i({json:{write:!0}})],Ne.prototype,"uniqueValueFields",null),e([i()],Ne.prototype,"type",void 0),Ne=e([m("esri.tasks.support.UniqueValueDefinition")],Ne);var Re=Ne;const Ae=a.getLogger("esri.smartMapping.support.adapters.FeatureLayerAdapter");let Oe=class extends oe{constructor(e){super(e)}destroy(){this._hasLocalSource=null}_isStatsSupportedOnService(){const e=this.layer;return!e.get("capabilities.query.supportsStatistics")||"multipatch"===this.geometryType&&!z(e.url)&&e.version<10.5?Promise.reject(new c("feature-layer-adapter:not-supported","Layer does not support statistics query")):Promise.resolve()}async _fetchFeaturesFromMemory(e,t,a){const r=this.layer;if(this._hasLocalSource){return(await r.queryFeatures(t)).features}if(!e)throw new c("feature-layer-adapter:insufficient-data","layerView is required to fetch the features");const i=o(),n=b(e,"updating",i.signal);await l(n,5e3,i).catch((e=>{throw Ae.warn("LayerView is taking too long to update. Aborting fetch from layerView."),e}));return(await e.queryFeatures(t,{signal:a})).features}_fetchFeaturesFromService(e,t){return this.layer.queryFeatures(e,{signal:t}).then((e=>e&&e.features))}_fetchFeaturesForStats(e){return Q({field:e.field,normalizationField:e.normalizationField,valueExpression:e.valueExpression}).then((t=>this.getSampleFeatures({sampleSize:-1,view:e.view,returnGeometry:e.returnGeometry,requiredFields:t,signal:e.signal})))}_summaryStatsFromGenRend(e){const t=e.normalizationType,a=e.normalizationField;return this.classBreaks({field:e.field,numClasses:5,classificationMethod:"standard-deviation",standardDeviationInterval:.25,normalizationType:t,normalizationField:"field"===t?a:void 0,minValue:e.minValue,maxValue:e.maxValue,signal:e.signal}).then((e=>{let t,a,r;if(e.classBreakInfos.some((e=>(e.hasAvg&&(t=e),!!t))),t){const e=t.maxValue-t.minValue;a=t.minValue+e/2,r=4*e}return Fe({min:e.minValue,max:e.maxValue,avg:a,stddev:r})}))}_getSummaryStatsQuery(e,t){const{field:a,normalizationType:r,normalizationField:i,normalizationTotal:n}=e,s=this.supportsSQLExpression&&t?Ie(this,a):e.sqlExpression,o=Ve({field:a,normalizationType:r,normalizationField:i,normalizationTotal:n,layer:this}),l=s||o,u=l?te(l,e.minValue,e.maxValue):null,c=K({field:a,normalizationField:i,normalizationType:r}),m=ie(e.sqlWhere,c),d=ie(m,u),p=this.layer.createQuery();return p.where=ie(p.where,d),p.sqlFormat=s?"standard":null,p.outStatistics=me.map((e=>{const t=new M;return t.statisticType="variance"===e?"var":e,t.onStatisticField=l,t.outStatisticFieldName=e+"_value",t})),p}async _summaryStatsFromServiceQuery(e,t){await this._isStatsSupportedOnService(),"percent-of-total"===e.normalizationType&&(e.normalizationTotal=await this._getNormalizationTotal(e.field,e.normalizationType));const a=this._getSummaryStatsQuery(e,t);return Fe(he(await this.layer.queryFeatures(a,{signal:e.signal}),t))}async _summaryStatsFromClientQuery(e,t){const a=this._getSummaryStatsQuery(e,t);return Fe(he(await this.layer.queryFeatures(a,{signal:e.signal}),t))}async _summaryStatsFromMemory(e,t){const a=e.field,r=e.valueExpression,i=e.view,n={field:a,valueExpression:r,normalizationField:e.normalizationField,view:i,signal:e.signal},s=e.features||await this._fetchFeaturesForStats(n);if(!(s&&s.length))throw new c("feature-layer-adapter:insufficient-data","No features are available to calculate statistics");const o={...e};if("percent-of-total"===o.normalizationType){const e=(await fe({field:a},s)).sum;if(null==e)throw new c("feature-layer-adapter:invalid","invalid normalizationTotal");o.normalizationTotal=e}return Fe(await fe(o,s,t))}_uvFromGenRenderer(e,t){const a=e.field,r=new Re;r.attributeField=a;const i=new Qe;return i.classificationDefinition=r,this.generateRenderer(i,e.signal).then((e=>{const t={},r=this.getField(a);return e.uniqueValues.forEach((e=>{let a=e.value;null!=a&&""!==a&&("string"!=typeof a||""!==a.trim()&&"<null>"!==a.toLowerCase())||(a=null),null==t[a]?t[a]={count:e.count,data:v(r)&&a?Number(a):a}:t[a].count=t[a].count+e.count})),{count:t}})).then((a=>je(a,t,e.returnAllCodedValues)))}_getUVQuery(e){const t=e.field,a=e.sqlExpression,r="countOF"+(t||"Expr"),i=new M;i.statisticType="count",i.onStatisticField=a?"1":t,i.outStatisticFieldName=r;const n=this.layer.createQuery();return n.where=ie(n.where,e.sqlWhere),n.sqlFormat=a?"standard":null,n.outStatistics=[i],n.groupByFieldsForStatistics=[t||a],n}_uvFromServiceQuery(e,t){return this._isStatsSupportedOnService().then((()=>this.layer.queryFeatures(this._getUVQuery(e),{signal:e.signal}))).then((t=>Le(t,this,e.field,null,e.signal))).then((a=>je(a,t,e.returnAllCodedValues)))}async _uvFromClientQuery(e,t){const{signal:a}=e,r=this._getUVQuery(e),i=await this.layer.queryFeatures(r,{signal:a});return je(await Le(i,this,e.field,null,a),t,e.returnAllCodedValues)}async _uvFromMemory(e,t){const{field:a,valueExpression:r,view:i,signal:n}=e,s={field:a,valueExpression:r,view:i,signal:n};return Ce(e,e.features?e.features:await this._fetchFeaturesForStats(s),t)}_calcBinsSQL(e,t,a){const r=[],i=t.length;return t.forEach(((t,n)=>{const[s,o]=t;let l=null;l=0!==n||a?n!==i-1||a?ie(`${e} >= ${s}`,`${e} ${n===i-1?" <= ":" < "} ${o}`):`${e} >= ${s}`:`${e} < ${o}`,r.push("WHEN ("+l+") THEN "+(n+1))})),["CASE",r.join(" "),"ELSE 0","END"].join(" ")}_getNormalizationTotal(e,t,a){return e&&"percent-of-total"===t?this.summaryStatistics({field:e,signal:a}).then((e=>e.sum)):Promise.resolve(null)}_getQueryParamsForExpr(e,t){const a=e.valueExpression||e.sqlExpression,r=e.signal;if(!a){const{field:a,normalizationType:i,normalizationField:n}=e,s=a?this.getField(a):null,o=w(s),l={field:a,normalizationType:i,normalizationField:n,normalizationTotal:t,layer:this};return{sqlExpression:o?Ie(this,a):Ve(l),sqlWhere:o?null:e.sqlWhere||K({field:a,normalizationType:i,normalizationField:n}),signal:r}}return{valueExpression:e.valueExpression,sqlExpression:e.sqlExpression,sqlWhere:e.sqlWhere,signal:r}}_getDataRange(e,t,a){return null!=t&&null!=a?Promise.resolve({min:t,max:a}):this.summaryStatistics(e).then((e=>({min:e.min,max:e.max})))}_histogramForExpr(e){return this._getNormalizationTotal(e.field,e.normalizationType,e.signal).then((t=>{const a=this._getQueryParamsForExpr(e,t);return this._getDataRange(a,e.minValue,e.maxValue).then((r=>{const{min:i,max:n}=r,s=e.numBins||10,o=Se(i,n,s),l=this._calcBinsSQL(a.sqlExpression,o,null!=e.minValue&&null!=e.maxValue),u=new M({statisticType:"count",outStatisticFieldName:"countOFExpr",onStatisticField:"1"}),c=this.layer.createQuery();return c.where=ie(c.where,a.sqlWhere),c.sqlFormat="standard",c.outStatistics=[u],c.groupByFieldsForStatistics=[l],c.orderByFields=[l],this._isStatsSupportedOnService().then((()=>this.layer.queryFeatures(c,{signal:a.signal}))).then((e=>qe(e,i,n,s,t)))}))}))}_histogramForField(e){let t=null;return t=null!=e.minValue&&null!=e.maxValue?Promise.resolve({min:e.minValue,max:e.maxValue}):this.summaryStatistics(e).then((e=>{if(!e.count)throw new c("feature-layer-adapter:insufficient-data","Either the layer has no features or none of the features have data for the field");return{min:e.min,max:e.max}})),t.then((t=>this._getBins({min:t.min,max:t.max},e.field,e.numBins,e.signal)))}_getBins(e,t,a=10,r){const{min:i,max:n,normTotal:s,excludeZerosExpr:o}=e,l=e.intervals||Se(i,n,a),u=e.sqlExpr||t;return this._queryBins(l,u,o,r).then((e=>({bins:e.map(((e,t)=>({minValue:l[t][0],maxValue:l[t][1],count:e.value}))),minValue:i,maxValue:n,normalizationTotal:s})))}_queryBins(e,t,a,r){const i=[],n=e.length;for(let r=0;r<n;r++){const s=ie(a,ie(t+" >= "+e[r][0],null!==e[r][1]?t+(r===n-1?" <= ":" < ")+e[r][1]:""));i.push(s)}return u(i.map((e=>this.queryFeatureCount(e,r))))}_binParamsFromGenRend(e,t){const{field:a,normalizationType:r,normalizationField:i,signal:n}=e,s=K({field:a,normalizationType:r,normalizationField:i}),o=new Qe({classificationDefinition:ve({field:a,normalizationType:r,normalizationField:i,classificationMethod:e.classificationMethod,standardDeviationInterval:e.standardDeviationInterval,breakCount:e.numBins||10}),where:ie(s,t)});return this.generateRenderer(o,n).then((e=>{const{normalizationTotal:t,classBreaks:n}=e;return _e({field:a,normalizationType:r,normalizationField:i,normalizationTotal:t,classBreaks:n,where:s,layer:this})}))}_histogramFromMemory(e){const{field:t,normalizationField:a,normalizationType:r,valueExpression:i,classificationMethod:n,minValue:s,maxValue:o,view:l,signal:u}=e,m={field:t,valueExpression:i,normalizationField:a,view:l,signal:u};return(e.features?Promise.resolve(e.features):this._fetchFeaturesForStats(m)).then((a=>{if(!(a&&a.length))throw new c("feature-layer-adapter:insufficient-data","No features are available to calculate histogram");let m=null;if((!n||"equal-interval"===n)&&!r)m=null!=s&&null!=o?Promise.resolve({min:s,max:o,source:"parameters"}):this.summaryStatistics({field:t,valueExpression:i,features:a,view:l,signal:u}).then((e=>e.count?{min:e.min,max:e.max}:Promise.reject(new c("feature-layer-adapter:insufficient-data","No features are available to calculate histogram"))));else{const t={...e};t.features=a,m=this._getBinParamsFromMemory(t)}return m.then((t=>be(e,t,a)))}))}async _getBinParamsFromMemory(e){const{field:t,valueExpression:a,classificationMethod:r,standardDeviationInterval:i,normalizationType:n,normalizationField:s,minValue:o,maxValue:l,features:u,view:c,signal:m}=e;return this._classBreaksFromMemory({field:t,valueExpression:a,normalizationType:n,normalizationField:s,classificationMethod:r,standardDeviationInterval:i,minValue:o,maxValue:l,numClasses:e.numBins,features:u,view:c,signal:m}).then((e=>{const a=e.normalizationTotal,r=e.classBreakInfos,i=K({field:t,normalizationType:n,normalizationField:s});return _e({field:t,normalizationType:n,normalizationField:s,normalizationTotal:a,classBreaks:r,where:i,layer:this})}))}_classBreaksFromGenRend(e){const{field:t,normalizationType:a,normalizationField:r,normalizationTotal:i,signal:n}=e,s=K({field:t,normalizationType:a,normalizationField:r}),o=te(Ve({field:t,normalizationType:a,normalizationField:r,normalizationTotal:i,layer:this}),e.minValue,e.maxValue),l=ve({field:t,normalizationType:a,normalizationField:r,classificationMethod:e.classificationMethod,standardDeviationInterval:e.standardDeviationInterval,breakCount:e.numClasses||5}),u=new Qe;return u.classificationDefinition=l,u.where=ie(s,o),this.generateRenderer(u,n).then((t=>we(e,t)))}_classBreaksFromInterpolation(e){const{minValue:t,maxValue:a}=e,r=e.numClasses||5,i=[],n=(a-t)/r;for(let e=0;e<r;e++){const a=t+e*n;i.push({minValue:a,maxValue:a+n})}i[r-1].maxValue=a;const s=we(e,{classBreaks:i,normalizationTotal:e.normalizationTotal});return Promise.resolve(s)}async _classBreaksFromMemory(e){const{field:t,normalizationField:a,valueExpression:r,view:i,signal:n}=e,s={field:t,valueExpression:r,normalizationField:a,view:i,signal:n},o=e.features||await this._fetchFeaturesForStats(s);if(!(o&&o.length))throw new c("feature-layer-adapter:insufficient-data","No features are available to calculate statistics");const l={...e};if("percent-of-total"===l.normalizationType){const e=(await fe({field:t},o)).sum;if(null==e)throw new c("feature-layer-adapter:invalid","invalid normalizationTotal");l.normalizationTotal=e}return xe(l,o)}async _heatmapStatsFromMemory(e,t){const{blurRadius:a,field:r,view:i,signal:n}=e,{resolution:s,size:o}=i.state,l=new L({extent:i.extent,tolerance:s}),u=this._quantizeFeatures(e.features||await this._fetchFeaturesForStats({field:r,view:i,returnGeometry:!0,signal:n}),l,i);if(!u||!u.length)return{count:0,min:null,max:null,avg:null,stddev:null};const m=function(e,t=10,a,r,i,n){const s=new Float64Array(i*n),o=G(t),l=Math.round(3*t);let u=Number.POSITIVE_INFINITY,c=Number.NEGATIVE_INFINITY,m=0,d=0,p=0,h=0;const f=$(r,a);for(const{geometry:t,attributes:a}of e){const e=t.x-l,r=t.y-l,y=Math.max(0,e),g=Math.max(0,r),F=Math.min(n,t.y+l),v=Math.min(i,t.x+l),x=+f(a);for(let t=g;t<F;t++){const a=o[t-r];for(let r=y;r<v;r++){const n=o[r-e],l=t*i+r,f=s[l];m=s[l]+=a*n*x;const y=m-f;d+=y,p+=y*y,m<u&&(u=m),m>c&&(c=m),h++}}}if(!h)return{mean:0,stddev:0,min:0,max:0,mid:0,count:0};const y=(c-u)/2;return{mean:d/h,stdDev:Math.sqrt((p-d*d/h)/h),min:u,max:c,mid:y,count:h}}(u,a,t,r,o[0],o[1]);if(m)return{count:m.count,min:m.min,max:m.max,avg:m.mean,stddev:m.stdDev};throw new c("feature-layer-adapter:invalid","unable to calculate heatmap statistics")}_quantizeFeatures(e,t,a){const i=N(t),{spatialReference:n,size:s}=a,o=h(n)?f(n):null,l=o?Math.round((o.valid[1]-o.valid[0])/i.scale[0]):null;return e.map((e=>{const t=new g(r(e.geometry));return R(i,t,t,t.hasZ,t.hasM),e.geometry=o?this._wrapPoint(t,l,s[0]):t,e}))}_wrapPoint(e,t,a){return e.x<0?e.x+=t:e.x>a&&(e.x-=t),e}getField(e=""){return this.layer.getField(e)}getFieldUsageInfo(e){return this.getField(e)?{supportsLabelingInfo:!0,supportsRenderer:!0,supportsPopupTemplate:!0,supportsLayerQuery:!0,supportsStatistics:!0}:null}getFieldDomain(e,t){return this.layer.getFieldDomain(e,t)}summaryStatistics(e){const{field:t,normalizationType:a,sqlExpression:r,view:i,features:n}=e,o=t?this.getField(t):null,l=w(o),u=e.valueExpression||r,m=u&&!r,d=this._hasLocalSource||n,p=i&&"3d"===i.type;if(d||m)return m||n||p?this._summaryStatsFromMemory(e,l):this._summaryStatsFromClientQuery(e,l);if(!this.supportsSQLExpression&&(l||u||"natural-log"===a||"square-root"===a))return Promise.reject(new c("feature-layer-adapter:not-supported","Layer does not support standardized SQL expression for queries"));return(a&&!this.supportsSQLExpression?this._summaryStatsFromGenRend(e):this._summaryStatsFromServiceQuery(e,l)).catch((()=>(s(e.signal),this._summaryStatsFromMemory(e,l))))}uniqueValues(e){const{field:t,valueExpression:a,sqlExpression:r,signal:i}=e,n=(t?this.getField(t):null)&&this.getFieldDomain(t),o=a&&(!r||!this.supportsSQLExpression),l=this._hasLocalSource||e.features||o,u=e.view,c=u&&"3d"===u.type;return l?o||e.features||c?this._uvFromMemory(e,n):this._uvFromClientQuery(e,n):this._uvFromServiceQuery(e,n).catch((t=>(s(i),e.field?this._uvFromGenRenderer(e,n):t))).catch((()=>(s(i),o||e.features||c?this._uvFromMemory(e,n):this._uvFromClientQuery(e,n))))}histogram(e){const{field:t,normalizationType:a,normalizationField:r,classificationMethod:i,signal:n}=e,s=t?this.getField(t):null,o=w(s),l=e.valueExpression||e.sqlExpression,u=l&&!e.sqlExpression,m=this._hasLocalSource||e.features||u,d=this.supportsSQLExpression,p=!i||"equal-interval"===i,h=e.minValue,f=e.maxValue,y=null!=h&&null!=f,g=e.numBins||10;return m?this._histogramFromMemory(e):(l||d)&&p?d||!l&&"natural-log"!==a&&"square-root"!==a?this._histogramForExpr(e):Promise.reject(new c("feature-layer-adapter:not-supported","Layer does not support standardized SQL expression for queries")):o&&p?Promise.reject(new c("feature-layer-adapter:not-supported","Normalization and date field are not allowed when layer does not support standardized SQL expression for queries")):a||!p?this._binParamsFromGenRend(e).then((i=>{if(!y)return this._getBins(i,t,g,n);if(h>i.max||f<i.min)throw new c("histogram:insufficient-data","Range defined by 'minValue' and 'maxValue' does not intersect available data range of the field");if(p)return this._getBins({min:h,max:f,sqlExpr:i.sqlExpr,excludeZerosExpr:i.excludeZerosExpr},t,g,n);{const s=te(Ve({field:t,normalizationType:a,normalizationField:r,normalizationTotal:i.normTotal,layer:this}),h,f);return this._binParamsFromGenRend(e,s).then((e=>this._getBins(e,t,g,n)))}})):this._histogramForField(e)}classBreaks(e){const t=!1!==e.analyzeData,a=this._hasLocalSource||e.features||e.valueExpression;if(t&&a)return this._classBreaksFromMemory(e);return(t?this._classBreaksFromGenRend(e):this._classBreaksFromInterpolation(e)).catch((()=>(s(e.signal),this._classBreaksFromMemory(e))))}queryFeatureCount(e,t){if(this._hasLocalSource)return Promise.reject(new c("feature-layer-adapter:not-supported","Layer does not support count query"));const a=this.layer,r=a.createQuery();return r.where=ie(r.where,e),a.queryFeatureCount(r,{signal:t})}generateRenderer(e,t){const a=this.layer;if(this._hasLocalSource||a.version<10.1)return Promise.reject(new c("feature-layer-adapter:not-supported","Layer does not support generateRenderer operation (requires ArcGIS Server version 10.1+)"));const r=new Be({url:a.parsedUrl.path,source:a.dynamicDataSource,gdbVersion:a.gdbVersion}),i=a.createQuery();return e.where=ie(e.where,i.where),r.execute(e,{signal:t})}heatmapStatistics(e){const{field:t,fieldOffset:a,signal:r}=e;return(t&&null==a?this.summaryStatistics({field:t,signal:r}):Promise.resolve(null)).then((t=>{let r=a||0;if(t){const{count:e,min:a,max:i}=t;e?a===i&&0===a?r=1:i<=0?r="abs":a<0&&(r=-1.01*a):r=1}return this._heatmapStatsFromMemory(e,r).then((e=>({...e,summaryStatistics:t,fieldOffset:r})))}))}async predominantCategories(e){if(!this._hasLocalSource&&!this.supportsSQLExpression)throw new c("feature-layer-adapter:not-supported","Layer does not support advanced SQL expressions and standardized queries");const{fields:t,view:a,signal:r}=e,i=A(t),n=O(t),s=(a&&this._hasLocalSource?await this._uvFromMemory({valueExpression:i,view:a,signal:r}):await this._uvFromServiceQuery({sqlExpression:n.expression,valueExpression:i,signal:r})).uniqueValueInfos,o=s.map((e=>e.value)),l=t.filter((e=>-1===o.indexOf(e)));for(const e of l)s.push({value:e,count:0});s.sort(((e,a)=>t.indexOf(e.value)-t.indexOf(a.value)));for(const e of s)e.value===U&&(e.value=null);return{predominantCategoryInfos:s}}async getSampleFeatures(e){const{view:t,sampleSize:a,requiredFields:r,returnGeometry:i,signal:o}=e,l=this.layer.createQuery();l.outSpatialReference=e.spatialReference||t&&t.spatialReference,l.returnGeometry=!!i,l.outFields=r;let u=[],c=!1;if(t)try{const e=await t.whenLayerView(this.layer);if(c=!(await pe(this,r,e)).length,c&&(u=await this._fetchFeaturesFromMemory(e,l,o),u.length&&a>0&&a<=u.length))return n(u,a,1)}catch(e){s(o)}try{if(this._hasLocalSource)return c?u:this._fetchFeaturesFromService(l,o);const r=await this.queryFeatureCount(null,o),i=this.layer.capabilities.query.maxRecordCount;let s=-1===a?r:a;if(s=i&&s>i?i:s,r<=u.length||u.length>=i)return u;const m=t.extent.width/t.width/t.scale*4e5;if(l.maxAllowableOffset=e.resolution||m,r<=s)return this._fetchFeaturesFromService(l,o);if(r<=2e4){const e=await this.layer.queryObjectIds();return l.objectIds=n(e,s,1),this._fetchFeaturesFromService(l,o)}return this.layer.get("capabilities.query.supportsPagination")&&(l.num=Math.min(s,2e4)),this._fetchFeaturesFromService(l,o)}catch(e){return s(o),u}}load(e){const t=this.layer.load(e).then((e=>{this.geometryType=e.geometryType,this.objectIdField=e.objectIdField,this.supportsSQLExpression=e.get("capabilities.query.supportsSqlExpression"),this._hasLocalSource=!e.url&&!!e.source,this.hasQueryEngine=this._hasLocalSource,this.minScale=e.minScale,this.maxScale=e.maxScale,this.fullExtent=e.fullExtent}));return this.addResolvingPromise(t),Promise.resolve(this)}};e([i({constructOnly:!0})],Oe.prototype,"layer",void 0),Oe=e([m("esri.smartMapping.support.adapters.FeatureLayerAdapter")],Oe);var Ue=Oe;function Ge(e){return"esri.tasks.support.ClassBreaksDefinition"===e.declaredClass}function $e(e){return"esri.tasks.support.UniqueValueDefinition"===e.declaredClass}let We=class extends Ue{constructor(e){super(e)}async _createGenerateRendererResult(e,t,a,r,i){const n=e&&e.features;if(!(n&&n.length))throw new c("csv-layer-adapter:insufficient-data","No features are available to calculate statistics");let s=null;if("percent-of-total"===r){if(s=(await fe({field:t},n)).sum,null==s)throw new c("csv-layer-adapter:invalid","invalid normalizationTotal")}if(Ge(i)){return H({definition:i,values:(await ge({field:t,normalizationType:r,normalizationField:a,normalizationTotal:s},n)).filter((e=>null!=e&&ke(e))),normalizationTotal:s})}if($e(i)){return function(e){const t=Y(e),a=[],r=t.uniqueValues.length;for(let e=0;e<r;e++){const r=t.uniqueValues[e],i=t.valueFrequency[e],n=r.toString();a.push({value:r,count:i,label:n})}return{uniqueValues:a}}((await ge({field:t},n)).filter((e=>null!=e&&"string"==typeof e&&""!==e.trim())))}}generateRenderer(e,t){const a=e.classificationDefinition;let r=null,i=null,n=null;Ge(a)?(r=a.classificationField,i=a.normalizationField,n=a.normalizationType):$e(a)&&(r=a.attributeField);const s=this.layer;return Q({field:r,normalizationField:i}).then((o=>{const l=s.createQuery();return l.returnGeometry=!1,l.outFields=o,l.where=ie(l.where,e.where),s.queryFeatures(l,{signal:t}).then((e=>this._createGenerateRendererResult(e,r,i,n,a)))}))}load(e){const t=this.layer.load(e).then((e=>{this.geometryType=e.geometryType,this.objectIdField=e.objectIdField,this.supportsSQLExpression=!0,this._hasLocalSource=!1,this.hasQueryEngine=!0}));return this.addResolvingPromise(t),Promise.resolve(this)}};We=e([m("esri.smartMapping.support.adapters.CSVLayerAdapter")],We);var He=We;let Je=class extends oe{constructor(e){super(e)}_hasCachedStatistics(e){return this.layer.hasCachedStatistics(e)}_updateQuery(e,t=[],a=[]){if(!a.length)return e;const r=this.layer.objectIdField,i=e.clone(),n=t.filter((e=>{const t=this.layer.getField(e);return-1===a.indexOf(t.name)})),s=n.some((e=>this.layer.getField(e).name===r));return i.outFields=s?n:[...n,r],i}async _fetchFeaturesFromMemory(e,t,a){if(!e)throw new c("scene-layer-adapter:insufficient-data","view is required to fetch the features from layerView");const r=await e.whenLayerView(this.layer),i=o(),n=b(r,"updating",i.signal);await l(n,5e3,i);const s=await pe(this,a,r),u=this._updateQuery(t,a,s),m=(await r.queryFeatures(u)).features;return s.length?r.whenGraphicAttributes(m,s):m}_fetchFeaturesForStats(e){return Q({field:e.field,normalizationField:e.normalizationField,valueExpression:e.valueExpression}).then((t=>this.getSampleFeatures({sampleSize:-1,view:e.view,returnGeometry:e.returnGeometry,requiredFields:t,signal:e.signal})))}_generateFeatureSetForCachedHistogram(e,t=e.minimum,a=e.maximum,r){const i=[];for(let e=0;e<r;e++)i[e]=0;const n=e.counts.length,s=e.minimum,o=e.maximum;for(let l=0;l<n;l++){const u=(l+.5)/n,c=((1-u)*s+u*o-t)/(a-t)*r;c>=0&&c<=r&&(i[c===r?r-1:Math.floor(c)]+=e.counts[l])}const l=[];i.forEach(((e,t)=>{const a=new _({attributes:{}});a.attributes.EXPR_1=t+1,a.attributes.countOFExpr=e,l.push(a)}));const u=new E;return u.features=l,u}_getCachedStatistics(e,t){const a=this.layer;return e.valueExpression||e.sqlExpression||e.sqlWhere||e.minValue||e.maxValue?Promise.reject(new c("scene-layer-adapter:not-supported","This Layer does not support calculating statistics when 'valueExpression', 'sqlExpression', 'sqlWhere', 'minValue' or 'maxValue' is specified")):a.queryCachedStatistics(t&&t.name,{signal:e.signal}).then((e=>{const t=e.stats,{min:a,max:r}=t;let{avg:i,stddev:n,sum:s,variance:o,count:l}=t;return 0===a&&0===r||(i=0===i?null:i,s=0===s?null:s,n=0===n?null:n,o=0===o?null:o,l=0===l?null:l),null==l&&null!=s&&null!=i&&(l=Math.round(s/i)),{avg:i,count:l,max:r,min:a,stddev:n,sum:s,variance:o}}))}async _getSummaryStatisticsFromMemory(e,t){const a={field:e.field,valueExpression:e.valueExpression,normalizationField:e.normalizationField,view:e.view,signal:e.signal},r=e.features?e.features:await this._fetchFeaturesForStats(a);if(!(r&&r.length))throw new c("scene-layer-adapter:insufficient-data","No features are available to calculate statistics");const i=w(t),n={...e};if("percent-of-total"===n.normalizationType){const e=(await fe({field:n.field},r)).sum;if(null==e)throw new c("scene-layer-adapter:invalid","invalid normalizationTotal");n.normalizationTotal=e}return Fe(await fe(n,r,i))}_getCachedStatisticsForUniqueValues(e,t){const a=this.layer,r=t&&t.name,i=t&&this.getFieldDomain(e.field);return e.valueExpression||e.sqlExpression||e.sqlWhere?Promise.reject(new c("scene-layer-adapter:not-supported","This Layer does not support calculating statistics when 'valueExpression', 'sqlExpression' or 'sqlWhere' is specified")):a.queryCachedStatistics(r,{signal:e.signal}).then((i=>{const n=i.stats;if(!n.mostFrequentValues)return Promise.reject();const s=i.labels&&i.labels.labels,o={},l=[],u="countOF"+r;n.mostFrequentValues.forEach((e=>{const i=new _({attributes:{}});i.attributes[r]=t&&t.name!==a.objectIdField&&(v(t)||w(t))?Number(e.value):e.value,i.attributes[u]=e.count,l.push(i)})),s&&s.forEach((e=>{o[e.value]=e.label}));const c=new E;return c.features=l,Le(c,this,e.field,o,e.signal)})).then((t=>je(t,i,e.returnAllCodedValues)))}_getUniqueValuesFromMemory(e,t){const a=t&&this.getFieldDomain(e.field),r={field:e.field,valueExpression:e.valueExpression,view:e.view,signal:e.signal};return(e.features?Promise.resolve(e.features):this._fetchFeaturesForStats(r)).then((t=>Ce(e,t,a)))}_getCachedStatisticsForHistogram(e,t){const a=this.layer;return e.valueExpression||e.sqlExpression||e.sqlWhere||e.normalizationType?Promise.reject(new c("scene-layer-adapter:not-supported","This Layer does not support calculating statistics when 'valueExpression' or 'sqlExpression' or 'sqlWhere' or 'normalizationType' is specified")):a.queryCachedStatistics(t&&t.name,{signal:e.signal}).then((t=>{const a=t.stats,{minValue:r,maxValue:i}=e,n=null!=r?r:a.min,s=null!=i?i:a.max,o=e.numBins||10;return qe(this._generateFeatureSetForCachedHistogram(a.histogram,n,s,o),n,s,o)}))}async _getClassBreaksFromMemory(e){const t={field:e.field,valueExpression:e.valueExpression,normalizationField:e.normalizationField,view:e.view,signal:e.signal},a=e.features?e.features:await this._fetchFeaturesForStats(t);if(!(a&&a.length))throw new c("scene-layer-adapter:insufficient-data","No features are available to calculate statistics");const r={...e};if("percent-of-total"===r.normalizationType){const e=(await fe({field:r.field},a)).sum;if(null==e)throw new c("scene-layer-adapter:invalid","invalid normalizationTotal");r.normalizationTotal=e}return xe(r,a)}_getHistogramFromMemory(e){const t={field:e.field,valueExpression:e.valueExpression,normalizationField:e.normalizationField,view:e.view,signal:e.signal};return(e.features?Promise.resolve(e.features):this._fetchFeaturesForStats(t)).then((t=>{if(!(t&&t.length))throw new c("scene-layer-adapter:insufficient-data","No features are available to calculate histogram");const{field:a,normalizationType:r,valueExpression:i,classificationMethod:n,minValue:s,maxValue:o,view:l}=e;let u=null;if((!n||"equal-interval"===n)&&!r)u=null!=s&&null!=o?Promise.resolve({min:s,max:o}):this.summaryStatistics({field:a,valueExpression:i,features:t,view:l,signal:e.signal}).then((e=>e.count?{min:e.min,max:e.max}:Promise.reject(new c("feature-layer-adapter:insufficient-data","No features are available to calculate histogram"))));else{const a={...e};a.features=t,u=this._getBinParamsFromMemory(a)}return u.then((a=>be(e,a,t)))}))}async _getBinParamsFromMemory(e){const{field:t,valueExpression:a,classificationMethod:r,standardDeviationInterval:i,normalizationType:n,normalizationField:s,minValue:o,maxValue:l,features:u,view:c}=e;return this._getClassBreaksFromMemory({field:t,valueExpression:a,normalizationType:n,normalizationField:s,classificationMethod:r,standardDeviationInterval:i,minValue:o,maxValue:l,numClasses:e.numBins,features:u,view:c}).then((e=>{const a=e.normalizationTotal,r=e.classBreakInfos,i=K({field:t,normalizationType:n,normalizationField:s});return _e({field:t,normalizationType:n,normalizationField:s,normalizationTotal:a,classBreaks:r,where:i,layer:this})}))}getField(e=""){return this.layer.getField(e)}getFieldUsageInfo(e){const t=this.getField(e);if(!t)return null;const a=this.layer.getFieldUsageInfo(t.name);return{supportsLabelingInfo:a.supportsLabelingInfo,supportsPopupTemplate:a.supportsPopupTemplate,supportsRenderer:a.supportsRenderer,supportsLayerQuery:a.supportsLayerQuery,supportsStatistics:!0}}getFieldDomain(e,t){return this._featureLayerAdapter?this._featureLayerAdapter.getFieldDomain(e,t):null}summaryStatistics(e){const t=this.getField(e.field);return this._featureLayerAdapter?this._featureLayerAdapter.summaryStatistics(e):this._hasCachedStatistics(t&&t.name)?this._getCachedStatistics(e,t).catch((()=>(s(e.signal),this._getSummaryStatisticsFromMemory(e,t)))):this._getSummaryStatisticsFromMemory(e,t)}uniqueValues(e){const t=this.getField(e.field);return this._featureLayerAdapter?this._featureLayerAdapter.uniqueValues(e):this._hasCachedStatistics(t&&t.name)?this._getCachedStatisticsForUniqueValues(e,t).catch((()=>(s(e.signal),this._getUniqueValuesFromMemory(e,t)))):this._getUniqueValuesFromMemory(e,t)}histogram(e){const t=this.getField(e.field);return this._featureLayerAdapter?this._featureLayerAdapter.histogram(e):this._hasCachedStatistics(t&&t.name)?this._getCachedStatisticsForHistogram(e,t).catch((()=>(s(e.signal),this._getHistogramFromMemory(e)))):this._getHistogramFromMemory(e)}classBreaks(e){const t=this.getField(e.field);return this._featureLayerAdapter?this._featureLayerAdapter.classBreaks(e):this._hasCachedStatistics(t&&t.name)?Promise.reject(new c("scene-layer-adapter:not-supported","Cached stats not supported")):this._getClassBreaksFromMemory(e)}queryFeatureCount(e,t){return this._featureLayerAdapter?this._featureLayerAdapter.queryFeatureCount(e,t):Promise.reject(new c("scene-layer-adapter:not-supported","SceneLayer without associated FeatureLayer does not support count query"))}generateRenderer(e,t){return this._featureLayerAdapter?this._featureLayerAdapter.generateRenderer(e,t):Promise.reject(new c("scene-layer-adapter:not-supported","SceneLayer without associated FeatureLayer does not support generateRenderer operation"))}heatmapStatistics(e){return this._featureLayerAdapter?this._featureLayerAdapter.heatmapStatistics(e):Promise.reject(new c("scene-layer-adapter:not-supported","SceneLayer without associated FeatureLayer does not support heatmapStatistics operation"))}async predominantCategories(e){if(this._featureLayerAdapter)return this._featureLayerAdapter.predominantCategories(e);throw new c("scene-layer-adapter:not-supported","SceneLayer without associated FeatureLayer does not support predominantCategories")}async getSampleFeatures(e){const{view:t,sampleSize:a,requiredFields:r,returnGeometry:i,signal:o}=e,l=this.layer.createQuery();l.outFields=r,l.returnGeometry=!!i,l.where=null,l.num=a;let u=[];try{if(u=await this._fetchFeaturesFromMemory(t,l,r),u.length&&a>0&&a<=u.length)return n(u,a,1)}catch(e){s(o)}let c=null;if(this._featureLayerAdapter){const t={...e};delete t.view,c=await this._featureLayerAdapter.getSampleFeatures(t)}return c&&c.length?c:n(u,u.length,1)}load(e){const a=this.layer.load(e).then((a=>{const r=a.associatedLayer;if(this.geometryType=a.geometryType,t(r)){this._featureLayerAdapter=new Ue({layer:r});return this._featureLayerAdapter.load(e).then((()=>{this.objectIdField=this._featureLayerAdapter.objectIdField,this.supportsSQLExpression=this._featureLayerAdapter.supportsSQLExpression,this.minScale=this._featureLayerAdapter.minScale,this.maxScale=this._featureLayerAdapter.maxScale,this.fullExtent=this._featureLayerAdapter.fullExtent}))}this.objectIdField=a.objectIdField,this.supportsSQLExpression=!1,this.hasQueryEngine=!1,this.fullExtent=a.fullExtent}));return this.addResolvingPromise(a),Promise.resolve(this)}};e([i({constructOnly:!0})],Je.prototype,"layer",void 0),Je=e([m("esri.smartMapping.support.adapters.SceneLayerAdapter")],Je);var Ye=Je;let Ze=class extends Ye{constructor(e){super(e)}getField(e=""){return S(this.layer.fields,e)}getFieldUsageInfo(e){const t=this.getField(e);if(!t)return null;const a=this._hasCachedStatistics(t.name);return{supportsLabelingInfo:a,supportsPopupTemplate:a,supportsRenderer:a,supportsLayerQuery:!1,supportsStatistics:a}}getFieldDomain(){return null}load(e){const t=this.layer.load(e).then((()=>{this.geometryType="point",this.objectIdField=null,this.supportsSQLExpression=!1,this.hasQueryEngine=!1}));return this.addResolvingPromise(t),Promise.resolve(this)}};Ze=e([m("esri.smartMapping.support.adapters.PointCloudLayerAdapter")],Ze);const Xe={0:{adapter:He,type:"csv",label:"CSVLayer"},2:{adapter:Ue,type:"feature",label:"FeatureLayer"},1:{adapter:Ue,type:"geojson",label:"GeoJSONLayer"},3:{adapter:Ye,type:"scene",label:"SceneLayer"},4:{adapter:Ze,type:"point-cloud",label:"PointCloudLayer"}},Ke=[0,2,1,3,4];function et(e){return e.map((e=>Xe[e].label))}function tt(e,t=Ke){if(e instanceof oe)return e;let a=null;return t.some((t=>{const r=e.type===Xe[t].type;if(r){const r=Xe[t].adapter;a=new r({layer:e})}return r})),a}export{ae as a,re as b,tt as c,et as g,ke as i,ne as v};
