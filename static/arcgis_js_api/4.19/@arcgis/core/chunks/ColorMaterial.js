/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.19/esri/copyright.txt for details.
*/
import{_ as e}from"./tslib.es6.js";import{O as t}from"./ArrayPool.js";import{clone as n,b as r,c as s,t as o}from"../core/lang.js";import{b as i,i as a,d as l}from"./Logger.js";import{P as c}from"../core/scheduling.js";import{E as u}from"./Evented.js";import{i as h}from"./mathUtils2.js";import{c as d,b as f,O as p,f as m,a as g}from"./vec3f64.js";import{s as y,c as b,n as v,b as _,e as x,d as w,a as A,g as j,i as M,f as z}from"./vec3.js";import{b as P,a as O,r as S}from"../geometry/Polygon.js";import{fromJSON as C}from"../geometry/support/jsonUtils.js";import E from"../Graphic.js";import T from"../core/Handles.js";import{d as D,e as F,f as U}from"./mat4.js";import{c as q}from"./aaBoundingRect.js";import{projectPoint as G}from"../geometry/projection.js";import{b as R,O as N}from"./vec4f64.js";import{c as I}from"./quatf64.js";import{s as B}from"./vec4.js";import{i as L,A as k}from"./aaBoundingBox.js";import{m as H}from"./dehydratedFeatures.js";import{f as V}from"./vec2f64.js";import{i as W,g as Z,A as $,S as Q,T as J,B as K,o as X,d as Y,C as ee,l as te,n as ne,O as re,E as se,p as oe,a as ie,b as ae,D as le,V as ce,q as ue,r as he,s as de,t as fe,u as pe,H as me,v as ge,I as ye,R as be,M as ve,J as _e,K as xe,G as we,m as Ae}from"./VertexColor.glsl.js";import{P as je}from"./Program.js";import{m as Me,a as ze,d as Pe}from"./renderState.js";import{n as Oe}from"./InterleavedLayout.js";import{f as Se,c as Ce,a as Ee}from"./vec3f32.js";import{p as Te,r as De,s as Fe,w as Ue}from"./geometryUtils.js";import{a as qe,c as Ge}from"./Util.js";import{G as Re}from"./glUtil3D.js";import{C as Ne}from"./Object3D.js";var Ie;!function(e){e.length=function(e,t){const n=e[t],r=e[t+1],s=e[t+2];return Math.sqrt(n*n+r*r+s*s)},e.normalize=function(e,t){const n=e[t],r=e[t+1],s=e[t+2],o=1/Math.sqrt(n*n+r*r+s*s);e[t]*=o,e[t+1]*=o,e[t+2]*=o},e.scale=function(e,t,n){e[t]*=n,e[t+1]*=n,e[t+2]*=n},e.add=function(e,t,n,r,s,o=t){(s=s||e)[o]=e[t]+n[r],s[o+1]=e[t+1]+n[r+1],s[o+2]=e[t+2]+n[r+2]},e.subtract=function(e,t,n,r,s,o=t){(s=s||e)[o]=e[t]-n[r],s[o+1]=e[t+1]-n[r+1],s[o+2]=e[t+2]-n[r+2]}}(Ie||(Ie={}));const Be=Ie;var Le,ke,He,Ve;!function(e){const t=.5,n=[[-t,-t,t],[t,-t,t],[t,t,t],[-t,t,t],[-t,-t,-t],[t,-t,-t],[t,t,-t],[-t,t,-t]],r=[0,0,1,-1,0,0,1,0,0,0,-1,0,0,1,0,0,0,-1],s=[0,0,1,0,1,1,0,1],o=new Uint16Array([0,1,2,2,3,0,4,0,3,3,7,4,1,5,6,6,2,1,1,0,4,4,5,1,3,2,6,6,7,3,5,4,7,7,6,5]),i=new Uint16Array(36);for(let e=0;e<6;e++)for(let t=0;t<6;t++)i[6*e+t]=e;const a=new Uint16Array(36);for(let e=0;e<6;e++)a[6*e+0]=0,a[6*e+1]=1,a[6*e+2]=2,a[6*e+3]=2,a[6*e+4]=3,a[6*e+5]=0;e.createGeometry=function(e){Array.isArray(e)||(e=[e,e,e]);const t=new Array(24);for(let r=0;r<8;r++)t[3*r]=n[r][0]*e[0],t[3*r+1]=n[r][1]*e[1],t[3*r+2]=n[r][2]*e[2];return new Re([["position",{size:3,data:t,exclusive:!0}],["normal",{size:3,data:r}],["uv0",{size:2,data:s}]],[["position",o],["normal",i],["uv0",a]])}}(Le||(Le={})),function(e){const t=.5,n=[[-t,0,-t],[t,0,-t],[t,0,t],[-t,0,t],[0,-t,0],[0,t,0]],r=[0,1,-1,1,1,0,0,1,1,-1,1,0,0,-1,-1,1,-1,0,0,-1,1,-1,-1,0],s=new Uint16Array([5,1,0,5,2,1,5,3,2,5,0,3,4,0,1,4,1,2,4,2,3,4,3,0]),o=new Uint16Array([0,0,0,1,1,1,2,2,2,3,3,3,4,4,4,5,5,5,6,6,6,7,7,7]);e.createGeometry=function(e){Array.isArray(e)||(e=[e,e,e]);const t=new Array(18);for(let r=0;r<6;r++)t[3*r]=n[r][0]*e[0],t[3*r+1]=n[r][1]*e[1],t[3*r+2]=n[r][2]*e[2];return new Re([["position",{size:3,data:t,exclusive:!0}],["normal",{size:3,data:r}]],[["position",s],["normal",o]])}}(ke||(ke={})),function(e){const t=.5,n=Se(-t,0,-t),r=Se(t,0,-t),s=Se(0,0,t),o=Se(0,.5,0),i=Ce(),a=Ce(),l=Ce(),c=Ce(),u=Ce();y(i,n,o),y(a,n,r),b(l,i,a),v(l,l),y(i,r,o),y(a,r,s),b(c,i,a),v(c,c),y(i,s,o),y(a,s,n),b(u,i,a),v(u,u);const h=[n,r,s,o],d=[0,-1,0,l[0],l[1],l[2],c[0],c[1],c[2],u[0],u[1],u[2]],f=[0,1,2,3,1,0,3,2,1,3,0,2],p=[0,0,0,1,1,1,2,2,2,3,3,3];e.createGeometry=function(e){Array.isArray(e)||(e=[e,e,e]);const t=new Array(12);for(let n=0;n<4;n++)t[3*n]=h[n][0]*e[0],t[3*n+1]=h[n][1]*e[1],t[3*n+2]=h[n][2]*e[2];return new Re([["position",{size:3,data:t,exclusive:!0}],["normal",{size:3,data:d}]],[["position",new Uint16Array(f)],["normal",new Uint16Array(p)]])}}(He||(He={})),function(e){e.createBoxGeometry=Le.createGeometry,e.createDiamondGeometry=ke.createGeometry,e.createTetrahedronGeometry=He.createGeometry,e.createSphereGeometry=function(e,t,n,r={uv:!0}){const s=-Math.PI,o=2*Math.PI,i=-Math.PI/2,a=Math.PI,l=Math.max(3,Math.floor(t)),c=Math.max(2,Math.floor(n)),u=(l+1)*(c+1),h=new Float32Array(3*u),d=new Float32Array(3*u),f=new Float32Array(2*u),p=[];let m=0;for(let t=0;t<=c;t++){const n=[],r=t/c,u=i+r*a,g=Math.cos(u);for(let t=0;t<=l;t++){const i=t/l,a=s+i*o,c=Math.cos(a)*g,p=Math.sin(u),y=-Math.sin(a)*g;h[3*m]=c*e,h[3*m+1]=p*e,h[3*m+2]=y*e,d[3*m]=c,d[3*m+1]=p,d[3*m+2]=y,f[2*m]=i,f[2*m+1]=r,n.push(m),++m}p.push(n)}const g=new Uint32Array(2*l*(c-1)*3);m=0;for(let e=0;e<c;e++)for(let t=0;t<l;t++){const n=p[e][t],r=p[e][t+1],s=p[e+1][t+1],o=p[e+1][t];0===e?(g[m++]=n,g[m++]=s,g[m++]=o):e===c-1?(g[m++]=n,g[m++]=r,g[m++]=s):(g[m++]=n,g[m++]=r,g[m++]=s,g[m++]=s,g[m++]=o,g[m++]=n)}const y=[["position",g],["normal",g]],b=[["position",{size:3,data:h,exclusive:!0}],["normal",{size:3,data:d,exclusive:!0}]];return r.uv&&(b.push(["uv0",{size:2,data:f,exclusive:!0}]),y.push(["uv0",g])),r.offset&&(y[0][0]="offset",b[0][0]="offset",y.push(["position",new Uint32Array(g.length)]),b.push(["position",{size:3,data:Float64Array.from(r.offset),exclusive:!0}])),new Re(b,y)},e.createPolySphereGeometry=function(e,t,n){const r=e;let s,o;if(n)s=[0,-1,0,1,0,0,0,0,1,-1,0,0,0,0,-1,0,1,0],o=new Uint32Array([0,1,2,0,2,3,0,3,4,0,4,1,1,5,2,2,5,3,3,5,4,4,5,1]);else{const e=r*(1+Math.sqrt(5))/2;s=[-r,e,0,r,e,0,-r,-e,0,r,-e,0,0,-r,e,0,r,e,0,-r,-e,0,r,-e,e,0,-r,e,0,r,-e,0,-r,-e,0,r],o=new Uint32Array([0,11,5,0,5,1,0,1,7,0,7,10,0,10,11,1,5,9,5,11,4,11,10,2,10,7,6,7,1,8,3,9,4,3,4,2,3,2,6,3,6,8,3,8,9,4,9,5,2,4,11,6,2,10,8,6,7,9,8,1])}for(let t=0;t<s.length;t+=3)Be.scale(s,t,e/Be.length(s,t));let i={};function a(t,n){t>n&&([t,n]=[n,t]);const r=t.toString()+"."+n.toString();if(i[r])return i[r];let o=s.length;return s.length+=3,Be.add(s,3*t,s,3*n,s,o),Be.scale(s,o,e/Be.length(s,o)),o/=3,i[r]=o,o}for(let e=0;e<t;e++){const e=o.length,t=new Uint32Array(4*e);for(let n=0;n<e;n+=3){const e=o[n],r=o[n+1],s=o[n+2],i=a(e,r),l=a(r,s),c=a(s,e),u=4*n;t[u]=e,t[u+1]=i,t[u+2]=c,t[u+3]=r,t[u+4]=l,t[u+5]=i,t[u+6]=s,t[u+7]=c,t[u+8]=l,t[u+9]=i,t[u+10]=l,t[u+11]=c}o=t,i={}}const l=new Float32Array(s);for(let e=0;e<l.length;e+=3)Be.normalize(l,e);const c=[["position",o],["normal",o]],u=[["position",{size:3,data:new Float32Array(s),exclusive:!0}],["normal",{size:3,data:l,exclusive:!0}]];return new Re(u,c)},e.createPointGeometry=function(e,t,n,r,s,o,i){const a=t?[t[0],t[1],t[2]]:[0,0,0],l=e?[e[0],e[1],e[2]]:[0,0,1];o=o||[0,0];const c=n?[255*n[0],255*n[1],255*n[2],n.length>3?255*n[3]:255]:[255,255,255,255],u=null!=r&&2===r.length?r:[1,1],h=[["position",{size:3,data:a,exclusive:!0}],["normal",{size:3,data:l,exclusive:!0}],["uv0",{size:o.length,data:o}],["color",{size:4,data:c,exclusive:!0}],["size",{size:2,data:u}]];if(null!=s){const e=new Float32Array([s[0],s[1],s[2],s[3]]);h.push(["auxpos1",{size:4,data:e}])}if(null!=i){const e=new Float32Array([i[0],i[1],i[2],i[3]]);h.push(["auxpos2",{size:4,data:e}])}return new Re(h,null,1)},e.updatePointGeometry=function(e,t,n,r,s,o,i,a){if(null!=e){const{data:t}=a.getMutableAttribute("normal");t[0]=e[0],t[1]=e[1],t[2]=e[2]}if(null!=t){const{data:e}=a.getMutableAttribute("position");e[0]=t[0],e[1]=t[1],e[2]=t[2]}if(null!=n){const{data:e}=a.getMutableAttribute("color");e[0]=n[0],e[1]=n[1],e[2]=n[2],e[3]=n[3]}if(null!=r){const{data:e}=a.getMutableAttribute("size");e[0]=r[0],e[1]=r[1]}if(null!=s){const{data:e}=a.getMutableAttribute("auxpos1");e[0]=s[0],e[1]=s[1],e[2]=s[2],e[3]=s[3]}if(null!=o){const{data:e}=a.getMutableAttribute("uv0");e[0]=o[0],e[1]=o[1]}if(null!=i){const{data:e}=a.getMutableAttribute("auxpos2");e[0]=i[0],e[1]=i[1],e[2]=i[2],e[3]=i[3]}},e.createPointArrayGeometry=function(e,t){const n=new Float32Array(3*e.length),r=new Float32Array(t?3*e.length:3),s=new Uint32Array(e.length),o=new Uint32Array(e.length);for(let i=0;i<e.length;i++)n[3*i]=e[i][0],n[3*i+1]=e[i][1],n[3*i+2]=e[i][2],t&&(r[3*i]=t[i][0],r[3*i+1]=t[i][1],r[3*i+2]=t[i][2]),s[i]=i,o[i]=0;return t||(r[0]=0,r[1]=1,r[2]=0),new Re([["position",{size:3,data:n,exclusive:!0}],["normal",{size:3,data:r,exclusive:!0}],["uv0",{size:2,data:[0,0],exclusive:!0}]],[["position",s],["normal",t?s:o],["uv0",o]],1)},e.createTriangleGeometry=function(){const e=new Uint16Array([0,1,2]),t=new Uint16Array([0,0,0]),n=new Uint16Array([0,0,0]);return new Re([["position",{size:3,data:[0,0,0,0,0,100,100,0,0],exclusive:!0}],["normal",{size:3,data:[0,1,0],exclusive:!0}],["uv0",{size:2,data:[0,0],exclusive:!0}]],[["position",e],["normal",t],["uv0",n]])};const t=[[-1,-1,0],[1,-1,0],[1,1,0],[-1,1,0]];function n(e,t,n,r,s){return!(Math.abs(w(t,e))>s)&&(b(n,e,t),v(n,n),b(r,n,e),v(r,r),!0)}function r(e,t,r,s,o,i,a){return n(e,t,o,i,a)||n(e,r,o,i,a)||n(e,s,o,i,a)}e.createSquareGeometry=function(e=t){const n=new Array(12);for(let t=0;t<4;t++)for(let r=0;r<3;r++)n[3*t+r]=e[t][r];const r=new Uint32Array([0,1,2,2,3,0]),s=new Uint32Array([0,0,0,0,0,0]);return new Re([["position",{size:3,data:n,exclusive:!0}],["normal",{size:3,data:[0,0,1],exclusive:!0}],["uv0",{size:2,data:[0,0,1,0,1,1,0,1],exclusive:!0}],["color",{size:4,data:[255,255,255,255],exclusive:!0}]],[["position",r],["normal",s],["uv0",r],["color",s]])},e.createConeGeometry=function(e,t,n,r,s=!0,o=!0){let i=0;const a=t,l=e;let c=Se(0,i,0),u=Se(0,i+l,0),h=Se(0,-1,0),d=Se(0,1,0);r&&(i=l,u=Se(0,0,0),c=Se(0,i,0),h=Se(0,1,0),d=Se(0,-1,0));const f=[u,c],p=[h,d],m=n+2,g=Math.sqrt(l*l+a*a);if(r)for(let e=n-1;e>=0;e--){const t=e*(2*Math.PI/n),r=Se(Math.cos(t)*a,i,Math.sin(t)*a);f.push(r);const s=Se(l*Math.cos(t)/g,-a/g,l*Math.sin(t)/g);p.push(s)}else for(let e=0;e<n;e++){const t=e*(2*Math.PI/n),r=Se(Math.cos(t)*a,i,Math.sin(t)*a);f.push(r);const s=Se(l*Math.cos(t)/g,a/g,l*Math.sin(t)/g);p.push(s)}const y=new Uint32Array(2*(n+2)*3),b=new Uint32Array(2*(n+2)*3);let v=0,_=0;if(s){for(let e=3;e<f.length;e++)y[v++]=1,y[v++]=e-1,y[v++]=e,b[_++]=0,b[_++]=0,b[_++]=0;y[v++]=f.length-1,y[v++]=2,y[v++]=1,b[_++]=0,b[_++]=0,b[_++]=0}if(o){for(let e=3;e<f.length;e++)y[v++]=e,y[v++]=e-1,y[v++]=0,b[_++]=e,b[_++]=e-1,b[_++]=1;y[v++]=0,y[v++]=2,y[v++]=f.length-1,b[_++]=1,b[_++]=2,b[_++]=p.length-1}const x=new Float32Array(3*m);for(let e=0;e<m;e++)x[3*e]=f[e][0],x[3*e+1]=f[e][1],x[3*e+2]=f[e][2];const w=new Float32Array(3*m);for(let e=0;e<m;e++)w[3*e]=p[e][0],w[3*e+1]=p[e][1],w[3*e+2]=p[e][2];return new Re([["position",{size:3,data:x,exclusive:!0}],["normal",{size:3,data:w,exclusive:!0}]],[["position",y],["normal",b]])},e.createCylinderGeometry=function(e,t,n,r,s,o){const i=r?Ee(r):Se(1,0,0),a=s?Ee(s):Se(0,0,0);o=null==o||o;const l=Ce();v(l,i);const c=Ce();_(c,l,Math.abs(e));const u=Ce();_(u,c,-.5),x(u,u,a);const h=Se(0,1,0);Math.abs(1-w(l,h))<.2&&A(h,0,0,1);const d=Ce();b(d,l,h),v(d,d),b(h,d,l);const f=2*n+(o?2:0),p=n+(o?2:0),m=new Float32Array(3*f),g=new Float32Array(3*p),y=new Float32Array(2*f),j=new Uint32Array(3*n*(o?4:2)),M=new Uint32Array(3*n*(o?4:2));o&&(m[3*(f-2)+0]=u[0],m[3*(f-2)+1]=u[1],m[3*(f-2)+2]=u[2],y[2*(f-2)]=0,y[2*(f-2)+1]=0,m[3*(f-1)+0]=m[3*(f-2)+0]+c[0],m[3*(f-1)+1]=m[3*(f-2)+1]+c[1],m[3*(f-1)+2]=m[3*(f-2)+2]+c[2],y[2*(f-1)]=1,y[2*(f-1)+1]=1,g[3*(p-2)+0]=-l[0],g[3*(p-2)+1]=-l[1],g[3*(p-2)+2]=-l[2],g[3*(p-1)+0]=l[0],g[3*(p-1)+1]=l[1],g[3*(p-1)+2]=l[2]);const z=function(e,t,n){j[e]=t,M[e]=n};let P=0;const O=Ce(),S=Ce();for(let e=0;e<n;e++){const r=e*(2*Math.PI/n);_(O,h,Math.sin(r)),_(S,d,Math.cos(r)),x(O,O,S),g[3*e+0]=O[0],g[3*e+1]=O[1],g[3*e+2]=O[2],_(O,O,t),x(O,O,u),m[3*e+0]=O[0],m[3*e+1]=O[1],m[3*e+2]=O[2],y[2*e+0]=e/n,y[2*e+1]=0,m[3*(e+n)+0]=m[3*e+0]+c[0],m[3*(e+n)+1]=m[3*e+1]+c[1],m[3*(e+n)+2]=m[3*e+2]+c[2],y[2*(e+n)+0]=e/n,y[2*e+1]=1;const s=(e+1)%n;z(P++,e,e),z(P++,e+n,e),z(P++,s,s),z(P++,s,s),z(P++,e+n,e),z(P++,s+n,s)}if(o){for(let e=0;e<n;e++){const t=(e+1)%n;z(P++,f-2,p-2),z(P++,e,p-2),z(P++,t,p-2)}for(let e=0;e<n;e++){const t=(e+1)%n;z(P++,e+n,p-1),z(P++,f-1,p-1),z(P++,t+n,p-1)}}return new Re([["position",{size:3,data:m,exclusive:!0}],["normal",{size:3,data:g,exclusive:!0}],["uv0",{size:2,data:y,exclusive:!0}]],[["position",j],["normal",M],["uv0",j]])},e.createTubeGeometry=function(t,n,r,s,o){r=r||10,s=null==s||s,qe(t.length>1);const i=[],a=[];for(let e=0;e<r;e++){i.push([0,-e-1,-(e+1)%r-1]);const t=e/r*2*Math.PI;a.push([Math.cos(t)*n,Math.sin(t)*n])}return e.createPathExtrusionGeometry(a,t,[[0,0,0]],i,s,o)},e.createPathExtrusionGeometry=function(e,t,n,s,o,i=Se(0,0,0)){const a=e.length,l=new Float32Array(t.length*a*3+(6*n.length||0)),c=new Float32Array(t.length*a*3+(n?6:0)),u=(t.length-1)*a*6+3*s.length*2,h=new Uint32Array(u),f=new Uint32Array(u);let p=0,m=0,g=0,w=0;const M=Ce(),z=Ce(),P=Ce(),O=Ce(),S=Ce(),C=Ce(),E=Ce(),T=d(),D=Ce(),F=Ce(),U=Ce(),q=Ce(),G=Ce(),R=Te.create();A(D,0,1,0),y(z,t[1],t[0]),v(z,z),o?(x(T,t[0],i),v(P,T)):A(P,0,0,1),r(z,P,D,D,S,P,We),j(O,P),j(q,S);for(let e=0;e<n.length;e++)_(C,S,n[e][0]),_(T,P,n[e][2]),x(C,C,T),x(C,C,t[0]),l[p++]=C[0],l[p++]=C[1],l[p++]=C[2];c[m++]=-z[0],c[m++]=-z[1],c[m++]=-z[2];for(let e=0;e<s.length;e++)h[g++]=s[e][0]>0?s[e][0]:-s[e][0]-1+n.length,h[g++]=s[e][1]>0?s[e][1]:-s[e][1]-1+n.length,h[g++]=s[e][2]>0?s[e][2]:-s[e][2]-1+n.length,f[w++]=0,f[w++]=0,f[w++]=0;let N=n.length;const I=n.length-1;for(let n=0;n<t.length;n++){let s=!1;if(n>0){j(M,z),n<t.length-1?(y(z,t[n+1],t[n]),v(z,z)):s=!0,x(F,M,z),v(F,F),x(U,t[n-1],O),Te.fromPositionAndNormal(t[n],F,R);Te.intersectRay(R,De.wrap(U,M),T)?(y(T,T,t[n]),v(P,T),b(S,F,P),v(S,S)):r(F,O,q,D,S,P,We),j(O,P),j(q,S)}o&&(x(T,t[n],i),v(G,T));for(let r=0;r<a;r++)if(_(C,S,e[r][0]),_(T,P,e[r][1]),x(C,C,T),v(E,C),c[m++]=E[0],c[m++]=E[1],c[m++]=E[2],x(C,C,t[n]),l[p++]=C[0],l[p++]=C[1],l[p++]=C[2],!s){const e=(r+1)%a;h[g++]=N+r,h[g++]=N+a+r,h[g++]=N+e,h[g++]=N+e,h[g++]=N+a+r,h[g++]=N+a+e;for(let e=0;e<6;e++)f[w++]=h[g-6+e]-I}N+=a}const B=t[t.length-1];for(let e=0;e<n.length;e++)_(C,S,n[e][0]),_(T,P,n[e][1]),x(C,C,T),x(C,C,B),l[p++]=C[0],l[p++]=C[1],l[p++]=C[2];const L=m/3;c[m++]=z[0],c[m++]=z[1],c[m++]=z[2];const k=N-a;for(let e=0;e<s.length;e++)h[g++]=s[e][0]>=0?N+s[e][0]:-s[e][0]-1+k,h[g++]=s[e][2]>=0?N+s[e][2]:-s[e][2]-1+k,h[g++]=s[e][1]>=0?N+s[e][1]:-s[e][1]-1+k,f[w++]=L,f[w++]=L,f[w++]=L;return new Re([["position",{size:3,data:l,exclusive:!0}],["normal",{size:3,data:c,exclusive:!0}]],[["position",h],["normal",f]])},e.createPolylineGeometry=function(e,t,n){qe(e.length>1,"createPolylineGeometry(): polyline needs at least 2 points"),qe(3===e[0].length,"createPolylineGeometry(): malformed vertex"),qe(null==t||t.length===e.length,"createPolylineGeometry: need same number of points and normals"),qe(null==t||3===t[0].length,"createPolylineGeometry(): malformed normal");const r=new Float64Array(3*e.length),s=new Uint32Array(2*(e.length-1));let o=0,i=0;for(let t=0;t<e.length;t++){for(let n=0;n<3;n++)r[o++]=e[t][n];t>0&&(s[i++]=t-1,s[i++]=t)}const a=[],l=[];if(a.push(["position",s]),l.push(["position",{size:3,data:r,exclusive:!0}]),t){const n=new Float32Array(3*t.length);let r=0;for(let s=0;s<e.length;s++)for(let e=0;e<3;e++)n[r++]=t[s][e];a.push(["normal",s]),l.push(["normal",{size:3,data:n,exclusive:!0}])}return n&&(l.push(["color",{size:4,data:n}]),a.push(["color",W(n.length/4)])),new Re(l,a,2)},e.createExtrudedTriangle=function(e,t,n,r){const s=new Array(18),o=[[-t,0,r/2],[n,0,r/2],[0,e,r/2],[-t,0,-r/2],[n,0,-r/2],[0,e,-r/2]],i=new Uint16Array([0,1,2,3,0,2,2,5,3,1,4,5,5,2,1,1,0,3,3,4,1,4,3,5]);for(let e=0;e<6;e++)s[3*e]=o[e][0],s[3*e+1]=o[e][1],s[3*e+2]=o[e][2];return new Re([["position",{size:3,data:s,exclusive:!0}]],[["position",i]])},e.transformInPlace=function(e,t){const n=e.getMutableAttribute("position").data;for(let e=0;e<n.length;e+=3){const r=n[e],s=n[e+1],o=n[e+2];A(Ze,r,s,o),M(Ze,Ze,t),n[e]=Ze[0],n[e+1]=Ze[1],n[e+2]=Ze[2]}},e.cgToGIS=function(e,t=e){const n=e.vertexAttributes,r=n.get("position").data,s=n.get("normal").data;if(s){const e=t.getMutableAttribute("normal").data;for(let t=0;t<s.length;t+=3){const n=s[t+1];e[t+1]=-s[t+2],e[t+2]=n}}if(r){const e=t.getMutableAttribute("position").data;for(let t=0;t<r.length;t+=3){const n=r[t+1];e[t+1]=-r[t+2],e[t+2]=n}}return t},e.makeOrthoBasisDirUp=n,e.makeOrthoBasisDirUpFallback=r}(Ve||(Ve={}));const We=.99619469809,Ze=Ce();var $e=Ve;function Qe(e){return"declaredClass"in e}function Je(e){return"declaredClass"in e}function Ke(e,t){if(!e)return null;if(function(e){return"declaredClass"in e}(e))return e;const r=new E({layer:t,sourceLayer:t});return r.visible=e.visible,r.symbol=n(e.symbol),r.attributes=n(e.attributes),r.geometry=Xe(e.geometry),r}function Xe(e){return i(e)?null:Qe(e)?e:C(function(e){const t=e.spatialReference.toJSON();switch(e.type){case"point":{const{x:n,y:r,z:s,m:o}=e;return{x:n,y:r,z:s,m:o,spatialReference:t}}case"polygon":{const{rings:n,hasZ:r,hasM:s}=e;return{rings:Ye(n),hasZ:r,hasM:s,spatialReference:t}}case"polyline":{const{paths:n,hasZ:r,hasM:s}=e;return{paths:Ye(n),hasZ:r,hasM:s,spatialReference:t}}case"extent":{const{xmin:n,xmax:r,ymin:s,ymax:o,zmin:i,zmax:a,mmin:l,mmax:c,hasZ:u,hasM:h}=e;return{xmin:n,xmax:r,ymin:s,ymax:o,zmin:i,zmax:a,mmin:l,mmax:c,hasZ:u,hasM:h,spatialReference:t}}case"multipoint":{const{points:n,hasZ:r,hasM:s}=e;return{points:tt(n)?et(n):n,hasZ:r,hasM:s,spatialReference:t}}default:return}}(e))}function Ye(e){return function(e){for(const t of e)if(0!==t.length)return tt(t);return!1}(e)?e.map((e=>et(e))):e}function et(e){return e.map((e=>o(e)))}function tt(e){return e.length&&(r(e[0])||s(e[0]))}function nt(e,t){if(!e)return null;let n;if(Je(e)){if(null==t)return e.clone();if(Je(t))return t.copy(e)}return null!=t?(n=t,n.x=e.x,n.y=e.y,n.spatialReference=e.spatialReference,e.hasZ?(n.z=e.z,n.hasZ=e.hasZ):(n.z=null,n.hasZ=!1),e.hasM?(n.m=e.m,n.hasM=!0):(n.m=null,n.hasM=!1)):(n=H(e.x,e.y,e.z,e.spatialReference),e.hasM&&(n.m=e.m,n.hasM=!0)),n}function rt(e,t){if("point"===e.type)return ot(e,t,!1);if(Qe(e))switch(e.type){case"extent":return ot(e.center,t,!1);case"polygon":return ot(e.centroid,t,!1);case"polyline":return ot(st(e),t,!0);case"mesh":return ot(e.extent.center,t,!1)}else switch(e.type){case"extent":return ot(function(e){const t=h(e.zmin);return H(.5*(e.xmax+e.xmin),.5*(e.ymax+e.ymin),t?.5*(e.zmax+e.zmin):void 0,e.spatialReference)}(e),t,!0);case"polygon":return ot(function(e){const t=e.rings[0];if(!t||0===t.length)return null;const n=S(e.rings,e.hasZ);return H(n[0],n[1],n[2],e.spatialReference)}(e),t,!0);case"polyline":return ot(st(e),t,!0)}}function st(e){const t=e.paths[0];if(!t||0===t.length)return null;const n=P(t,O(t)/2);return H(n[0],n[1],n[2],e.spatialReference)}function ot(e,t,n){const r=n?e:nt(e);return t&&e?G(e,r,t)?r:null:r}function it(e,t,n,r=0){if(e){t||(t=q());const s=e;let o=.5*s.width*(n-1),i=.5*s.height*(n-1);return s.width<1e-7*s.height?o+=i/20:s.height<1e-7*s.width&&(i+=o/20),B(t,s.xmin-o-r,s.ymin-i-r,s.xmax+o+r,s.ymax+i+r),t}return null}function at(e,t){for(let n=0;n<e.geometries.length;++n){const r=e.geometries[n].getMutableAttribute("auxpos1");r&&r.data[3]!==t&&(r.data[3]=t,e.geometryVertexAttrsUpdated(n))}}function lt(e,t){const n=R(N);return a(e)&&(n[0]=e[0],n[1]=e[1],n[2]=e[2]),a(t)?n[3]=t:a(e)&&e.length>3&&(n[3]=e[3]),n}function ct(e,t,n,r,s,o=[0,0,0,0]){for(let t=0;t<3;++t)a(e)&&null!=e[t]?o[t]=e[t]:a(n)&&null!=n[t]?o[t]=n[t]:o[t]=s[t];return a(t)?o[3]=t:a(r)?o[3]=r:o[3]=s[3],o}function ut(e=p,t,n,r=1){const s=new Array(3);if(i(t)||i(n))s[0]=1,s[1]=1,s[2]=1;else{let r,o=0;for(let i=2;i>=0;i--){const a=e[i];let l;const c=null!=a,u=0===i&&!r&&!c,h=n[i];"symbol-value"===a||u?l=0!==h?t[i]/h:1:c&&"proportional"!==a&&isFinite(a)&&(l=0!==h?a/h:1),null!=l&&(s[i]=l,r=l,o=Math.max(o,Math.abs(l)))}for(let e=2;e>=0;e--)null==s[e]?s[e]=r:0===s[e]&&(s[e]=.001*o)}for(let e=2;e>=0;e--)s[e]/=r;return f(s)}function ht(e){return null!=e.isPrimitive&&(e=[e.width,e.depth,e.height]),dt(e)?null:"Symbol sizes may not be negative values"}function dt(e){if(Array.isArray(e)){for(const t of e)if(!dt(t))return!1;return!0}return null==e||e>=0}function ft(e,t,n,r=I()){const s=e||0,o=t||0,i=n||0;return 0!==s&&D(r,r,-s/180*Math.PI),0!==o&&F(r,r,o/180*Math.PI),0!==i&&U(r,r,i/180*Math.PI),r}function pt(e,t){return null!=t.minDemResolution?t.minDemResolution:L(e)?t.minDemResolutionForPoints:.01*k(e)}const mt={"bottom-left":V(0,0),bottom:V(.5,0),"bottom-right":V(1,0),left:V(0,.5),center:V(.5,.5),right:V(1,.5),"top-left":V(0,1),top:V(.5,1),"top-right":V(1,1)},gt=["layerObjectAdded","layerObjectRemoved","layerObjectsAdded","layerObjectsRemoved","shaderTransformationChanged","objectTransformation","visibilityChanged","occlusionChanged","highlightChanged","objectGeometryAdded","objectGeometryRemoved","vertexAttrsUpdated"];class yt{constructor(e,t){this._objectToBoundingSphere=e,this._maximumObjectsPerNode=10,this._maximumDepth=20,this._degenerateObjects=new Set,this._root=new bt,this._objectCount=0,t&&(void 0!==t.maximumObjectsPerNode&&(this._maximumObjectsPerNode=t.maximumObjectsPerNode),void 0!==t.maximumDepth&&(this._maximumDepth=t.maximumDepth))}get bounds(){return this._root.bounds}get halfSize(){return this._root.halfSize}get root(){return this._root.node}get maximumObjectsPerNode(){return this._maximumObjectsPerNode}get maximumDepth(){return this._maximumDepth}get objectCount(){return this._objectCount}destroy(){this._degenerateObjects.clear(),bt.clearPool(),Ct[0]=null,Ut.prune(),Bt.prune()}add(e,t=e.length){this._objectCount+=t,this._grow(e,t);const n=bt.acquire();for(let r=0;r<t;r++){const t=e[r];this._isDegenerate(t)?this._degenerateObjects.add(t):(n.init(this._root),this._add(t,n))}bt.release(n)}remove(e,t=null){this._objectCount-=e.length;const n=bt.acquire();for(const r of e){const e=a(t)?t:Fe.copy(this._objectToBoundingSphere(r),qt);zt(e[3])?(n.init(this._root),this._remove(r,e,n)):this._degenerateObjects.delete(r)}bt.release(n),this._shrink()}update(e,t){if(!zt(t[3])&&this._isDegenerate(e))return;const n=function(e){return Ct[0]=e,Ct}(e);this.remove(n,t),this.add(n)}forEachAlongRay(e,t,n){const r=De.wrap(e,t);this._forEachNode(this._root,(e=>{if(!this._intersectsNode(r,e))return!1;const t=e.node;return t.terminals.forAll((e=>{this._intersectsObject(r,e)&&n(e)})),null!==t.residents&&t.residents.forAll((e=>{this._intersectsObject(r,e)&&n(e)})),!0}))}forEachAlongRayWithVerticalOffset(e,t,n,r){const s=De.wrap(e,t);this._forEachNode(this._root,(e=>{if(!this._intersectsNodeWithOffset(s,e,r))return!1;const t=e.node;return t.terminals.forAll((e=>{this._intersectsObjectWithOffset(s,e,r)&&n(e)})),null!==t.residents&&t.residents.forAll((e=>{this._intersectsObjectWithOffset(s,e,r)&&n(e)})),!0}))}forEach(e){this._forEachNode(this._root,(t=>{const n=t.node;return n.terminals.forAll(e),null!==n.residents&&n.residents.forAll(e),!0})),this._degenerateObjects.forEach(e)}forEachDegenerateObject(e){this._degenerateObjects.forEach(e)}findClosest(e,t,n,r,s){return this._findClosest(e,"front-to-back"===t?1:-1,n,r,s)}forEachInDepthRange(e,t,n,r,s,o,i,a){this._forEachInDepthRange(e,t,"front-to-back"===n?1:-1,r,s,o,i,a)}forEachNode(e){this._forEachNode(this._root,(t=>e(t.node,t.bounds,t.halfSize)))}_intersectsNode(e,t){return xt(t.bounds,2*-t.halfSize,Dt),xt(t.bounds,2*t.halfSize,Ft),Ge(e.origin,e.direction,Dt,Ft)}_intersectsNodeWithOffset(e,t,n){return xt(t.bounds,2*-t.halfSize,Dt),xt(t.bounds,2*t.halfSize,Ft),n.applyToMinMax(Dt,Ft),Ge(e.origin,e.direction,Dt,Ft)}_intersectsObject(e,t){const n=this._objectToBoundingSphere(t);return!(n[3]>0)||Fe.intersectsRay(n,e)}_intersectsObjectWithOffset(e,t,n){const r=this._objectToBoundingSphere(t);return!(r[3]>0)||Fe.intersectsRay(n.applyToBoundingSphere(r),e)}_forEachNode(e,t){let n=bt.acquire().init(e);const r=[n];for(;0!==r.length;){if(n=r.pop(),t(n)&&!n.isLeaf())for(let e=0;e<n.node.children.length;e++){n.node.children[e]&&r.push(bt.acquire().init(n).advance(e))}bt.release(n)}}_forEachNodeDepthOrdered(e,t,n,r=1){let s=bt.acquire().init(e);const o=[s];for(!function(e,t,n){if(!Bt.length)for(let e=0;e<8;++e)Bt.push({index:0,distance:0});for(let n=0;n<8;++n){const r=Pt[n];Bt.data[n].index=n,Bt.data[n].distance=Mt(e,t,r)}Bt.sort(((e,t)=>e.distance-t.distance));for(let e=0;e<8;++e)n[e]=Bt.data[e].index}(n,r,Lt);0!==o.length;){if(s=o.pop(),t(s)&&!s.isLeaf())for(let e=7;e>=0;--e){const t=Lt[e];if(t>=s.node.children.length)continue;s.node.children[t]&&o.push(bt.acquire().init(s).advance(t))}bt.release(s)}}_findClosest(e,t,n,r,s){let o=1/0,i=1/0,a=null;const l=jt(e,t);let c=0;const u=s=>{if(++c,r&&!r(s))return;const l=this._objectToBoundingSphere(s);if(n&&wt(l,n))return;const u=Mt(e,t,Fe.getCenter(l)),h=u-l[3],d=u+l[3];h<o&&(o=h,i=d,a=s)};return this._forEachNodeDepthOrdered(this._root,(r=>{if(null!=s&&c>=s)return!1;if(n&&wt(r.bounds,n))return!1;_(Tt,l,r.halfSize),x(Tt,Tt,r.bounds);if(Mt(e,t,Tt)>i)return!1;const o=r.node;return o.terminals.forAll((e=>{u(e)})),null!==o.residents&&o.residents.forAll((e=>{u(e)})),!0}),e,t),a}_forEachInDepthRange(e,t,n,r,s,o,i,a){let l=-1/0,c=1/0;const u={setRange:e=>{1===n?(l=Math.max(l,e.near),c=Math.min(c,e.far)):(l=Math.max(l,-e.far),c=Math.min(c,-e.near))}};u.setRange(r);const h=Mt(t,n,e),d=jt(t,n),f=jt(t,-1*n);let p=0;const m=e=>{if(++p,i&&!i(e))return;const r=this._objectToBoundingSphere(e),a=Fe.getCenter(r),d=Mt(t,n,a)-h,f=d-r[3],m=d+r[3];f>c||m<l||o&&wt(r,o)||s(e,u)};this._forEachNodeDepthOrdered(this._root,(e=>{if(null!=a&&p>=a)return!1;if(o&&wt(e.bounds,o))return!1;_(Tt,d,e.halfSize),x(Tt,Tt,e.bounds);if(Mt(t,n,Tt)-h>c)return!1;_(Tt,f,e.halfSize),x(Tt,Tt,e.bounds);if(Mt(t,n,Tt)-h<l)return!1;const r=e.node;return r.terminals.forAll((e=>{m(e)})),null!==r.residents&&r.residents.forAll((e=>{m(e)})),!0}),t,n)}_remove(e,t,n){Ut.clear();const r=n.advanceTo(t,((e,t)=>{Ut.push(e.node),Ut.push(t)}))?n.node.terminals:n.node.residents;if(r.removeUnordered(e),0===r.length)for(let e=Ut.length-2;e>=0;e-=2){const t=Ut.data[e],n=Ut.data[e+1];if(!this._purge(t,n))break}}_nodeIsEmpty(e){if(0!==e.terminals.length)return!1;if(null!==e.residents)return 0===e.residents.length;for(let t=0;t<e.children.length;t++)if(e.children[t])return!1;return!0}_purge(e,t){return t>=0&&(e.children[t]=null),!!this._nodeIsEmpty(e)&&(null===e.residents&&(e.residents=new c({shrink:!0})),!0)}_add(e,t){t.advanceTo(this._objectToBoundingSphere(e))?t.node.terminals.push(e):(t.node.residents.push(e),t.node.residents.length>this._maximumObjectsPerNode&&t.depth<this._maximumDepth&&this._split(t))}_split(e){const t=e.node.residents;e.node.residents=null;for(let n=0;n<t.length;n++){const r=bt.acquire().init(e);this._add(t.getItemAt(n),r),bt.release(r)}}_grow(e,t){if(0!==t&&(At(e,t,(e=>this._objectToBoundingSphere(e)),Gt),zt(Gt[3])&&!this._fitsInsideTree(Gt)))if(this._nodeIsEmpty(this._root.node))Fe.copy(Gt,this._root.bounds),this._root.halfSize=1.25*Gt[3];else{const e=this._rootBoundsForRootAsSubNode(Gt);this._placingRootViolatesMaxDepth(e)?this._rebuildTree(Gt,e):this._growRootAsSubNode(e),bt.release(e)}}_rebuildTree(e,t){j(Rt,t.bounds),Rt[3]=t.halfSize,At([e,Rt],2,(e=>e),Nt);const n=bt.acquire().init(this._root);this._root.initFrom(null,Nt,1.25*Nt[3]),this._forEachNode(n,(e=>(this.add(e.node.terminals.data,e.node.terminals.length),null!==e.node.residents&&this.add(e.node.residents.data,e.node.residents.length),!0))),bt.release(n)}_placingRootViolatesMaxDepth(e){const t=Math.log(e.halfSize/this._root.halfSize)*Math.LOG2E;let n=0;return this._forEachNode(this._root,(e=>(n=Math.max(n,e.depth),n+t<=this._maximumDepth))),n+t>this._maximumDepth}_rootBoundsForRootAsSubNode(e){const t=e[3],n=e;let r=-1/0;const s=this._root.bounds,o=this._root.halfSize;for(let e=0;e<3;e++){const i=s[e]-o-(n[e]-t),a=n[e]+t-(s[e]+o),l=Math.max(0,Math.ceil(i/(2*o))),c=Math.max(0,Math.ceil(a/(2*o)))+1,u=2**Math.ceil(Math.log(l+c)*Math.LOG2E);r=Math.max(r,u),It[e].min=l,It[e].max=c}for(let e=0;e<3;e++){let t=It[e].min,n=It[e].max;const i=(r-(t+n))/2;t+=Math.ceil(i),n+=Math.floor(i);const a=s[e]-o-t*o*2;Et[e]=a+(n+t)*o}return Et[3]=r*o*St,bt.acquire().initFrom(null,Et,r*o,0)}_growRootAsSubNode(e){const t=this._root.node;j(Gt,this._root.bounds),Gt[3]=this._root.halfSize,this._root.init(e),e.advanceTo(Gt,null,!0),e.node.children=t.children,e.node.residents=t.residents,e.node.terminals=t.terminals}_shrink(){for(;;){const e=this._findShrinkIndex();if(-1===e)break;this._root.advance(e),this._root.depth=0}}_findShrinkIndex(){if(0!==this._root.node.terminals.length||this._root.isLeaf())return-1;let e=null;const t=this._root.node.children;let n=0,r=0;for(;r<t.length&&null==e;)n=r++,e=t[n];for(;r<t.length;)if(t[r++])return-1;return n}_isDegenerate(e){return!zt(this._objectToBoundingSphere(e)[3])}_fitsInsideTree(e){const t=this._root.bounds,n=this._root.halfSize;return e[3]<=n&&e[0]>=t[0]-n&&e[0]<=t[0]+n&&e[1]>=t[1]-n&&e[1]<=t[1]+n&&e[2]>=t[2]-n&&e[2]<=t[2]+n}}class bt{constructor(){this.bounds=Fe.create(),this.halfSize=0,this.initFrom(null,null,0,0)}init(e){return this.initFrom(e.node,e.bounds,e.halfSize,e.depth)}initFrom(e,t,n,r=this.depth){return this.node=a(e)?e:bt.createEmptyNode(),a(t)&&Fe.copy(t,this.bounds),this.halfSize=n,this.depth=r,this}advance(e){let t=this.node.children[e];t||(t=bt.createEmptyNode(),this.node.children[e]=t),this.node=t,this.halfSize/=2,this.depth++;const n=Pt[e];return this.bounds[0]+=n[0]*this.halfSize,this.bounds[1]+=n[1]*this.halfSize,this.bounds[2]+=n[2]*this.halfSize,this.bounds[3]=this.halfSize*St,this}advanceTo(e,t,n=!1){for(;;){if(this.isTerminalFor(e))return t&&t(this,-1),!0;if(this.isLeaf()){if(!n)return t&&t(this,-1),!1;this.node.residents=null}const r=this._childIndex(e);t&&t(this,r),this.advance(r)}}isLeaf(){return null!=this.node.residents}isTerminalFor(e){return e[3]>this.halfSize/2}_childIndex(e){const t=this.bounds;return(t[0]<e[0]?1:0)+(t[1]<e[1]?2:0)+(t[2]<e[2]?4:0)}static createEmptyNode(){return{children:[null,null,null,null,null,null,null,null],terminals:new c({shrink:!0}),residents:new c({shrink:!0})}}static acquire(){return bt._pool.acquire()}static release(e){bt._pool.release(e)}static clearPool(){bt._pool.prune()}}function vt(e,t){e[0]=Math.min(e[0],t[0]-t[3]),e[1]=Math.min(e[1],t[1]-t[3]),e[2]=Math.min(e[2],t[2]-t[3])}function _t(e,t){e[0]=Math.max(e[0],t[0]+t[3]),e[1]=Math.max(e[1],t[1]+t[3]),e[2]=Math.max(e[2],t[2]+t[3])}function xt(e,t,n){n[0]=e[0]+t,n[1]=e[1]+t,n[2]=e[2]+t}function wt(e,t){return!Ue.intersectsSphere(t,e)}function At(e,t,n,r){if(1===t){const t=n(e[0]);Fe.copy(t,r)}else{Dt[0]=1/0,Dt[1]=1/0,Dt[2]=1/0,Ft[0]=-1/0,Ft[1]=-1/0,Ft[2]=-1/0;for(let r=0;r<t;r++){const t=n(e[r]);zt(t[3])&&(vt(Dt,t),_t(Ft,t))}z(r,Dt,Ft,.5),r[3]=Math.max(Ft[0]-Dt[0],Ft[1]-Dt[1],Ft[2]-Dt[2])/2}}function jt(e,t){let n=1/0,r=null;for(let s=0;s<8;++s){const o=Mt(e,t,Ot[s]);o<n&&(n=o,r=Ot[s])}return r}function Mt(e,t,n){return t*(e[0]*n[0]+e[1]*n[1]+e[2]*n[2])}function zt(e){return!isNaN(e)&&e!==-1/0&&e!==1/0&&e>0}bt._pool=new t(bt);const Pt=[m(-1,-1,-1),m(1,-1,-1),m(-1,1,-1),m(1,1,-1),m(-1,-1,1),m(1,-1,1),m(-1,1,1),m(1,1,1)],Ot=[m(-1,-1,-1),m(-1,-1,1),m(-1,1,-1),m(-1,1,1),m(1,-1,-1),m(1,-1,1),m(1,1,-1),m(1,1,1)],St=Math.sqrt(3),Ct=[null];const Et=Fe.create(),Tt=d(),Dt=d(),Ft=d(),Ut=new c,qt=Fe.create(),Gt=Fe.create(),Rt=Fe.create(),Nt=Fe.create(),It=[{min:0,max:0},{min:0,max:0},{min:0,max:0}],Bt=new c,Lt=[0,0,0,0,0,0,0,0];class kt extends Ne{constructor(e,t=""){super(),this.apiLayerUid=t,this.type=0,this.events=new u,this.isSliceable=!1,this._objects=new c,this._stageHandles=new T,this.apiLayerUid=t,e=e||{},this.group=e.group||"",this.isVisible=null==e.isVisible||e.isVisible,this.isPickable=null==e.isPickable||e.isPickable,this.translation=e.translation?g(e.translation):d()}destroy(){this.detachStage(),this._stage=null}attachStage(e){this.detachStage(),this._stage=e;for(const t of gt)this._stageHandles.add(this.events.on(t,(n=>e.handleEvent(t,n))))}detachStage(){this._stageHandles.removeAll(),this.invalidateSpatialQueryAccelerator()}getObjectIds(){return this._objects.map((e=>e.id))}getObjects(){return this._objects}add(e){this._objects.push(e),e.parentLayer=this,this.events.emit("layerObjectAdded",{layer:this,object:e}),a(this._octree)&&this._octree.add([e])}remove(e){this._objects.removeUnordered(e)&&(e.parentLayer=null,this.events.emit("layerObjectRemoved",{layer:this,object:e}),a(this._octree)&&this._octree.remove([e]))}addMany(e){this._objects.pushArray(e);for(const t of e)t.parentLayer=this;this.events.emit("layerObjectsAdded",{layer:this,objects:e}),a(this._octree)&&this._octree.add(e)}removeMany(e){const t=new Array;if(this._objects.removeUnorderedMany(e,e.length,t),0!==t.length){for(const e of t)e.parentLayer=null;this.events.emit("layerObjectsRemoved",{layer:this,objects:t}),a(this._octree)&&this._octree.remove(t)}}commit(){a(this._stage)&&this._stage.processDirtyLayer(this.id)}notifyObjectBBChanged(e,t){a(this._octree)&&this._octree.update(e,t)}getSpatialQueryAccelerator(){return i(this._octree)&&this._objects.length>50&&this._createOctree(),this._octree}shaderTransformationChanged(){this.invalidateSpatialQueryAccelerator(),this.events.emit("shaderTransformationChanged",this)}invalidateSpatialQueryAccelerator(){this._octree=l(this._octree)}_createOctree(){this._octree=new yt((e=>e.getBounds())),this._octree.add(this._objects.data,this._objects.length)}}function Ht(e){return a(e)&&0===e.type}function Vt(e){e.attributes.add("position","vec2"),e.varyings.add("uv","vec2"),e.vertex.code.add(Z`
    void main(void) {
      gl_Position = vec4(position, 0.0, 1.0);
      uv = position * 0.5 + vec2(0.5);
    }
  `)}const Wt=Oe().vec3f("position"),Zt=Oe().vec3f("position").vec2f("uv0"),$t=Oe().vec3f("position").vec4u8("color");class Qt{constructor(e){this.vertexBufferLayout=e}allocate(e){return this.vertexBufferLayout.createBuffer(e)}elementCount(e){return e.indices.get("position").length}write(e,t,n,r){$(t,this.vertexBufferLayout,e.transformation,e.invTranspTransformation,n,r)}}var Jt=Object.freeze({__proto__:null,build:function(e){const t=new Q,n=1===e.output;return t.include(J,{linearDepth:n}),t.include(K,e),t.vertex.uniforms.add("proj","mat4").add("view","mat4"),t.attributes.add("position","vec3"),t.varyings.add("vpos","vec3"),e.multipassTerrainEnabled&&t.varyings.add("depth","float"),n&&(t.include(X,e),t.vertex.uniforms.add("cameraNearFar","vec2"),t.varyings.add("linearDepth","float")),t.vertex.code.add(Z`
    void main(void) {
      vpos = position;
      forwardNormalizedVertexColor();
      ${e.multipassTerrainEnabled?"depth = (view * vec4(vpos, 1.0)).z;":""}
      gl_Position = ${n?Z`transformPositionWithDepth(proj, view, vpos, cameraNearFar, linearDepth);`:Z`transformPosition(proj, view, vpos);`}
    }
  `),t.include(Y,e),t.fragment.include(ee),e.multipassTerrainEnabled&&(t.fragment.include(te),t.include(ne,e)),t.fragment.uniforms.add("eColor","vec4"),4===e.output&&t.include(re),t.fragment.code.add(Z`
  void main() {
    discardBySlice(vpos);
    ${e.multipassTerrainEnabled?"terrainDepthTest(gl_FragCoord, depth);":""}
    vec4 color = ${e.attributeColor?"vColor * eColor;":"eColor;"}

    if (color.a < ${Z.float(se)}) {
      discard;
    }

    ${7===e.output?Z`gl_FragColor = vec4(color.a);`:""}

    ${0===e.output?Z`gl_FragColor = highlightSlice(color, vpos); ${e.OITEnabled?"gl_FragColor = premultiplyAlpha(gl_FragColor);":""}`:""}
    ${4===e.output?Z`outputHighlight();`:""};
    ${1===e.output?Z`outputDepth(linearDepth);`:""};
  }
  `),t}});class Kt extends ae{initializeProgram(e){const t=Kt.shader.get(),n=this.configuration,r=t.build({output:n.output,OITEnabled:0===n.transparencyPassType,attributeColor:n.vertexColors,slicePlaneEnabled:n.slicePlaneEnabled,sliceHighlightDisabled:!1,sliceEnabledForVertexPrograms:!1,multipassTerrainEnabled:n.multipassTerrainEnabled,cullAboveGround:n.cullAboveGround});return new je(e.rctx,r.generateSource("vertex"),r.generateSource("fragment"),le)}bindPass(e,t,n){ce.bindProjectionMatrix(this.program,n.camera.projectionMatrix),this.program.setUniform4fv("eColor",t.color),4===this.configuration.output&&re.bindOutputHighlight(e,this.program,n),(1===this.configuration.output||n.multipassTerrainEnabled)&&this.program.setUniform2fv("cameraNearFar",n.camera.nearFar),n.multipassTerrainEnabled&&(this.program.setUniform2fv("inverseViewport",n.inverseViewport),ue(this.program,e,n))}bindDraw(e){ce.bindView(this.program,e),Y.bindUniformsWithOrigin(this.program,this.configuration,e)}setPipelineState(e,t){const n=this.configuration,r=3===e,s=2===e;return Me({blending:0!==n.output&&7!==n.output||!n.transparent?null:r?he:de(e),culling:(o=n.cullFace,0!==o&&{face:1===o?1028:1029,mode:2305}),depthTest:{func:fe(e)},depthWrite:r||s?n.writeDepth&&ze:null,colorWrite:Pe,stencilWrite:n.sceneHasOcludees?pe:null,stencilTest:n.sceneHasOcludees?t?me:ge:null,polygonOffset:r||s?n.polygonOffset&&Xt:ye(n.enableOffset)});var o}initializePipeline(){return this._occludeePipelineState=this.setPipelineState(this.configuration.transparencyPassType,!0),this.setPipelineState(this.configuration.transparencyPassType,!1)}getPipelineState(e){return e?this._occludeePipelineState:this.pipeline}}Kt.shader=new be(Jt,(()=>Promise.resolve().then((function(){return Jt}))));const Xt={factor:1,units:1};class Yt extends ie{constructor(){super(...arguments),this.output=0,this.cullFace=0,this.slicePlaneEnabled=!1,this.vertexColors=!1,this.transparent=!1,this.polygonOffset=!1,this.enableOffset=!0,this.writeDepth=!0,this.sceneHasOcludees=!1,this.transparencyPassType=3,this.multipassTerrainEnabled=!1,this.cullAboveGround=!0}}e([oe({count:8})],Yt.prototype,"output",void 0),e([oe({count:3})],Yt.prototype,"cullFace",void 0),e([oe()],Yt.prototype,"slicePlaneEnabled",void 0),e([oe()],Yt.prototype,"vertexColors",void 0),e([oe()],Yt.prototype,"transparent",void 0),e([oe()],Yt.prototype,"polygonOffset",void 0),e([oe()],Yt.prototype,"enableOffset",void 0),e([oe()],Yt.prototype,"writeDepth",void 0),e([oe()],Yt.prototype,"sceneHasOcludees",void 0),e([oe({count:4})],Yt.prototype,"transparencyPassType",void 0),e([oe()],Yt.prototype,"multipassTerrainEnabled",void 0),e([oe()],Yt.prototype,"cullAboveGround",void 0);class en extends ve{constructor(e){super(e,nn),this.supportsEdges=!0,this.techniqueConfig=new Yt}getTechniqueConfig(e,t){return this.techniqueConfig.output=e,this.techniqueConfig.cullFace=this.params.cullFace,this.techniqueConfig.vertexColors=this.params.vertexColors,this.techniqueConfig.slicePlaneEnabled=this.params.slicePlaneEnabled,this.techniqueConfig.transparent=this.params.transparent,this.techniqueConfig.polygonOffset=this.params.polygonOffset,this.techniqueConfig.writeDepth=this.params.writeDepth,this.techniqueConfig.sceneHasOcludees=this.params.sceneHasOcludees,this.techniqueConfig.transparencyPassType=t?t.transparencyPassType:3,this.techniqueConfig.enableOffset=!t||t.camera.relativeElevation<_e,this.techniqueConfig.multipassTerrainEnabled=!!t&&t.multipassTerrainEnabled,this.techniqueConfig.cullAboveGround=!t||t.cullAboveGround,this.techniqueConfig}getPassParameters(){return this.params}intersect(e,t,n,r,s,o,i){xe(e,t,r,s,o,void 0,i)}getGLMaterial(e){return 0===e.output||7===e.output||4===e.output||1===e.output&&this.params.writeLinearDepth?new tn(e):void 0}createBufferWriter(){return new Qt($t)}}class tn extends we{constructor(e){super(e),this.updateParameters()}updateParameters(e){this.technique=this.techniqueRep.acquireAndReleaseExisting(Kt,this.material.getTechniqueConfig(this.output,e),this.technique)}beginSlot(e){if(4===this.output)return 3===e;return e===(this.technique.configuration.transparent?this.technique.configuration.writeDepth?5:8:3)}_updateOccludeeState(e){e.hasOccludees!==this.material.params.sceneHasOcludees&&this.material.setParameterValues({sceneHasOcludees:e.hasOccludees})}ensureParameters(e){0!==this.output&&7!==this.output||this._updateOccludeeState(e),this.updateParameters(e)}bind(e,t){e.bindProgram(this.technique.program),this.technique.bindPass(e,this.material.getPassParameters(),t)}getPipelineState(e,t){return this.technique.getPipelineState(t)}}const nn={color:[1,1,1,1],transparent:!1,writeDepth:!0,writeLinearDepth:!1,vertexColors:!1,polygonOffset:!1,slicePlaneEnabled:!1,cullFace:0,sceneHasOcludees:!1,...Ae};export{en as C,Qt as D,$e as G,yt as O,Zt as P,Vt as S,kt as W,ut as a,ft as b,rt as c,pt as d,Ht as e,Xe as f,$t as g,Ke as h,dt as i,Wt as j,nt as k,it as l,lt as m,mt as n,ct as o,at as u,ht as v};
