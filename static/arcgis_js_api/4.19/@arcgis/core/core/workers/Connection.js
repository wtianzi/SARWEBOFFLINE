/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.19/esri/copyright.txt for details.
*/
import"../../chunks/tslib.es6.js";import"../../chunks/ArrayPool.js";import"../lang.js";import"../../chunks/deprecate.js";import"../../chunks/object.js";import"../../kernel.js";import"../../config.js";import{L as e}from"../../chunks/Logger.js";import"../../chunks/string.js";import{h as t}from"../../chunks/metadata.js";import"../accessorSupport/decorators/property.js";import"../Accessor.js";import"../../chunks/PropertyOrigin.js";import"../scheduling.js";import{isPromiseLike as s,throwIfAborted as i}from"../promiseUtils.js";import"../../chunks/Message.js";import"../Error.js";import"../../chunks/ensureType.js";import"../accessorSupport/decorators/subclass.js";import"../urlUtils.js";import"../../chunks/resourceExtension.js";import"../watchUtils.js";import"../../chunks/Scheduler.js";import r from"./RemoteClient.js";const n=e.getLogger("esri.core.workers.Connection");export default class{constructor(){this._clients=new Array,this._clientPromises=new Array,this._clientIdx=0}destroy(){this.close()}get closed(){return!this._clients||!this._clients.length}open(e,t){return new Promise(((n,o)=>{let l=!0;const c=e=>{i(t.signal),l&&(l=!1,e())};this._clients.length=e.length,this._clientPromises.length=e.length;for(let i=0;i<e.length;++i){const l=e[i];s(l)?this._clientPromises[i]=l.then((e=>(this._clients[i]=new r(e,t),c(n),this._clients[i])),(()=>(c(o),null))):(this._clients[i]=new r(l,t),this._clientPromises[i]=Promise.resolve(this._clients[i]),c(n))}}))}broadcast(e,t,s){const i=new Array(this._clientPromises.length);for(let r=0;r<this._clientPromises.length;++r){const n=this._clientPromises[r];i[r]=n.then((i=>i.invoke(e,t,s)))}return i}close(){for(const e of this._clientPromises)e.then((e=>e.close()));this._clients.length=0,this._clientPromises.length=0}getAvailableClient(){let e;for(let t=0;t<this._clients.length;++t){const s=this._clients[t];if(s){if(!s.isBusy())return Promise.resolve(s)}else e=e||[],e.push(this._clientPromises[t])}return e?Promise.race(e):(this._clientIdx=(this._clientIdx+1)%this._clients.length,Promise.resolve(this._clients[this._clientIdx]))}invoke(e,t,s){let i=null;if(Array.isArray(s)?(n.warn("invoke()","The transferList parameter is deprecated, use the options object instead"),i={transferList:s}):i=s,this.closed)return Promise.reject(new Error("Connection closed"));return this.getAvailableClient().then((s=>s.invoke(e,t,i)))}on(e,s){return Promise.all(this._clientPromises).then((()=>t(this._clients.map((t=>t.on(e,s))))))}openPorts(){return new Promise((e=>{const t=new Array(this._clientPromises.length);let s=t.length;for(let i=0;i<this._clientPromises.length;++i){this._clientPromises[i].then((r=>{t[i]=r.openPort(),0==--s&&e(t)}))}}))}get test(){return{numClients:this._clients.length}}}
